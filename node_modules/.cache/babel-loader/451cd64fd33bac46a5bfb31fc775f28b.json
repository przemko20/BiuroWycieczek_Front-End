{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    `@apply` --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n'use strict';\n\nimport _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { forEachRule, processVariableAndFallback, rulesForStyle, toCssText, gatherStyleText } from './style-util.js';\nimport { MIXIN_MATCH, VAR_ASSIGN } from './common-regex.js';\nimport { detectMixin as _detectMixin } from './common-utils.js';\nimport { StyleNode } from './css-parse.js'; // eslint-disable-line no-unused-vars\n\nvar APPLY_NAME_CLEAN = /;\\s*/m;\nvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nvar IMPORTANT = /\\s*!important/; // separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\n\nvar MIXIN_VAR_SEP = '_-_';\n/**\n * @typedef {!Object<string, string>}\n */\n\nvar PropertyEntry; // eslint-disable-line no-unused-vars\n\n/**\n * @typedef {!Object<string, boolean>}\n */\n\nvar DependantsEntry; // eslint-disable-line no-unused-vars\n\n/** @typedef {{\n *    properties: PropertyEntry,\n *    dependants: DependantsEntry\n * }}\n */\n\nvar MixinMapEntry; // eslint-disable-line no-unused-vars\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\nvar MixinMap =\n/*#__PURE__*/\nfunction () {\n  function MixinMap() {\n    _classCallCheck(this, MixinMap);\n\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!PropertyEntry} props\n   */\n\n\n  _createClass(MixinMap, [{\n    key: \"set\",\n    value: function set(name, props) {\n      name = name.trim();\n      this._map[name] = {\n        properties: props,\n        dependants: {}\n      };\n    }\n    /**\n     * @param {string} name\n     * @return {MixinMapEntry}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      name = name.trim();\n      return this._map[name] || null;\n    }\n  }]);\n\n  return MixinMap;\n}();\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\n\n\nvar invalidCallback = null;\n/** @unrestricted */\n\nvar ApplyShim =\n/*#__PURE__*/\nfunction () {\n  function ApplyShim() {\n    _classCallCheck(this, ApplyShim);\n\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n\n\n  _createClass(ApplyShim, [{\n    key: \"detectMixin\",\n    value: function detectMixin(cssText) {\n      return _detectMixin(cssText);\n    }\n    /**\n     * Gather styles into one style for easier processing\n     * @param {!HTMLTemplateElement} template\n     * @return {HTMLStyleElement}\n     */\n\n  }, {\n    key: \"gatherStyles\",\n    value: function gatherStyles(template) {\n      var styleText = gatherStyleText(template.content);\n\n      if (styleText) {\n        var style =\n        /** @type {!HTMLStyleElement} */\n        document.createElement('style');\n        style.textContent = styleText;\n        template.content.insertBefore(style, template.content.firstChild);\n        return style;\n      }\n\n      return null;\n    }\n    /**\n     * @param {!HTMLTemplateElement} template\n     * @param {string} elementName\n     * @return {StyleNode}\n     */\n\n  }, {\n    key: \"transformTemplate\",\n    value: function transformTemplate(template, elementName) {\n      if (template._gatheredStyle === undefined) {\n        template._gatheredStyle = this.gatherStyles(template);\n      }\n      /** @type {HTMLStyleElement} */\n\n\n      var style = template._gatheredStyle;\n      return style ? this.transformStyle(style, elementName) : null;\n    }\n    /**\n     * @param {!HTMLStyleElement} style\n     * @param {string} elementName\n     * @return {StyleNode}\n     */\n\n  }, {\n    key: \"transformStyle\",\n    value: function transformStyle(style) {\n      var elementName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var ast = rulesForStyle(style);\n      this.transformRules(ast, elementName);\n      style.textContent = toCssText(ast);\n      return ast;\n    }\n    /**\n     * @param {!HTMLStyleElement} style\n     * @return {StyleNode}\n     */\n\n  }, {\n    key: \"transformCustomStyle\",\n    value: function transformCustomStyle(style) {\n      var _this = this;\n\n      var ast = rulesForStyle(style);\n      forEachRule(ast, function (rule) {\n        if (rule['selector'] === ':root') {\n          rule['selector'] = 'html';\n        }\n\n        _this.transformRule(rule);\n      });\n      style.textContent = toCssText(ast);\n      return ast;\n    }\n    /**\n     * @param {StyleNode} rules\n     * @param {string} elementName\n     */\n\n  }, {\n    key: \"transformRules\",\n    value: function transformRules(rules, elementName) {\n      var _this2 = this;\n\n      this._currentElement = elementName;\n      forEachRule(rules, function (r) {\n        _this2.transformRule(r);\n      });\n      this._currentElement = null;\n    }\n    /**\n     * @param {!StyleNode} rule\n     */\n\n  }, {\n    key: \"transformRule\",\n    value: function transformRule(rule) {\n      rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule); // :root was only used for variable assignment in property shim,\n      // but generates invalid selectors with real properties.\n      // replace with `:host > *`, which serves the same effect\n\n      if (rule['selector'] === ':root') {\n        rule['selector'] = ':host > *';\n      }\n    }\n    /**\n     * @param {string} cssText\n     * @param {!StyleNode} rule\n     * @return {string}\n     */\n\n  }, {\n    key: \"transformCssText\",\n    value: function transformCssText(cssText, rule) {\n      var _this3 = this;\n\n      // produce variables\n      cssText = cssText.replace(VAR_ASSIGN, function (matchText, propertyName, valueProperty, valueMixin) {\n        return _this3._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule);\n      }); // consume mixins\n\n      return this._consumeCssProperties(cssText, rule);\n    }\n    /**\n     * @param {string} property\n     * @return {string}\n     */\n\n  }, {\n    key: \"_getInitialValueForProperty\",\n    value: function _getInitialValueForProperty(property) {\n      if (!this._measureElement) {\n        this._measureElement =\n        /** @type {HTMLMetaElement} */\n        document.createElement('meta');\n\n        this._measureElement.setAttribute('apply-shim-measure', '');\n\n        this._measureElement.style.all = 'initial';\n        document.head.appendChild(this._measureElement);\n      }\n\n      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n    }\n    /**\n     * Walk over all rules before this rule to find fallbacks for mixins\n     *\n     * @param {!StyleNode} startRule\n     * @return {!Object}\n     */\n\n  }, {\n    key: \"_fallbacksFromPreviousRules\",\n    value: function _fallbacksFromPreviousRules(startRule) {\n      var _this4 = this;\n\n      // find the \"top\" rule\n      var topRule = startRule;\n\n      while (topRule['parent']) {\n        topRule = topRule['parent'];\n      }\n\n      var fallbacks = {};\n      var seenStartRule = false;\n      forEachRule(topRule, function (r) {\n        // stop when we hit the input rule\n        seenStartRule = seenStartRule || r === startRule;\n\n        if (seenStartRule) {\n          return;\n        } // NOTE: Only matching selectors are \"safe\" for this fallback processing\n        // It would be prohibitive to run `matchesSelector()` on each selector,\n        // so we cheat and only check if the same selector string is used, which\n        // guarantees things like specificity matching\n\n\n        if (r['selector'] === startRule['selector']) {\n          Object.assign(fallbacks, _this4._cssTextToMap(r['parsedCssText']));\n        }\n      });\n      return fallbacks;\n    }\n    /**\n     * replace mixin consumption with variable consumption\n     * @param {string} text\n     * @param {!StyleNode=} rule\n     * @return {string}\n     */\n\n  }, {\n    key: \"_consumeCssProperties\",\n    value: function _consumeCssProperties(text, rule) {\n      /** @type {Array} */\n      var m = null; // loop over text until all mixins with defintions have been applied\n\n      while (m = MIXIN_MATCH.exec(text)) {\n        var matchText = m[0];\n        var mixinName = m[1];\n        var idx = m.index; // collect properties before apply to be \"defaults\" if mixin might override them\n        // match includes a \"prefix\", so find the start and end positions of @apply\n\n        var applyPos = idx + matchText.indexOf('@apply');\n        var afterApplyPos = idx + matchText.length; // find props defined before this @apply\n\n        var textBeforeApply = text.slice(0, applyPos);\n        var textAfterApply = text.slice(afterApplyPos);\n        var defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};\n        Object.assign(defaults, this._cssTextToMap(textBeforeApply));\n\n        var replacement = this._atApplyToCssProperties(mixinName, defaults); // use regex match position to replace mixin, keep linear processing time\n\n\n        text = \"\".concat(textBeforeApply).concat(replacement).concat(textAfterApply); // move regex search to _after_ replacement\n\n        MIXIN_MATCH.lastIndex = idx + replacement.length;\n      }\n\n      return text;\n    }\n    /**\n     * produce variable consumption at the site of mixin consumption\n     * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n     * Example:\n     *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n     *\n     * @param {string} mixinName\n     * @param {Object} fallbacks\n     * @return {string}\n     */\n\n  }, {\n    key: \"_atApplyToCssProperties\",\n    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n      var vars = [];\n\n      var mixinEntry = this._map.get(mixinName); // if we depend on a mixin before it is created\n      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\n\n      if (!mixinEntry) {\n        this._map.set(mixinName, {});\n\n        mixinEntry = this._map.get(mixinName);\n      }\n\n      if (mixinEntry) {\n        if (this._currentElement) {\n          mixinEntry.dependants[this._currentElement] = true;\n        }\n\n        var p, parts, f;\n        var properties = mixinEntry.properties;\n\n        for (p in properties) {\n          f = fallbacks && fallbacks[p];\n          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\n          if (f) {\n            parts.push(',', f.replace(IMPORTANT, ''));\n          }\n\n          parts.push(')');\n\n          if (IMPORTANT.test(properties[p])) {\n            parts.push(' !important');\n          }\n\n          vars.push(parts.join(''));\n        }\n      }\n\n      return vars.join('; ');\n    }\n    /**\n     * @param {string} property\n     * @param {string} value\n     * @return {string}\n     */\n\n  }, {\n    key: \"_replaceInitialOrInherit\",\n    value: function _replaceInitialOrInherit(property, value) {\n      var match = INITIAL_INHERIT.exec(value);\n\n      if (match) {\n        if (match[1]) {\n          // initial\n          // replace `initial` with the concrete initial value for this property\n          value = this._getInitialValueForProperty(property);\n        } else {\n          // inherit\n          // with this purposfully illegal value, the variable will be invalid at\n          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n          // and for inheriting values, will behave similarly\n          // we cannot support the same behavior for non inheriting values like 'border'\n          value = 'apply-shim-inherit';\n        }\n      }\n\n      return value;\n    }\n    /**\n     * \"parse\" a mixin definition into a map of properties and values\n     * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n     * @param {string} text\n     * @param {boolean=} replaceInitialOrInherit\n     * @return {!Object<string, string>}\n     */\n\n  }, {\n    key: \"_cssTextToMap\",\n    value: function _cssTextToMap(text) {\n      var replaceInitialOrInherit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var props = text.split(';');\n      var property, value;\n      var out = {};\n\n      for (var i = 0, p, sp; i < props.length; i++) {\n        p = props[i];\n\n        if (p) {\n          sp = p.split(':'); // ignore lines that aren't definitions like @media\n\n          if (sp.length > 1) {\n            property = sp[0].trim(); // some properties may have ':' in the value, like data urls\n\n            value = sp.slice(1).join(':');\n\n            if (replaceInitialOrInherit) {\n              value = this._replaceInitialOrInherit(property, value);\n            }\n\n            out[property] = value;\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * @param {MixinMapEntry} mixinEntry\n     */\n\n  }, {\n    key: \"_invalidateMixinEntry\",\n    value: function _invalidateMixinEntry(mixinEntry) {\n      if (!invalidCallback) {\n        return;\n      }\n\n      for (var elementName in mixinEntry.dependants) {\n        if (elementName !== this._currentElement) {\n          invalidCallback(elementName);\n        }\n      }\n    }\n    /**\n     * @param {string} matchText\n     * @param {string} propertyName\n     * @param {?string} valueProperty\n     * @param {?string} valueMixin\n     * @param {!StyleNode} rule\n     * @return {string}\n     */\n\n  }, {\n    key: \"_produceCssProperties\",\n    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {\n      var _this5 = this;\n\n      // handle case where property value is a mixin\n      if (valueProperty) {\n        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n        processVariableAndFallback(valueProperty, function (prefix, value) {\n          if (value && _this5._map.get(value)) {\n            valueMixin = \"@apply \".concat(value, \";\");\n          }\n        });\n      }\n\n      if (!valueMixin) {\n        return matchText;\n      }\n\n      var mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);\n\n      var prefix = matchText.slice(0, matchText.indexOf('--')); // `initial` and `inherit` as properties in a map should be replaced because\n      // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,\n      // and would set the variable value, rather than carry the keyword to the `var()` usage.\n\n      var mixinValues = this._cssTextToMap(mixinAsProperties, true);\n\n      var combinedProps = mixinValues;\n\n      var mixinEntry = this._map.get(propertyName);\n\n      var oldProps = mixinEntry && mixinEntry.properties;\n\n      if (oldProps) {\n        // NOTE: since we use mixin, the map of properties is updated here\n        // and this is what we want.\n        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n      } else {\n        this._map.set(propertyName, combinedProps);\n      }\n\n      var out = [];\n      var p, v; // set variables defined by current mixin\n\n      var needToInvalidate = false;\n\n      for (p in combinedProps) {\n        v = mixinValues[p]; // if property not defined by current mixin, set initial\n\n        if (v === undefined) {\n          v = 'initial';\n        }\n\n        if (oldProps && !(p in oldProps)) {\n          needToInvalidate = true;\n        }\n\n        out.push(\"\".concat(propertyName).concat(MIXIN_VAR_SEP).concat(p, \": \").concat(v));\n      }\n\n      if (needToInvalidate) {\n        this._invalidateMixinEntry(mixinEntry);\n      }\n\n      if (mixinEntry) {\n        mixinEntry.properties = combinedProps;\n      } // because the mixinMap is global, the mixin might conflict with\n      // a different scope's simple variable definition:\n      // Example:\n      // some style somewhere:\n      // --mixin1:{ ... }\n      // --mixin2: var(--mixin1);\n      // some other element:\n      // --mixin1: 10px solid red;\n      // --foo: var(--mixin1);\n      // In this case, we leave the original variable definition in place.\n\n\n      if (valueProperty) {\n        prefix = \"\".concat(matchText, \";\").concat(prefix);\n      }\n\n      return \"\".concat(prefix).concat(out.join('; '), \";\");\n    }\n  }]);\n\n  return ApplyShim;\n}();\n/* exports */\n\n/* eslint-disable no-self-assign */\n\n\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\n/* eslint-enable no-self-assign */\n\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */\n  get: function get() {\n    return invalidCallback;\n  },\n\n  /** @param {?function(string)} cb */\n  set: function set(cb) {\n    invalidCallback = cb;\n  }\n});\nexport default ApplyShim;","map":null,"metadata":{},"sourceType":"module"}