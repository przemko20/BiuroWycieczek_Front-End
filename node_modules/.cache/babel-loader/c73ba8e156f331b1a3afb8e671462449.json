{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nimport { calculateSplices } from './array-splice.js';\nimport { microTask } from './async.js';\n/**\n * Returns true if `node` is a slot element\n * @param {!Node} node Node to test.\n * @return {boolean} Returns true if the given `node` is a slot\n * @private\n */\n\nfunction isSlot(node) {\n  return node.localName === 'slot';\n}\n/**\n * Class that listens for changes (additions or removals) to\n * \"flattened nodes\" on a given `node`. The list of flattened nodes consists\n * of a node's children and, for any children that are `<slot>` elements,\n * the expanded flattened list of `assignedNodes`.\n * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n * and the `<slot>` has one `<div>` assigned to it, then the flattened\n * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n * `<slot>` elements assigned to it, these are flattened as well.\n *\n * The provided `callback` is called whenever any change to this list\n * of flattened nodes occurs, where an addition or removal of a node is\n * considered a change. The `callback` is called with one argument, an object\n * containing an array of any `addedNodes` and `removedNodes`.\n *\n * Note: the callback is called asynchronous to any changes\n * at a microtask checkpoint. This is because observation is performed using\n * `MutationObserver` and the `<slot>` element's `slotchange` event which\n * are asynchronous.\n *\n * An example:\n * ```js\n * class TestSelfObserve extends PolymerElement {\n *   static get is() { return 'test-self-observe';}\n *   connectedCallback() {\n *     super.connectedCallback();\n *     this._observer = new FlattenedNodesObserver(this, (info) => {\n *       this.info = info;\n *     });\n *   }\n *   disconnectedCallback() {\n *     super.disconnectedCallback();\n *     this._observer.disconnect();\n *   }\n * }\n * customElements.define(TestSelfObserve.is, TestSelfObserve);\n * ```\n *\n * @summary Class that listens for changes (additions or removals) to\n * \"flattened nodes\" on a given `node`.\n */\n\n\nexport var FlattenedNodesObserver =\n/*#__PURE__*/\nfunction () {\n  _createClass(FlattenedNodesObserver, null, [{\n    key: \"getFlattenedNodes\",\n\n    /**\n     * Returns the list of flattened nodes for the given `node`.\n     * This list consists of a node's children and, for any children\n     * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.\n     * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n     * and the `<slot>` has one `<div>` assigned to it, then the flattened\n     * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n     * `<slot>` elements assigned to it, these are flattened as well.\n     *\n     * @param {!HTMLElement|!HTMLSlotElement} node The node for which to\n     *      return the list of flattened nodes.\n     * @return {!Array<!Node>} The list of flattened nodes for the given `node`.\n     * @nocollapse See https://github.com/google/closure-compiler/issues/2763\n     */\n    value: function getFlattenedNodes(node) {\n      if (isSlot(node)) {\n        node =\n        /** @type {!HTMLSlotElement} */\n        node; // eslint-disable-line no-self-assign\n\n        return node.assignedNodes({\n          flatten: true\n        });\n      } else {\n        return Array.from(node.childNodes).map(function (node) {\n          if (isSlot(node)) {\n            node =\n            /** @type {!HTMLSlotElement} */\n            node; // eslint-disable-line no-self-assign\n\n            return node.assignedNodes({\n              flatten: true\n            });\n          } else {\n            return [node];\n          }\n        }).reduce(function (a, b) {\n          return a.concat(b);\n        }, []);\n      }\n    }\n    /**\n     * @param {!HTMLElement} target Node on which to listen for changes.\n     * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions\n     * or removals from the target's list of flattened nodes.\n     */\n\n  }]);\n\n  function FlattenedNodesObserver(target, callback) {\n    var _this = this;\n\n    _classCallCheck(this, FlattenedNodesObserver);\n\n    /**\n     * @type {MutationObserver}\n     * @private\n     */\n    this._shadyChildrenObserver = null;\n    /**\n     * @type {MutationObserver}\n     * @private\n     */\n\n    this._nativeChildrenObserver = null;\n    this._connected = false;\n    /**\n     * @type {!HTMLElement}\n     * @private\n     */\n\n    this._target = target;\n    this.callback = callback;\n    this._effectiveNodes = [];\n    this._observer = null;\n    this._scheduled = false;\n    /**\n     * @type {function()}\n     * @private\n     */\n\n    this._boundSchedule = function () {\n      _this._schedule();\n    };\n\n    this.connect();\n\n    this._schedule();\n  }\n  /**\n   * Activates an observer. This method is automatically called when\n   * a `FlattenedNodesObserver` is created. It should only be called to\n   * re-activate an observer that has been deactivated via the `disconnect` method.\n   *\n   * @return {void}\n   */\n\n\n  _createClass(FlattenedNodesObserver, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      if (isSlot(this._target)) {\n        this._listenSlots([this._target]);\n      } else if (this._target.children) {\n        this._listenSlots(\n        /** @type {!NodeList<!Node>} */\n        this._target.children);\n\n        if (window.ShadyDOM) {\n          this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {\n            _this2._processMutations(mutations);\n          });\n        } else {\n          this._nativeChildrenObserver = new MutationObserver(function (mutations) {\n            _this2._processMutations(mutations);\n          });\n\n          this._nativeChildrenObserver.observe(this._target, {\n            childList: true\n          });\n        }\n      }\n\n      this._connected = true;\n    }\n    /**\n     * Deactivates the flattened nodes observer. After calling this method\n     * the observer callback will not be called when changes to flattened nodes\n     * occur. The `connect` method may be subsequently called to reactivate\n     * the observer.\n     *\n     * @return {void}\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (isSlot(this._target)) {\n        this._unlistenSlots([this._target]);\n      } else if (this._target.children) {\n        this._unlistenSlots(\n        /** @type {!NodeList<!Node>} */\n        this._target.children);\n\n        if (window.ShadyDOM && this._shadyChildrenObserver) {\n          ShadyDOM.unobserveChildren(this._shadyChildrenObserver);\n          this._shadyChildrenObserver = null;\n        } else if (this._nativeChildrenObserver) {\n          this._nativeChildrenObserver.disconnect();\n\n          this._nativeChildrenObserver = null;\n        }\n      }\n\n      this._connected = false;\n    }\n    /**\n     * @return {void}\n     * @private\n     */\n\n  }, {\n    key: \"_schedule\",\n    value: function _schedule() {\n      var _this3 = this;\n\n      if (!this._scheduled) {\n        this._scheduled = true;\n        microTask.run(function () {\n          return _this3.flush();\n        });\n      }\n    }\n    /**\n     * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer\n     * @return {void}\n     * @private\n     */\n\n  }, {\n    key: \"_processMutations\",\n    value: function _processMutations(mutations) {\n      this._processSlotMutations(mutations);\n\n      this.flush();\n    }\n    /**\n     * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer\n     * @return {void}\n     * @private\n     */\n\n  }, {\n    key: \"_processSlotMutations\",\n    value: function _processSlotMutations(mutations) {\n      if (mutations) {\n        for (var i = 0; i < mutations.length; i++) {\n          var mutation = mutations[i];\n\n          if (mutation.addedNodes) {\n            this._listenSlots(mutation.addedNodes);\n          }\n\n          if (mutation.removedNodes) {\n            this._unlistenSlots(mutation.removedNodes);\n          }\n        }\n      }\n    }\n    /**\n     * Flushes the observer causing any pending changes to be immediately\n     * delivered the observer callback. By default these changes are delivered\n     * asynchronously at the next microtask checkpoint.\n     *\n     * @return {boolean} Returns true if any pending changes caused the observer\n     * callback to run.\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (!this._connected) {\n        return false;\n      }\n\n      if (window.ShadyDOM) {\n        ShadyDOM.flush();\n      }\n\n      if (this._nativeChildrenObserver) {\n        this._processSlotMutations(this._nativeChildrenObserver.takeRecords());\n      } else if (this._shadyChildrenObserver) {\n        this._processSlotMutations(this._shadyChildrenObserver.takeRecords());\n      }\n\n      this._scheduled = false;\n      var info = {\n        target: this._target,\n        addedNodes: [],\n        removedNodes: []\n      };\n      var newNodes = this.constructor.getFlattenedNodes(this._target);\n      var splices = calculateSplices(newNodes, this._effectiveNodes); // process removals\n\n      for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\n        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n          info.removedNodes.push(n);\n        }\n      } // process adds\n\n\n      for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {\n        for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {\n          info.addedNodes.push(newNodes[_j]);\n        }\n      } // update cache\n\n\n      this._effectiveNodes = newNodes;\n      var didFlush = false;\n\n      if (info.addedNodes.length || info.removedNodes.length) {\n        didFlush = true;\n        this.callback.call(this._target, info);\n      }\n\n      return didFlush;\n    }\n    /**\n     * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change\n     * @return {void}\n     * @private\n     */\n\n  }, {\n    key: \"_listenSlots\",\n    value: function _listenSlots(nodeList) {\n      for (var i = 0; i < nodeList.length; i++) {\n        var n = nodeList[i];\n\n        if (isSlot(n)) {\n          n.addEventListener('slotchange', this._boundSchedule);\n        }\n      }\n    }\n    /**\n     * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change\n     * @return {void}\n     * @private\n     */\n\n  }, {\n    key: \"_unlistenSlots\",\n    value: function _unlistenSlots(nodeList) {\n      for (var i = 0; i < nodeList.length; i++) {\n        var n = nodeList[i];\n\n        if (isSlot(n)) {\n          n.removeEventListener('slotchange', this._boundSchedule);\n        }\n      }\n    }\n  }]);\n\n  return FlattenedNodesObserver;\n}();","map":null,"metadata":{},"sourceType":"module"}