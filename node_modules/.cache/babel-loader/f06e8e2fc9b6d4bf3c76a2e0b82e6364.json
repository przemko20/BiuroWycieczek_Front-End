{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport '../utils/settings.js';\nimport { FlattenedNodesObserver } from '../utils/flattened-nodes-observer.js';\nexport { flush, enqueueDebouncer as addDebouncer } from '../utils/flush.js';\n/* eslint-disable no-unused-vars */\n\nimport { Debouncer } from '../utils/debounce.js'; // used in type annotations\n\n/* eslint-enable no-unused-vars */\n\nvar p = Element.prototype;\n/**\n * @const {function(this:Node, string): boolean}\n */\n\nvar normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n/**\n * Cross-platform `element.matches` shim.\n *\n * @function matchesSelector\n * @param {!Node} node Node to check selector against\n * @param {string} selector Selector to match\n * @return {boolean} True if node matched selector\n */\n\nexport var matchesSelector = function matchesSelector(node, selector) {\n  return normalizedMatchesSelector.call(node, selector);\n};\n/**\n * Node API wrapper class returned from `Polymer.dom.(target)` when\n * `target` is a `Node`.\n *\n */\n\nexport var DomApi =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Node} node Node for which to create a Polymer.dom helper object.\n   */\n  function DomApi(node) {\n    _classCallCheck(this, DomApi);\n\n    this.node = node;\n  }\n  /**\n   * Returns an instance of `FlattenedNodesObserver` that\n   * listens for node changes on this element.\n   *\n   * @param {function(this:HTMLElement, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Called when direct or distributed children\n   *   of this element changes\n   * @return {!FlattenedNodesObserver} Observer instance\n   */\n\n\n  _createClass(DomApi, [{\n    key: \"observeNodes\",\n    value: function observeNodes(callback) {\n      return new FlattenedNodesObserver(\n      /** @type {!HTMLElement} */\n      this.node, callback);\n    }\n    /**\n     * Disconnects an observer previously created via `observeNodes`\n     *\n     * @param {!FlattenedNodesObserver} observerHandle Observer instance\n     *   to disconnect.\n     * @return {void}\n     */\n\n  }, {\n    key: \"unobserveNodes\",\n    value: function unobserveNodes(observerHandle) {\n      observerHandle.disconnect();\n    }\n    /**\n     * Provided as a backwards-compatible API only.  This method does nothing.\n     * @return {void}\n     */\n\n  }, {\n    key: \"notifyObserver\",\n    value: function notifyObserver() {}\n    /**\n     * Returns true if the provided node is contained with this element's\n     * light-DOM children or shadow root, including any nested shadow roots\n     * of children therein.\n     *\n     * @param {Node} node Node to test\n     * @return {boolean} Returns true if the given `node` is contained within\n     *   this element's light or shadow DOM.\n     */\n\n  }, {\n    key: \"deepContains\",\n    value: function deepContains(node) {\n      if (this.node.contains(node)) {\n        return true;\n      }\n\n      var n = node;\n      var doc = node.ownerDocument; // walk from node to `this` or `document`\n\n      while (n && n !== doc && n !== this.node) {\n        // use logical parentnode, or native ShadowRoot host\n        n = n.parentNode || n.host;\n      }\n\n      return n === this.node;\n    }\n    /**\n     * Returns the root node of this node.  Equivalent to `getRootNode()`.\n     *\n     * @return {Node} Top most element in the dom tree in which the node\n     * exists. If the node is connected to a document this is either a\n     * shadowRoot or the document; otherwise, it may be the node\n     * itself or a node or document fragment containing it.\n     */\n\n  }, {\n    key: \"getOwnerRoot\",\n    value: function getOwnerRoot() {\n      return this.node.getRootNode();\n    }\n    /**\n     * For slot elements, returns the nodes assigned to the slot; otherwise\n     * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.\n     *\n     * @return {!Array<!Node>} Array of assigned nodes\n     */\n\n  }, {\n    key: \"getDistributedNodes\",\n    value: function getDistributedNodes() {\n      return this.node.localName === 'slot' ? this.node.assignedNodes({\n        flatten: true\n      }) : [];\n    }\n    /**\n     * Returns an array of all slots this element was distributed to.\n     *\n     * @return {!Array<!HTMLSlotElement>} Description\n     */\n\n  }, {\n    key: \"getDestinationInsertionPoints\",\n    value: function getDestinationInsertionPoints() {\n      var ip$ = [];\n      var n = this.node.assignedSlot;\n\n      while (n) {\n        ip$.push(n);\n        n = n.assignedSlot;\n      }\n\n      return ip$;\n    }\n    /**\n     * Calls `importNode` on the `ownerDocument` for this node.\n     *\n     * @param {!Node} node Node to import\n     * @param {boolean} deep True if the node should be cloned deeply during\n     *   import\n     * @return {Node} Clone of given node imported to this owner document\n     */\n\n  }, {\n    key: \"importNode\",\n    value: function importNode(node, deep) {\n      var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;\n      return doc.importNode(node, deep);\n    }\n    /**\n     * @return {!Array<!Node>} Returns a flattened list of all child nodes and\n     * nodes assigned to child slots.\n     */\n\n  }, {\n    key: \"getEffectiveChildNodes\",\n    value: function getEffectiveChildNodes() {\n      return FlattenedNodesObserver.getFlattenedNodes(\n      /** @type {!HTMLElement} */\n      this.node);\n    }\n    /**\n     * Returns a filtered list of flattened child elements for this element based\n     * on the given selector.\n     *\n     * @param {string} selector Selector to filter nodes against\n     * @return {!Array<!HTMLElement>} List of flattened child elements\n     */\n\n  }, {\n    key: \"queryDistributedElements\",\n    value: function queryDistributedElements(selector) {\n      var c$ = this.getEffectiveChildNodes();\n      var list = [];\n\n      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\n        if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {\n          list.push(c);\n        }\n      }\n\n      return list;\n    }\n    /**\n     * For shadow roots, returns the currently focused element within this\n     * shadow root.\n     *\n     * @return {Node|undefined} Currently focused element\n     */\n\n  }, {\n    key: \"activeElement\",\n    get: function get() {\n      var node = this.node;\n      return node._activeElement !== undefined ? node._activeElement : node.activeElement;\n    }\n  }]);\n\n  return DomApi;\n}();\n\nfunction forwardMethods(proto, methods) {\n  var _loop = function _loop(i) {\n    var method = methods[i];\n    /* eslint-disable valid-jsdoc */\n\n    proto[method] =\n    /** @this {DomApi} */\n    function () {\n      return this.node[method].apply(this.node, arguments);\n    };\n    /* eslint-enable */\n\n  };\n\n  for (var i = 0; i < methods.length; i++) {\n    _loop(i);\n  }\n}\n\nfunction forwardReadOnlyProperties(proto, properties) {\n  var _loop2 = function _loop2(i) {\n    var name = properties[i];\n    Object.defineProperty(proto, name, {\n      get: function get() {\n        var domApi =\n        /** @type {DomApi} */\n        this;\n        return domApi.node[name];\n      },\n      configurable: true\n    });\n  };\n\n  for (var i = 0; i < properties.length; i++) {\n    _loop2(i);\n  }\n}\n\nfunction forwardProperties(proto, properties) {\n  var _loop3 = function _loop3(i) {\n    var name = properties[i];\n    Object.defineProperty(proto, name, {\n      /**\n       * @this {DomApi}\n       * @return {*} .\n       */\n      get: function get() {\n        return this.node[name];\n      },\n\n      /**\n       * @this {DomApi}\n       * @param {*} value .\n       */\n      set: function set(value) {\n        this.node[name] = value;\n      },\n      configurable: true\n    });\n  };\n\n  for (var i = 0; i < properties.length; i++) {\n    _loop3(i);\n  }\n}\n/**\n * Event API wrapper class returned from `dom.(target)` when\n * `target` is an `Event`.\n */\n\n\nexport var EventApi =\n/*#__PURE__*/\nfunction () {\n  function EventApi(event) {\n    _classCallCheck(this, EventApi);\n\n    this.event = event;\n  }\n  /**\n   * Returns the first node on the `composedPath` of this event.\n   *\n   * @return {!EventTarget} The node this event was dispatched to\n   */\n\n\n  _createClass(EventApi, [{\n    key: \"rootTarget\",\n    get: function get() {\n      return this.event.composedPath()[0];\n    }\n    /**\n     * Returns the local (re-targeted) target for this event.\n     *\n     * @return {!EventTarget} The local (re-targeted) target for this event.\n     */\n\n  }, {\n    key: \"localTarget\",\n    get: function get() {\n      return this.event.target;\n    }\n    /**\n     * Returns the `composedPath` for this event.\n     * @return {!Array<!EventTarget>} The nodes this event propagated through\n     */\n\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this.event.composedPath();\n    }\n  }]);\n\n  return EventApi;\n}();\n/**\n * @function\n * @param {boolean=} deep\n * @return {!Node}\n */\n\nDomApi.prototype.cloneNode;\n/**\n * @function\n * @param {!Node} node\n * @return {!Node}\n */\n\nDomApi.prototype.appendChild;\n/**\n * @function\n * @param {!Node} newChild\n * @param {Node} refChild\n * @return {!Node}\n */\n\nDomApi.prototype.insertBefore;\n/**\n * @function\n * @param {!Node} node\n * @return {!Node}\n */\n\nDomApi.prototype.removeChild;\n/**\n * @function\n * @param {!Node} oldChild\n * @param {!Node} newChild\n * @return {!Node}\n */\n\nDomApi.prototype.replaceChild;\n/**\n * @function\n * @param {string} name\n * @param {string} value\n * @return {void}\n */\n\nDomApi.prototype.setAttribute;\n/**\n * @function\n * @param {string} name\n * @return {void}\n */\n\nDomApi.prototype.removeAttribute;\n/**\n * @function\n * @param {string} selector\n * @return {?Element}\n */\n\nDomApi.prototype.querySelector;\n/**\n * @function\n * @param {string} selector\n * @return {!NodeList<!Element>}\n */\n\nDomApi.prototype.querySelectorAll;\n/** @type {?Node} */\n\nDomApi.prototype.parentNode;\n/** @type {?Node} */\n\nDomApi.prototype.firstChild;\n/** @type {?Node} */\n\nDomApi.prototype.lastChild;\n/** @type {?Node} */\n\nDomApi.prototype.nextSibling;\n/** @type {?Node} */\n\nDomApi.prototype.previousSibling;\n/** @type {?HTMLElement} */\n\nDomApi.prototype.firstElementChild;\n/** @type {?HTMLElement} */\n\nDomApi.prototype.lastElementChild;\n/** @type {?HTMLElement} */\n\nDomApi.prototype.nextElementSibling;\n/** @type {?HTMLElement} */\n\nDomApi.prototype.previousElementSibling;\n/** @type {!Array<!Node>} */\n\nDomApi.prototype.childNodes;\n/** @type {!Array<!HTMLElement>} */\n\nDomApi.prototype.children;\n/** @type {?DOMTokenList} */\n\nDomApi.prototype.classList;\n/** @type {string} */\n\nDomApi.prototype.textContent;\n/** @type {string} */\n\nDomApi.prototype.innerHTML;\nforwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);\nforwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);\nforwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);\n/**\n * Legacy DOM and Event manipulation API wrapper factory used to abstract\n * differences between native Shadow DOM and \"Shady DOM\" when polyfilling on\n * older browsers.\n *\n * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and\n * in the majority of cases simply facades directly to the standard native\n * API.\n *\n * @summary Legacy DOM and Event manipulation API wrapper factory used to\n * abstract differences between native Shadow DOM and \"Shady DOM.\"\n * @param {(Node|Event)=} obj Node or event to operate on\n * @return {!DomApi|!EventApi} Wrapper providing either node API or event API\n */\n\nexport var dom = function dom(obj) {\n  obj = obj || document;\n\n  if (!obj.__domApi) {\n    var helper;\n\n    if (obj instanceof Event) {\n      helper = new EventApi(obj);\n    } else {\n      helper = new DomApi(obj);\n    }\n\n    obj.__domApi = helper;\n  }\n\n  return obj.__domApi;\n};","map":null,"metadata":{},"sourceType":"module"}