{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { TemplateInstanceBase, templatize, modelForElement as _modelForElement } from '../utils/templatize.js'; // eslint-disable-line no-unused-vars\n\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { OptionalMutableData } from '../mixins/mutable-data.js';\nimport { matches, translate } from '../utils/path.js';\nimport { timeOut, microTask } from '../utils/async.js';\n/**\n * @constructor\n * @implements {Polymer_OptionalMutableData}\n * @extends {PolymerElement}\n * @private\n */\n\nvar domRepeatBase = OptionalMutableData(PolymerElement);\n/**\n * The `<dom-repeat>` element will automatically stamp and binds one instance\n * of template content to each object in a user-provided array.\n * `dom-repeat` accepts an `items` property, and one instance of the template\n * is stamped for each item into the DOM at the location of the `dom-repeat`\n * element.  The `item` property will be set on each instance's binding\n * scope, thus templates should bind to sub-properties of `item`.\n *\n * Example:\n *\n * ```html\n * <dom-module id=\"employee-list\">\n *\n *   <template>\n *\n *     <div> Employee list: </div>\n *     <dom-repeat items=\"{{employees}}\">\n *       <template>\n *         <div>First name: <span>{{item.first}}</span></div>\n *         <div>Last name: <span>{{item.last}}</span></div>\n *       </template>\n *     </dom-repeat>\n *\n *   </template>\n *\n * </dom-module>\n * ```\n *\n * With the following custom element definition:\n *\n * ```js\n * class EmployeeList extends PolymerElement {\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n * }\n * ```\n *\n * Notifications for changes to items sub-properties will be forwarded to template\n * instances, which will update via the normal structured data notification system.\n *\n * Mutations to the `items` array itself should be made using the Array\n * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,\n * `shift`, `unshift`), and template instances will be kept in sync with the\n * data in the array.\n *\n * Events caught by event handlers within the `dom-repeat` template will be\n * decorated with a `model` property, which represents the binding scope for\n * each template instance.  The model should be used to manipulate data on the\n * instance, for example `event.model.set('item.checked', true);`.\n *\n * Alternatively, the model for a template instance for an element stamped by\n * a `dom-repeat` can be obtained using the `modelForElement` API on the\n * `dom-repeat` that stamped it, for example\n * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n * This may be useful for manipulating instance data of event targets obtained\n * by event handlers on parents of the `dom-repeat` (event delegation).\n *\n * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n * `filter` and/or `sort` property.  This may be a string that names a function on\n * the host, or a function may be assigned to the property directly.  The functions\n * should implemented following the standard `Array` filter/sort API.\n *\n * In order to re-run the filter or sort functions based on changes to sub-fields\n * of `items`, the `observe` property may be set as a space-separated list of\n * `item` sub-fields that should cause a re-filter/sort when modified.  If\n * the filter or sort function depends on properties not contained in `items`,\n * the user should observe changes to those properties and call `render` to update\n * the view based on the dependency change.\n *\n * For example, for an `dom-repeat` with a filter of the following:\n *\n * ```js\n * isEngineer(item) {\n *   return item.type == 'engineer' || item.manager.type == 'engineer';\n * }\n * ```\n *\n * Then the `observe` property should be configured as follows:\n *\n * ```html\n * <dom-repeat items=\"{{employees}}\" filter=\"isEngineer\" observe=\"type manager.type\">\n * ```\n *\n * @customElement\n * @polymer\n * @extends {domRepeatBase}\n * @appliesMixin OptionalMutableData\n * @summary Custom element for stamping instance of a template bound to\n *   items in an array.\n */\n\nexport var DomRepeat =\n/*#__PURE__*/\nfunction (_domRepeatBase) {\n  _inherits(DomRepeat, _domRepeatBase);\n\n  _createClass(DomRepeat, null, [{\n    key: \"is\",\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    get: function get() {\n      return 'dom-repeat';\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      /**\n       * Fired whenever DOM is added or removed by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n      return {\n        /**\n         * An array containing items determining how many instances of the template\n         * to stamp and that that each template instance should bind to.\n         */\n        items: {\n          type: Array\n        },\n\n        /**\n         * The name of the variable to add to the binding scope for the array\n         * element associated with a given template instance.\n         */\n        as: {\n          type: String,\n          value: 'item'\n        },\n\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the sorted and filtered list of rendered items.\n         * Note, for the index in the `this.items` array, use the value of the\n         * `itemsIndexAs` property.\n         */\n        indexAs: {\n          type: String,\n          value: 'index'\n        },\n\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the `this.items` array. Note, for the index of\n         * this instance in the sorted and filtered list of rendered items,\n         * use the value of the `indexAs` property.\n         */\n        itemsIndexAs: {\n          type: String,\n          value: 'itemsIndex'\n        },\n\n        /**\n         * A function that should determine the sort order of the items.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.sort`.\n         * Using a sort function has no effect on the underlying `items` array.\n         */\n        sort: {\n          type: Function,\n          observer: '__sortChanged'\n        },\n\n        /**\n         * A function that can be used to filter items out of the view.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.filter`.\n         * Using a filter function has no effect on the underlying `items` array.\n         */\n        filter: {\n          type: Function,\n          observer: '__filterChanged'\n        },\n\n        /**\n         * When using a `filter` or `sort` function, the `observe` property\n         * should be set to a space-separated list of the names of item\n         * sub-fields that should trigger a re-sort or re-filter when changed.\n         * These should generally be fields of `item` that the sort or filter\n         * function depends on.\n         */\n        observe: {\n          type: String,\n          observer: '__observeChanged'\n        },\n\n        /**\n         * When using a `filter` or `sort` function, the `delay` property\n         * determines a debounce time in ms after a change to observed item\n         * properties that must pass before the filter or sort is re-run.\n         * This is useful in rate-limiting shuffling of the view when\n         * item changes may be frequent.\n         */\n        delay: Number,\n\n        /**\n         * Count of currently rendered items after `filter` (if any) has been applied.\n         * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n         * set of template instances is rendered.\n         *\n         */\n        renderedItemCount: {\n          type: Number,\n          notify: true,\n          readOnly: true\n        },\n\n        /**\n         * Defines an initial count of template instances to render after setting\n         * the `items` array, before the next paint, and puts the `dom-repeat`\n         * into \"chunking mode\".  The remaining items will be created and rendered\n         * incrementally at each animation frame therof until all instances have\n         * been rendered.\n         */\n        initialCount: {\n          type: Number,\n          observer: '__initializeChunking'\n        },\n\n        /**\n         * When `initialCount` is used, this property defines a frame rate (in\n         * fps) to target by throttling the number of instances rendered each\n         * frame to not exceed the budget for the target frame rate.  The\n         * framerate is effectively the number of `requestAnimationFrame`s that\n         * it tries to allow to actually fire in a given second. It does this\n         * by measuring the time between `rAF`s and continuously adjusting the\n         * number of items created each `rAF` to maintain the target framerate.\n         * Setting this to a higher number allows lower latency and higher\n         * throughput for event handlers and other tasks, but results in a\n         * longer time for the remaining items to complete rendering.\n         */\n        targetFramerate: {\n          type: Number,\n          value: 20\n        },\n        _targetFrameTime: {\n          type: Number,\n          computed: '__computeFrameTime(targetFramerate)'\n        }\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['__itemsChanged(items.*)'];\n    }\n  }]);\n\n  function DomRepeat() {\n    var _this;\n\n    _classCallCheck(this, DomRepeat);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DomRepeat).call(this));\n    _this.__instances = [];\n    _this.__limit = Infinity;\n    _this.__pool = [];\n    _this.__renderDebouncer = null;\n    _this.__itemsIdxToInstIdx = {};\n    _this.__chunkCount = null;\n    _this.__lastChunkTime = null;\n    _this.__sortFn = null;\n    _this.__filterFn = null;\n    _this.__observePaths = null;\n    /** @type {?function(new:Polymer.TemplateInstanceBase, *)} */\n\n    _this.__ctor = null;\n    _this.__isDetached = true;\n    _this.template = null;\n    return _this;\n  }\n  /**\n   * @override\n   * @return {void}\n   */\n\n\n  _createClass(DomRepeat, [{\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(DomRepeat.prototype), \"disconnectedCallback\", this).call(this);\n\n      this.__isDetached = true;\n\n      for (var i = 0; i < this.__instances.length; i++) {\n        this.__detachInstance(i);\n      }\n    }\n    /**\n     * @override\n     * @return {void}\n     */\n\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(DomRepeat.prototype), \"connectedCallback\", this).call(this);\n\n      this.style.display = 'none'; // only perform attachment if the element was previously detached.\n\n      if (this.__isDetached) {\n        this.__isDetached = false;\n        var parent = this.parentNode;\n\n        for (var i = 0; i < this.__instances.length; i++) {\n          this.__attachInstance(i, parent);\n        }\n      }\n    }\n  }, {\n    key: \"__ensureTemplatized\",\n    value: function __ensureTemplatized() {\n      var _this2 = this;\n\n      // Templatizing (generating the instance constructor) needs to wait\n      // until ready, since won't have its template content handed back to\n      // it until then\n      if (!this.__ctor) {\n        var template = this.template =\n        /** @type {HTMLTemplateElement} */\n        this.querySelector('template');\n\n        if (!template) {\n          // // Wait until childList changes and template should be there by then\n          var observer = new MutationObserver(function () {\n            if (_this2.querySelector('template')) {\n              observer.disconnect();\n\n              _this2.__render();\n            } else {\n              throw new Error('dom-repeat requires a <template> child');\n            }\n          });\n          observer.observe(this, {\n            childList: true\n          });\n          return false;\n        } // Template instance props that should be excluded from forwarding\n\n\n        var instanceProps = {};\n        instanceProps[this.as] = true;\n        instanceProps[this.indexAs] = true;\n        instanceProps[this.itemsIndexAs] = true;\n        this.__ctor = templatize(template, this, {\n          mutableData: this.mutableData,\n          parentModel: true,\n          instanceProps: instanceProps,\n\n          /**\n           * @this {DomRepeat}\n           * @param {string} prop Property to set\n           * @param {*} value Value to set property to\n           */\n          forwardHostProp: function forwardHostProp(prop, value) {\n            var i$ = this.__instances;\n\n            for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {\n              inst.forwardHostProp(prop, value);\n            }\n          },\n\n          /**\n           * @this {DomRepeat}\n           * @param {Object} inst Instance to notify\n           * @param {string} prop Property to notify\n           * @param {*} value Value to notify\n           */\n          notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {\n            if (matches(this.as, prop)) {\n              var idx = inst[this.itemsIndexAs];\n\n              if (prop == this.as) {\n                this.items[idx] = value;\n              }\n\n              var path = translate(this.as, 'items.' + idx, prop);\n              this.notifyPath(path, value);\n            }\n          }\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"__getMethodHost\",\n    value: function __getMethodHost() {\n      // Technically this should be the owner of the outermost template.\n      // In shadow dom, this is always getRootNode().host, but we can\n      // approximate this via cooperation with our dataHost always setting\n      // `_methodHost` as long as there were bindings (or id's) on this\n      // instance causing it to get a dataHost.\n      return this.__dataHost._methodHost || this.__dataHost;\n    }\n  }, {\n    key: \"__functionFromPropertyValue\",\n    value: function __functionFromPropertyValue(functionOrMethodName) {\n      if (typeof functionOrMethodName === 'string') {\n        var methodName = functionOrMethodName;\n\n        var obj = this.__getMethodHost();\n\n        return function () {\n          return obj[methodName].apply(obj, arguments);\n        };\n      }\n\n      return functionOrMethodName;\n    }\n  }, {\n    key: \"__sortChanged\",\n    value: function __sortChanged(sort) {\n      this.__sortFn = this.__functionFromPropertyValue(sort);\n\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: \"__filterChanged\",\n    value: function __filterChanged(filter) {\n      this.__filterFn = this.__functionFromPropertyValue(filter);\n\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: \"__computeFrameTime\",\n    value: function __computeFrameTime(rate) {\n      return Math.ceil(1000 / rate);\n    }\n  }, {\n    key: \"__initializeChunking\",\n    value: function __initializeChunking() {\n      if (this.initialCount) {\n        this.__limit = this.initialCount;\n        this.__chunkCount = this.initialCount;\n        this.__lastChunkTime = performance.now();\n      }\n    }\n  }, {\n    key: \"__tryRenderChunk\",\n    value: function __tryRenderChunk() {\n      // Debounced so that multiple calls through `_render` between animation\n      // frames only queue one new rAF (e.g. array mutation & chunked render)\n      if (this.items && this.__limit < this.items.length) {\n        this.__debounceRender(this.__requestRenderChunk);\n      }\n    }\n  }, {\n    key: \"__requestRenderChunk\",\n    value: function __requestRenderChunk() {\n      var _this3 = this;\n\n      requestAnimationFrame(function () {\n        return _this3.__renderChunk();\n      });\n    }\n  }, {\n    key: \"__renderChunk\",\n    value: function __renderChunk() {\n      // Simple auto chunkSize throttling algorithm based on feedback loop:\n      // measure actual time between frames and scale chunk count by ratio\n      // of target/actual frame time\n      var currChunkTime = performance.now();\n      var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);\n      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n      this.__limit += this.__chunkCount;\n      this.__lastChunkTime = currChunkTime;\n\n      this.__debounceRender(this.__render);\n    }\n  }, {\n    key: \"__observeChanged\",\n    value: function __observeChanged() {\n      this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');\n    }\n  }, {\n    key: \"__itemsChanged\",\n    value: function __itemsChanged(change) {\n      if (this.items && !Array.isArray(this.items)) {\n        console.warn('dom-repeat expected array for `items`, found', this.items);\n      } // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n      // path to that instance synchronously (returns false for non-item paths)\n\n\n      if (!this.__handleItemPath(change.path, change.value)) {\n        // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n        // so queue a full refresh\n        this.__initializeChunking();\n\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: \"__handleObservedPaths\",\n    value: function __handleObservedPaths(path) {\n      // Handle cases where path changes should cause a re-sort/filter\n      if (this.__sortFn || this.__filterFn) {\n        if (!path) {\n          // Always re-render if the item itself changed\n          this.__debounceRender(this.__render, this.delay);\n        } else if (this.__observePaths) {\n          // Otherwise, re-render if the path changed matches an observed path\n          var paths = this.__observePaths;\n\n          for (var i = 0; i < paths.length; i++) {\n            if (path.indexOf(paths[i]) === 0) {\n              this.__debounceRender(this.__render, this.delay);\n            }\n          }\n        }\n      }\n    }\n    /**\n     * @param {function(this:DomRepeat)} fn Function to debounce.\n     * @param {number=} delay Delay in ms to debounce by.\n     */\n\n  }, {\n    key: \"__debounceRender\",\n    value: function __debounceRender(fn) {\n      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, delay > 0 ? timeOut.after(delay) : microTask, fn.bind(this));\n      enqueueDebouncer(this.__renderDebouncer);\n    }\n    /**\n     * Forces the element to render its content. Normally rendering is\n     * asynchronous to a provoking change. This is done for efficiency so\n     * that multiple changes trigger only a single render. The render method\n     * should be called if, for example, template rendering is required to\n     * validate application state.\n     * @return {void}\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      // Queue this repeater, then flush all in order\n      this.__debounceRender(this.__render);\n\n      flush();\n    }\n  }, {\n    key: \"__render\",\n    value: function __render() {\n      if (!this.__ensureTemplatized()) {\n        // No template found yet\n        return;\n      }\n\n      this.__applyFullRefresh(); // Reset the pool\n      // TODO(kschaaf): Reuse pool across turns and nested templates\n      // Now that objects/arrays are re-evaluated when set, we can safely\n      // reuse pooled instances across turns, however we still need to decide\n      // semantics regarding how long to hold, how many to hold, etc.\n\n\n      this.__pool.length = 0; // Set rendered item count\n\n      this._setRenderedItemCount(this.__instances.length); // Notify users\n\n\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      })); // Check to see if we need to render more items\n\n      this.__tryRenderChunk();\n    }\n  }, {\n    key: \"__applyFullRefresh\",\n    value: function __applyFullRefresh() {\n      var _this4 = this;\n\n      var items = this.items || [];\n      var isntIdxToItemsIdx = new Array(items.length);\n\n      for (var i = 0; i < items.length; i++) {\n        isntIdxToItemsIdx[i] = i;\n      } // Apply user filter\n\n\n      if (this.__filterFn) {\n        isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {\n          return _this4.__filterFn(items[i], idx, array);\n        });\n      } // Apply user sort\n\n\n      if (this.__sortFn) {\n        isntIdxToItemsIdx.sort(function (a, b) {\n          return _this4.__sortFn(items[a], items[b]);\n        });\n      } // items->inst map kept for item path forwarding\n\n\n      var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n      var instIdx = 0; // Generate instances and assign items\n\n      var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);\n\n      for (; instIdx < limit; instIdx++) {\n        var inst = this.__instances[instIdx];\n        var itemIdx = isntIdxToItemsIdx[instIdx];\n        var item = items[itemIdx];\n        itemsIdxToInstIdx[itemIdx] = instIdx;\n\n        if (inst) {\n          inst._setPendingProperty(this.as, item);\n\n          inst._setPendingProperty(this.indexAs, instIdx);\n\n          inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n\n          inst._flushProperties();\n        } else {\n          this.__insertInstance(item, instIdx, itemIdx);\n        }\n      } // Remove any extra instances from previous state\n\n\n      for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {\n        this.__detachAndRemoveInstance(_i);\n      }\n    }\n  }, {\n    key: \"__detachInstance\",\n    value: function __detachInstance(idx) {\n      var inst = this.__instances[idx];\n\n      for (var i = 0; i < inst.children.length; i++) {\n        var el = inst.children[i];\n        inst.root.appendChild(el);\n      }\n\n      return inst;\n    }\n  }, {\n    key: \"__attachInstance\",\n    value: function __attachInstance(idx, parent) {\n      var inst = this.__instances[idx];\n      parent.insertBefore(inst.root, this);\n    }\n  }, {\n    key: \"__detachAndRemoveInstance\",\n    value: function __detachAndRemoveInstance(idx) {\n      var inst = this.__detachInstance(idx);\n\n      if (inst) {\n        this.__pool.push(inst);\n      }\n\n      this.__instances.splice(idx, 1);\n    }\n  }, {\n    key: \"__stampInstance\",\n    value: function __stampInstance(item, instIdx, itemIdx) {\n      var model = {};\n      model[this.as] = item;\n      model[this.indexAs] = instIdx;\n      model[this.itemsIndexAs] = itemIdx;\n      return new this.__ctor(model);\n    }\n  }, {\n    key: \"__insertInstance\",\n    value: function __insertInstance(item, instIdx, itemIdx) {\n      var inst = this.__pool.pop();\n\n      if (inst) {\n        // TODO(kschaaf): If the pool is shared across turns, hostProps\n        // need to be re-set to reused instances in addition to item\n        inst._setPendingProperty(this.as, item);\n\n        inst._setPendingProperty(this.indexAs, instIdx);\n\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n\n        inst._flushProperties();\n      } else {\n        inst = this.__stampInstance(item, instIdx, itemIdx);\n      }\n\n      var beforeRow = this.__instances[instIdx + 1];\n      var beforeNode = beforeRow ? beforeRow.children[0] : this;\n      this.parentNode.insertBefore(inst.root, beforeNode);\n      this.__instances[instIdx] = inst;\n      return inst;\n    } // Implements extension point from Templatize mixin\n\n    /**\n     * Shows or hides the template instance top level child elements. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     * @param {boolean} hidden Set to true to hide the children;\n     * set to false to show them.\n     * @return {void}\n     * @protected\n     */\n\n  }, {\n    key: \"_showHideChildren\",\n    value: function _showHideChildren(hidden) {\n      for (var i = 0; i < this.__instances.length; i++) {\n        this.__instances[i]._showHideChildren(hidden);\n      }\n    } // Called as a side effect of a host items.<key>.<path> path change,\n    // responsible for notifying item.<path> changes to inst for key\n\n  }, {\n    key: \"__handleItemPath\",\n    value: function __handleItemPath(path, value) {\n      var itemsPath = path.slice(6); // 'items.'.length == 6\n\n      var dot = itemsPath.indexOf('.');\n      var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot); // If path was index into array...\n\n      if (itemsIdx == parseInt(itemsIdx, 10)) {\n        var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1); // If the path is observed, it will trigger a full refresh\n\n        this.__handleObservedPaths(itemSubPath); // Note, even if a rull refresh is triggered, always do the path\n        // notification because unless mutableData is used for dom-repeat\n        // and all elements in the instance subtree, a full refresh may\n        // not trigger the proper update.\n\n\n        var instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n        var inst = this.__instances[instIdx];\n\n        if (inst) {\n          var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : ''); // This is effectively `notifyPath`, but avoids some of the overhead\n          // of the public API\n\n          inst._setPendingPropertyOrPath(itemPath, value, false, true);\n\n          inst._flushProperties();\n        }\n\n        return true;\n      }\n    }\n    /**\n     * Returns the item associated with a given element stamped by\n     * this `dom-repeat`.\n     *\n     * Note, to modify sub-properties of the item,\n     * `modelForElement(el).set('item.<sub-prop>', value)`\n     * should be used.\n     *\n     * @param {!HTMLElement} el Element for which to return the item.\n     * @return {*} Item associated with the element.\n     */\n\n  }, {\n    key: \"itemForElement\",\n    value: function itemForElement(el) {\n      var instance = this.modelForElement(el);\n      return instance && instance[this.as];\n    }\n    /**\n     * Returns the inst index for a given element stamped by this `dom-repeat`.\n     * If `sort` is provided, the index will reflect the sorted order (rather\n     * than the original array order).\n     *\n     * @param {!HTMLElement} el Element for which to return the index.\n     * @return {?number} Row index associated with the element (note this may\n     *   not correspond to the array index if a user `sort` is applied).\n     */\n\n  }, {\n    key: \"indexForElement\",\n    value: function indexForElement(el) {\n      var instance = this.modelForElement(el);\n      return instance && instance[this.indexAs];\n    }\n    /**\n     * Returns the template \"model\" associated with a given element, which\n     * serves as the binding scope for the template instance the element is\n     * contained in. A template model\n     * should be used to manipulate data associated with this template instance.\n     *\n     * Example:\n     *\n     *   let model = modelForElement(el);\n     *   if (model.index < 10) {\n     *     model.set('item.checked', true);\n     *   }\n     *\n     * @param {!HTMLElement} el Element for which to return a template model.\n     * @return {TemplateInstanceBase} Model representing the binding scope for\n     *   the element.\n     */\n\n  }, {\n    key: \"modelForElement\",\n    value: function modelForElement(el) {\n      return _modelForElement(this.template, el);\n    }\n  }]);\n\n  return DomRepeat;\n}(domRepeatBase);\ncustomElements.define(DomRepeat.is, DomRepeat);","map":null,"metadata":{},"sourceType":"module"}