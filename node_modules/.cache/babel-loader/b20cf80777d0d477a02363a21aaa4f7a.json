{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { LegacyElementMixin } from './legacy-element-mixin.js';\nvar metaProps = {\n  attached: true,\n  detached: true,\n  ready: true,\n  created: true,\n  beforeRegister: true,\n  registered: true,\n  attributeChanged: true,\n  // meta objects\n  behaviors: true\n};\n/**\n * Applies a \"legacy\" behavior or array of behaviors to the provided class.\n *\n * Note: this method will automatically also apply the `LegacyElementMixin`\n * to ensure that any legacy behaviors can rely on legacy Polymer API on\n * the underlying element.\n *\n * @function\n * @template T\n * @param {!Object|!Array<!Object>} behaviors Behavior object or array of behaviors.\n * @param {function(new:T)} klass Element class.\n * @return {?} Returns a new Element class extended by the\n * passed in `behaviors` and also by `LegacyElementMixin`.\n * @suppress {invalidCasts, checkTypes}\n */\n\nexport function mixinBehaviors(behaviors, klass) {\n  if (!behaviors) {\n    klass =\n    /** @type {HTMLElement} */\n    klass; // eslint-disable-line no-self-assign\n\n    return klass;\n  } // NOTE: ensure the behavior is extending a class with\n  // legacy element api. This is necessary since behaviors expect to be able\n  // to access 1.x legacy api.\n\n\n  klass = LegacyElementMixin(klass);\n\n  if (!Array.isArray(behaviors)) {\n    behaviors = [behaviors];\n  }\n\n  var superBehaviors = klass.prototype.behaviors; // get flattened, deduped list of behaviors *not* already on super class\n\n  behaviors = flattenBehaviors(behaviors, null, superBehaviors); // mixin new behaviors\n\n  klass = _mixinBehaviors(behaviors, klass);\n\n  if (superBehaviors) {\n    behaviors = superBehaviors.concat(behaviors);\n  } // Set behaviors on prototype for BC...\n\n\n  klass.prototype.behaviors = behaviors;\n  return klass;\n} // NOTE:\n// 1.x\n// Behaviors were mixed in *in reverse order* and de-duped on the fly.\n// The rule was that behavior properties were copied onto the element\n// prototype if and only if the property did not already exist.\n// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:\n// (1), B, (2), A, (3) C. This means prototype properties win over\n// B properties win over A win over C. This mirrors what would happen\n// with inheritance if element extended B extended A extended C.\n//\n// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting\n// `behaviors` array was [C, A, B].\n// Behavior lifecycle methods were called in behavior array order\n// followed by the element, e.g. (1) C.created, (2) A.created,\n// (3) B.created, (4) element.created. There was no support for\n// super, and \"super-behavior\" methods were callable only by name).\n//\n// 2.x\n// Behaviors are made into proper mixins which live in the\n// element's prototype chain. Behaviors are placed in the element prototype\n// eldest to youngest and de-duped youngest to oldest:\n// So, first [A, B, C, A, B] becomes [C, A, B] then,\n// the element prototype becomes (oldest) (1) PolymerElement, (2) class(C),\n// (3) class(A), (4) class(B), (5) class(Polymer({...})).\n// Result:\n// This means element properties win over B properties win over A win\n// over C. (same as 1.x)\n// If lifecycle is called (super then me), order is\n// (1) C.created, (2) A.created, (3) B.created, (4) element.created\n// (again same as 1.x)\n\nfunction _mixinBehaviors(behaviors, klass) {\n  for (var i = 0; i < behaviors.length; i++) {\n    var b = behaviors[i];\n\n    if (b) {\n      klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);\n    }\n  }\n\n  return klass;\n}\n/**\n * @param {Array} behaviors List of behaviors to flatten.\n * @param {Array=} list Target list to flatten behaviors into.\n * @param {Array=} exclude List of behaviors to exclude from the list.\n * @return {!Array} Returns the list of flattened behaviors.\n */\n\n\nfunction flattenBehaviors(behaviors, list, exclude) {\n  list = list || [];\n\n  for (var i = behaviors.length - 1; i >= 0; i--) {\n    var b = behaviors[i];\n\n    if (b) {\n      if (Array.isArray(b)) {\n        flattenBehaviors(b, list);\n      } else {\n        // dedup\n        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {\n          list.unshift(b);\n        }\n      }\n    } else {\n      console.warn('behavior is null, check for missing or 404 import');\n    }\n  }\n\n  return list;\n}\n/**\n * @param {!PolymerInit} info Polymer info object\n * @param {function(new:HTMLElement)} Base base class to extend with info object\n * @return {function(new:HTMLElement)} Generated class\n * @suppress {checkTypes}\n * @private\n */\n\n\nfunction GenerateClassFromInfo(info, Base) {\n  /** @private */\n  var PolymerGenerated =\n  /*#__PURE__*/\n  function (_Base) {\n    _inherits(PolymerGenerated, _Base);\n\n    function PolymerGenerated() {\n      _classCallCheck(this, PolymerGenerated);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(PolymerGenerated).apply(this, arguments));\n    }\n\n    _createClass(PolymerGenerated, [{\n      key: \"created\",\n\n      /**\n       * @return {void}\n       */\n      value: function created() {\n        _get(_getPrototypeOf(PolymerGenerated.prototype), \"created\", this).call(this);\n\n        if (info.created) {\n          info.created.call(this);\n        }\n      }\n      /**\n       * @return {void}\n       */\n\n    }, {\n      key: \"_registered\",\n      value: function _registered() {\n        _get(_getPrototypeOf(PolymerGenerated.prototype), \"_registered\", this).call(this);\n        /* NOTE: `beforeRegister` is called here for bc, but the behavior\n         is different than in 1.x. In 1.0, the method was called *after*\n         mixing prototypes together but *before* processing of meta-objects.\n         However, dynamic effects can still be set here and can be done either\n         in `beforeRegister` or `registered`. It is no longer possible to set\n         `is` in `beforeRegister` as you could in 1.x.\n        */\n\n\n        if (info.beforeRegister) {\n          info.beforeRegister.call(Object.getPrototypeOf(this));\n        }\n\n        if (info.registered) {\n          info.registered.call(Object.getPrototypeOf(this));\n        }\n      }\n      /**\n       * @return {void}\n       */\n\n    }, {\n      key: \"_applyListeners\",\n      value: function _applyListeners() {\n        _get(_getPrototypeOf(PolymerGenerated.prototype), \"_applyListeners\", this).call(this);\n\n        if (info.listeners) {\n          for (var l in info.listeners) {\n            this._addMethodEventListenerToNode(this, l, info.listeners[l]);\n          }\n        }\n      } // note: exception to \"super then me\" rule;\n      // do work before calling super so that super attributes\n      // only apply if not already set.\n\n      /**\n       * @return {void}\n       */\n\n    }, {\n      key: \"_ensureAttributes\",\n      value: function _ensureAttributes() {\n        if (info.hostAttributes) {\n          for (var a in info.hostAttributes) {\n            this._ensureAttribute(a, info.hostAttributes[a]);\n          }\n        }\n\n        _get(_getPrototypeOf(PolymerGenerated.prototype), \"_ensureAttributes\", this).call(this);\n      }\n      /**\n       * @return {void}\n       */\n\n    }, {\n      key: \"ready\",\n      value: function ready() {\n        _get(_getPrototypeOf(PolymerGenerated.prototype), \"ready\", this).call(this);\n\n        if (info.ready) {\n          info.ready.call(this);\n        }\n      }\n      /**\n       * @return {void}\n       */\n\n    }, {\n      key: \"attached\",\n      value: function attached() {\n        _get(_getPrototypeOf(PolymerGenerated.prototype), \"attached\", this).call(this);\n\n        if (info.attached) {\n          info.attached.call(this);\n        }\n      }\n      /**\n       * @return {void}\n       */\n\n    }, {\n      key: \"detached\",\n      value: function detached() {\n        _get(_getPrototypeOf(PolymerGenerated.prototype), \"detached\", this).call(this);\n\n        if (info.detached) {\n          info.detached.call(this);\n        }\n      }\n      /**\n       * Implements native Custom Elements `attributeChangedCallback` to\n       * set an attribute value to a property via `_attributeToProperty`.\n       *\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       * @return {void}\n       */\n\n    }, {\n      key: \"attributeChanged\",\n      value: function attributeChanged(name, old, value) {\n        _get(_getPrototypeOf(PolymerGenerated.prototype), \"attributeChanged\", this).call(this, name, old, value);\n\n        if (info.attributeChanged) {\n          info.attributeChanged.call(this, name, old, value);\n        }\n      }\n    }], [{\n      key: \"properties\",\n      get: function get() {\n        return info.properties;\n      }\n    }, {\n      key: \"observers\",\n      get: function get() {\n        return info.observers;\n      }\n    }]);\n\n    return PolymerGenerated;\n  }(Base);\n\n  PolymerGenerated.generatedFrom = info;\n\n  for (var p in info) {\n    // NOTE: cannot copy `metaProps` methods onto prototype at least because\n    // `super.ready` must be called and is not included in the user fn.\n    if (!(p in metaProps)) {\n      var pd = Object.getOwnPropertyDescriptor(info, p);\n\n      if (pd) {\n        Object.defineProperty(PolymerGenerated.prototype, p, pd);\n      }\n    }\n  }\n\n  return PolymerGenerated;\n}\n/**\n * Generates a class that extends `LegacyElement` based on the\n * provided info object.  Metadata objects on the `info` object\n * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used\n * for Polymer's meta-programming systems, and any functions are copied\n * to the generated class.\n *\n * Valid \"metadata\" values are as follows:\n *\n * `is`: String providing the tag name to register the element under. In\n * addition, if a `dom-module` with the same id exists, the first template\n * in that `dom-module` will be stamped into the shadow root of this element,\n * with support for declarative event listeners (`on-...`), Polymer data\n * bindings (`[[...]]` and `{{...}}`), and id-based node finding into\n * `this.$`.\n *\n * `properties`: Object describing property-related metadata used by Polymer\n * features (key: property names, value: object containing property metadata).\n * Valid keys in per-property metadata include:\n * - `type` (String|Number|Object|Array|...): Used by\n *   `attributeChangedCallback` to determine how string-based attributes\n *   are deserialized to JavaScript property values.\n * - `notify` (boolean): Causes a change in the property to fire a\n *   non-bubbling event called `<property>-changed`. Elements that have\n *   enabled two-way binding to the property use this event to observe changes.\n * - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *   To set a read-only property, use the private setter method\n *   `_setProperty(property, value)`.\n * - `observer` (string): Observer method name that will be called when\n *   the property changes. The arguments of the method are\n *   `(value, previousValue)`.\n * - `computed` (string): String describing method and dependent properties\n *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *   Computed properties are read-only by default and can only be changed\n *   via the return value of the computing method.\n *\n * `observers`: Array of strings describing multi-property observer methods\n *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).\n *\n * `listeners`: Object describing event listeners to be added to each\n *  instance of this element (key: event name, value: method name).\n *\n * `behaviors`: Array of additional `info` objects containing metadata\n * and callbacks in the same format as the `info` object here which are\n * merged into this element.\n *\n * `hostAttributes`: Object listing attributes to be applied to the host\n *  once created (key: attribute name, value: attribute value).  Values\n *  are serialized based on the type of the value.  Host attributes should\n *  generally be limited to attributes such as `tabIndex` and `aria-...`.\n *  Attributes in `hostAttributes` are only applied if a user-supplied\n *  attribute is not already present (attributes in markup override\n *  `hostAttributes`).\n *\n * In addition, the following Polymer-specific callbacks may be provided:\n * - `registered`: called after first instance of this element,\n * - `created`: called during `constructor`\n * - `attached`: called during `connectedCallback`\n * - `detached`: called during `disconnectedCallback`\n * - `ready`: called before first `attached`, after all properties of\n *   this element have been propagated to its template and all observers\n *   have run\n *\n * @param {!PolymerInit} info Object containing Polymer metadata and functions\n *   to become class methods.\n * @template T\n * @param {function(T):T} mixin Optional mixin to apply to legacy base class\n *   before extending with Polymer metaprogramming.\n * @return {function(new:HTMLElement)} Generated class\n */\n\n\nexport var Class = function Class(info, mixin) {\n  if (!info) {\n    console.warn(\"Polymer's Class function requires `info` argument\");\n  }\n\n  var baseWithBehaviors = info.behaviors ? // note: mixinBehaviors ensures `LegacyElementMixin`.\n  mixinBehaviors(info.behaviors, HTMLElement) : LegacyElementMixin(HTMLElement);\n  var baseWithMixin = mixin ? mixin(baseWithBehaviors) : baseWithBehaviors;\n  var klass = GenerateClassFromInfo(info, baseWithMixin); // decorate klass with registration info\n\n  klass.is = info.is;\n  return klass;\n};","map":null,"metadata":{},"sourceType":"module"}