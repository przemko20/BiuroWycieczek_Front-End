{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { microTask } from '../utils/async.js';\n/** @const {!AsyncInterface} */\n\nvar microtask = microTask;\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n */\n\nexport var PropertiesChanged = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nfunction (superClass) {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  var PropertiesChanged =\n  /*#__PURE__*/\n  function (_superClass) {\n    _inherits(PropertiesChanged, _superClass);\n\n    _createClass(PropertiesChanged, [{\n      key: \"_createPropertyAccessor\",\n      //eslint-disable-line no-unused-vars\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @return {void}\n       * @protected\n       * @override\n       */\n      value: function _createPropertyAccessor(property, readOnly) {\n        this._addPropertyToAttributeMap(property);\n\n        if (!this.hasOwnProperty('__dataHasAccessor')) {\n          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n        }\n\n        if (!this.__dataHasAccessor[property]) {\n          this.__dataHasAccessor[property] = true;\n\n          this._definePropertyAccessor(property, readOnly);\n        }\n      }\n      /**\n       * Adds the given `property` to a map matching attribute names\n       * to property names, using `attributeNameForProperty`. This map is\n       * used when deserializing attribute values to properties.\n       *\n       * @param {string} property Name of the property\n       * @override\n       */\n\n    }, {\n      key: \"_addPropertyToAttributeMap\",\n      value: function _addPropertyToAttributeMap(property) {\n        if (!this.hasOwnProperty('__dataAttributes')) {\n          this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n        }\n\n        if (!this.__dataAttributes[property]) {\n          var attr = this.constructor.attributeNameForProperty(property);\n          this.__dataAttributes[attr] = property;\n        }\n      }\n      /**\n       * Defines a property accessor for the given property.\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"_definePropertyAccessor\",\n      value: function _definePropertyAccessor(property, readOnly) {\n        Object.defineProperty(this, property, {\n          /* eslint-disable valid-jsdoc */\n\n          /** @this {PropertiesChanged} */\n          get: function get() {\n            return this._getProperty(property);\n          },\n\n          /** @this {PropertiesChanged} */\n          set: readOnly ? function () {} : function (value) {\n            this._setProperty(property, value);\n          }\n          /* eslint-enable */\n\n        });\n      }\n    }], [{\n      key: \"createProperties\",\n\n      /**\n       * Creates property accessors for the given property names.\n       * @param {!Object} props Object whose keys are names of accessors.\n       * @return {void}\n       * @protected\n       */\n      value: function createProperties(props) {\n        var proto = this.prototype;\n\n        for (var prop in props) {\n          // don't stomp an existing accessor\n          if (!(prop in proto)) {\n            proto._createPropertyAccessor(prop);\n          }\n        }\n      }\n      /**\n       * Returns an attribute name that corresponds to the given property.\n       * The attribute name is the lowercased property name. Override to\n       * customize this mapping.\n       * @param {string} property Property to convert\n       * @return {string} Attribute name corresponding to the given property.\n       *\n       * @protected\n       */\n\n    }, {\n      key: \"attributeNameForProperty\",\n      value: function attributeNameForProperty(property) {\n        return property.toLowerCase();\n      }\n      /**\n       * Override point to provide a type to which to deserialize a value to\n       * a given property.\n       * @param {string} name Name of property\n       *\n       * @protected\n       */\n\n    }, {\n      key: \"typeForProperty\",\n      value: function typeForProperty(name) {}\n    }]);\n\n    function PropertiesChanged() {\n      var _this;\n\n      _classCallCheck(this, PropertiesChanged);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(PropertiesChanged).call(this));\n      _this.__dataEnabled = false;\n      _this.__dataReady = false;\n      _this.__dataInvalid = false;\n      _this.__data = {};\n      _this.__dataPending = null;\n      _this.__dataOld = null;\n      _this.__dataInstanceProps = null;\n      _this.__serializing = false;\n\n      _this._initializeProperties();\n\n      return _this;\n    }\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n\n\n    _createClass(PropertiesChanged, [{\n      key: \"ready\",\n      value: function ready() {\n        this.__dataReady = true;\n\n        this._flushProperties();\n      }\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * Provided as an override point for performing any setup work prior\n       * to initializing the property accessor system.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_initializeProperties\",\n      value: function _initializeProperties() {\n        // Capture instance properties; these will be set into accessors\n        // during first flush. Don't set them here, since we want\n        // these to overwrite defaults/constructor assignments\n        for (var p in this.__dataHasAccessor) {\n          if (this.hasOwnProperty(p)) {\n            this.__dataInstanceProps = this.__dataInstanceProps || {};\n            this.__dataInstanceProps[p] = this[p];\n            delete this[p];\n          }\n        }\n      }\n      /**\n       * Called at ready time with bag of instance properties that overwrote\n       * accessors when the element upgraded.\n       *\n       * The default implementation sets these properties back into the\n       * setter at ready time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_initializeInstanceProperties\",\n      value: function _initializeInstanceProperties(props) {\n        Object.assign(this, props);\n      }\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_setProperty\",\n      value: function _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n      /**\n       * Returns the value for the given property.\n       * @param {string} property Name of property\n       * @return {*} Value for the given property\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_getProperty\",\n      value: function _getProperty(property) {\n        return this.__data[property];\n      }\n      /* eslint-disable no-unused-vars */\n\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} ext Not used here; affordance for closure\n       * @return {boolean} Returns true if the property changed\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_setPendingProperty\",\n      value: function _setPendingProperty(property, value, ext) {\n        var old = this.__data[property];\n\n        var changed = this._shouldPropertyChange(property, value, old);\n\n        if (changed) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          } // Ensure old is captured from the last turn\n\n\n          if (this.__dataOld && !(property in this.__dataOld)) {\n            this.__dataOld[property] = old;\n          }\n\n          this.__data[property] = value;\n          this.__dataPending[property] = value;\n        }\n\n        return changed;\n      }\n      /* eslint-enable */\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_invalidateProperties\",\n      value: function _invalidateProperties() {\n        var _this2 = this;\n\n        if (!this.__dataInvalid && this.__dataReady) {\n          this.__dataInvalid = true;\n          microtask.run(function () {\n            if (_this2.__dataInvalid) {\n              _this2.__dataInvalid = false;\n\n              _this2._flushProperties();\n            }\n          });\n        }\n      }\n      /**\n       * Call to enable property accessor processing. Before this method is\n       * called accessor values will be set but side effects are\n       * queued. When called, any pending side effects occur immediately.\n       * For elements, generally `connectedCallback` is a normal spot to do so.\n       * It is safe to call this method multiple times as it only turns on\n       * property accessors once.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_enableProperties\",\n      value: function _enableProperties() {\n        if (!this.__dataEnabled) {\n          this.__dataEnabled = true;\n\n          if (this.__dataInstanceProps) {\n            this._initializeInstanceProperties(this.__dataInstanceProps);\n\n            this.__dataInstanceProps = null;\n          }\n\n          this.ready();\n        }\n      }\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes. Generally, this method\n       * should not be called in user code.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_flushProperties\",\n      value: function _flushProperties() {\n        var props = this.__data;\n        var changedProps = this.__dataPending;\n        var old = this.__dataOld;\n\n        if (this._shouldPropertiesChange(props, changedProps, old)) {\n          this.__dataPending = null;\n          this.__dataOld = null;\n\n          this._propertiesChanged(props, changedProps, old);\n        }\n      }\n      /**\n       * Called in `_flushProperties` to determine if `_propertiesChanged`\n       * should be called. The default implementation returns true if\n       * properties are pending. Override to customize when\n       * `_propertiesChanged` is called.\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {boolean} true if changedProps is truthy\n       * @override\n       */\n\n    }, {\n      key: \"_shouldPropertiesChange\",\n      value: function _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n        // eslint-disable-line no-unused-vars\n        return Boolean(changedProps);\n      }\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_propertiesChanged\",\n      value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` if a strict equality\n       * check fails. The method always returns false for `NaN`.\n       *\n       * Override this method to e.g. provide stricter checking for\n       * Objects/Arrays when using immutable patterns.\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"_shouldPropertyChange\",\n      value: function _shouldPropertyChange(property, value, old) {\n        return (// Strict equality check\n          old !== value && ( // This ensures (old==NaN, value==NaN) always returns false\n          old === old || value === value)\n        );\n      }\n      /**\n       * Implements native Custom Elements `attributeChangedCallback` to\n       * set an attribute value to a property via `_attributeToProperty`.\n       *\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       * @param {?string} namespace Attribute namespace.\n       * @return {void}\n       * @suppress {missingProperties} Super may or may not implement the callback\n       * @override\n       */\n\n    }, {\n      key: \"attributeChangedCallback\",\n      value: function attributeChangedCallback(name, old, value, namespace) {\n        if (old !== value) {\n          this._attributeToProperty(name, value);\n        }\n\n        if (_get(_getPrototypeOf(PropertiesChanged.prototype), \"attributeChangedCallback\", this)) {\n          _get(_getPrototypeOf(PropertiesChanged.prototype), \"attributeChangedCallback\", this).call(this, name, old, value, namespace);\n        }\n      }\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeValue` method to convert the string to\n       * a typed value.\n       *\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {?string} value of the attribute.\n       * @param {*=} type type to deserialize to, defaults to the value\n       * returned from `typeForProperty`\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"_attributeToProperty\",\n      value: function _attributeToProperty(attribute, value, type) {\n        if (!this.__serializing) {\n          var map = this.__dataAttributes;\n          var property = map && map[attribute] || attribute;\n          this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));\n        }\n      }\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect to.\n       * @param {*=} value Property value to refect.\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"_propertyToAttribute\",\n      value: function _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = arguments.length < 3 ? this[property] : value;\n\n        this._valueToNodeAttribute(\n        /** @type {!HTMLElement} */\n        this, value, attribute || this.constructor.attributeNameForProperty(property));\n\n        this.__serializing = false;\n      }\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeValue` method to convert the typed\n       * value to a string.  If the `_serializeValue` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"_valueToNodeAttribute\",\n      value: function _valueToNodeAttribute(node, value, attribute) {\n        var str = this._serializeValue(value);\n\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute, str);\n        }\n      }\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * This method is called when setting JS property values to\n       * HTML attributes.  Users may override this method to provide\n       * serialization for custom types.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided\n       * property  value.\n       * @override\n       */\n\n    }, {\n      key: \"_serializeValue\",\n      value: function _serializeValue(value) {\n        switch (typeof value) {\n          case 'boolean':\n            return value ? '' : undefined;\n\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called when reading HTML attribute values to\n       * JS properties.  Users may override this method to provide\n       * deserialization for custom `type`s. Types for `Boolean`, `String`,\n       * and `Number` convert attributes to the expected types.\n       *\n       * @param {?string} value Value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       * @override\n       */\n\n    }, {\n      key: \"_deserializeValue\",\n      value: function _deserializeValue(value, type) {\n        switch (type) {\n          case Boolean:\n            return value !== null;\n\n          case Number:\n            return Number(value);\n\n          default:\n            return value;\n        }\n      }\n    }]);\n\n    return PropertiesChanged;\n  }(superClass);\n\n  return PropertiesChanged;\n});","map":null,"metadata":{},"sourceType":"module"}