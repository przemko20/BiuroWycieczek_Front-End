{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { rootPath, strictTemplatePolicy, allowTemplateFromDomModule } from '../utils/settings.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { stylesFromTemplate, stylesFromModuleImports } from '../utils/style-gather.js';\nimport { pathFromUrl, resolveCss, resolveUrl as _resolveUrl } from '../utils/resolve-url.js';\nimport { DomModule } from '../elements/dom-module.js';\nimport { PropertyEffects } from './property-effects.js';\nimport { PropertiesMixin } from './properties-mixin.js';\n/**\n * Current Polymer version in Semver notation.\n * @type {string} Semver notation of the current version of Polymer.\n */\n\nexport var version = '3.0.5';\n/**\n * Element class mixin that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * Subclassers may provide the following static getters to return metadata\n * used to configure Polymer's features for the class:\n *\n * - `static get is()`: When the template is provided via a `dom-module`,\n *   users should return the `dom-module` id from a static `is` getter.  If\n *   no template is needed or the template is provided directly via the\n *   `template` getter, there is no need to define `is` for the element.\n *\n * - `static get template()`: Users may provide the template directly (as\n *   opposed to via `dom-module`) by implementing a static `template` getter.\n *   The getter must return an `HTMLTemplateElement`.\n *\n * - `static get properties()`: Should return an object describing\n *   property-related metadata used by Polymer features (key: property name\n *   value: object containing property metadata). Valid keys in per-property\n *   metadata include:\n *   - `type` (String|Number|Object|Array|...): Used by\n *     `attributeChangedCallback` to determine how string-based attributes\n *     are deserialized to JavaScript property values.\n *   - `notify` (boolean): Causes a change in the property to fire a\n *     non-bubbling event called `<property>-changed`. Elements that have\n *     enabled two-way binding to the property use this event to observe changes.\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *     To set a read-only property, use the private setter method\n *     `_setProperty(property, value)`.\n *   - `observer` (string): Observer method name that will be called when\n *     the property changes. The arguments of the method are\n *     `(value, previousValue)`.\n *   - `computed` (string): String describing method and dependent properties\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *     Computed properties are read-only by default and can only be changed\n *     via the return value of the computing method.\n *\n * - `static get observers()`: Array of strings describing multi-property\n *   observer methods and their dependent properties (e.g.\n *   `'observeABC(a, b, c)'`).\n *\n * The base class provides default implementations for the following standard\n * custom element lifecycle callbacks; users may override these, but should\n * call the super method to ensure\n * - `constructor`: Run when the element is created or upgraded\n * - `connectedCallback`: Run each time the element is connected to the\n *   document\n * - `disconnectedCallback`: Run each time the element is disconnected from\n *   the document\n * - `attributeChangedCallback`: Run each time an attribute in\n *   `observedAttributes` is set or removed (note: this element's default\n *   `observedAttributes` implementation will automatically return an array\n *   of dash-cased attributes based on `properties`)\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyEffects\n * @appliesMixin PropertiesMixin\n * @property rootPath {string} Set to the value of `rootPath`,\n *   which defaults to the main document path\n * @property importPath {string} Set to the value of the class's static\n *   `importPath` property, which defaults to the path of this element's\n *   `dom-module` (when `is` is used), but can be overridden for other\n *   import strategies.\n * @summary Element class mixin that provides the core API for Polymer's\n * meta-programming features.\n */\n\nexport var ElementMixin = dedupingMixin(function (base) {\n  /**\n   * @constructor\n   * @extends {base}\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @private\n   */\n  var polymerElementBase = PropertiesMixin(PropertyEffects(base));\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      var props = constructor._properties;\n\n      for (var p in props) {\n        var info = props[p];\n\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n\n    return constructor.__propertyDefaults;\n  }\n  /**\n   * Returns a memoized version of the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n\n\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ?\n      /** @type {PolymerElementConstructor} */\n      constructor.observers : null;\n    }\n\n    return constructor.__ownObservers;\n  }\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * is also automatically set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   * Also consider adding warnings when an effect cannot be changed.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n\n\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    } // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n\n\n    if (info.computed && !proto._hasReadOnlyEffect(name)) {\n      proto._createComputedProperty(name, info.computed, allProps);\n    }\n\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    }\n\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    }\n\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } // always add observer\n\n\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    } // always create the mapping from attribute back to property for deserialization.\n\n\n    proto._addPropertyToAttributeMap(name);\n  }\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n\n\n  function processElementStyles(klass, template, is, baseURI) {\n    var templateStyles = template.content.querySelectorAll('style');\n    var stylesWithImports = stylesFromTemplate(template); // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n\n    var linkedStyles = stylesFromModuleImports(is);\n    var firstTemplateChild = template.content.firstElementChild;\n\n    for (var idx = 0; idx < linkedStyles.length; idx++) {\n      var s = linkedStyles[idx];\n      s.textContent = klass._processStyleText(s.textContent, baseURI);\n      template.content.insertBefore(s, firstTemplateChild);\n    } // keep track of the last \"concrete\" style in the template we have encountered\n\n\n    var templateStyleIndex = 0; // ensure all gathered styles are actually in this template.\n\n    for (var i = 0; i < stylesWithImports.length; i++) {\n      var _s = stylesWithImports[i];\n      var templateStyle = templateStyles[templateStyleIndex]; // if the style is not in this template, it's been \"included\" and\n      // we put a clone of it in the template before the style that included it\n\n      if (templateStyle !== _s) {\n        _s = _s.cloneNode(true);\n        templateStyle.parentNode.insertBefore(_s, templateStyle);\n      } else {\n        templateStyleIndex++;\n      }\n\n      _s.textContent = klass._processStyleText(_s.textContent, baseURI);\n    }\n\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n  }\n  /**\n   * Look up template from dom-module for element\n   *\n   * @param {!string} is Element name to look up\n   * @return {!HTMLTemplateElement} Template found in dom module, or\n   *   undefined if not found\n   * @protected\n   */\n\n\n  function getTemplateFromDomModule(is) {\n    var template = null; // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\n    // when opted-in via allowTemplateFromDomModule\n\n    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {\n      template = DomModule.import(is, 'template'); // Under strictTemplatePolicy, require any element with an `is`\n      // specified to have a dom-module\n\n      if (strictTemplatePolicy && !template) {\n        throw new Error(\"strictTemplatePolicy: expecting dom-module or null template for \".concat(is));\n      }\n    }\n\n    return template;\n  }\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   */\n\n\n  var PolymerElement =\n  /*#__PURE__*/\n  function (_polymerElementBase) {\n    _inherits(PolymerElement, _polymerElementBase);\n\n    _createClass(PolymerElement, null, [{\n      key: \"_finalizeClass\",\n\n      /**\n       * Override of PropertiesMixin _finalizeClass to create observers and\n       * find the template.\n       * @return {void}\n       * @protected\n       * @override\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n      value: function _finalizeClass() {\n        _get(_getPrototypeOf(PolymerElement), \"_finalizeClass\", this).call(this);\n\n        if (this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && this.is) {\n          register(this.prototype);\n        }\n\n        var observers = ownObservers(this);\n\n        if (observers) {\n          this.createObservers(observers, this._properties);\n        } // note: create \"working\" template that is finalized at instance time\n\n\n        var template =\n        /** @type {PolymerElementConstructor} */\n        this.template;\n\n        if (template) {\n          if (typeof template === 'string') {\n            console.error('template getter must return HTMLTemplateElement');\n            template = null;\n          } else {\n            template = template.cloneNode(true);\n          }\n        }\n\n        this.prototype._template = template;\n      }\n      /**\n       * Override of PropertiesChanged createProperties to create accessors\n       * and property effects for all of the properties.\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    }, {\n      key: \"createProperties\",\n      value: function createProperties(props) {\n        for (var p in props) {\n          createPropertyFromConfig(this.prototype, p, props[p], props);\n        }\n      }\n      /**\n       * Creates observers for the given `observers` array.\n       * Leverages `PropertyEffects` to create observers.\n       * @param {Object} observers Array of observer descriptors for\n       *   this class\n       * @param {Object} dynamicFns Object containing keys for any properties\n       *   that are functions and should trigger the effect when the function\n       *   reference is changed\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"createObservers\",\n      value: function createObservers(observers, dynamicFns) {\n        var proto = this.prototype;\n\n        for (var i = 0; i < observers.length; i++) {\n          proto._createMethodObserver(observers[i], dynamicFns);\n        }\n      }\n      /**\n       * Returns the template that will be stamped into this element's shadow root.\n       *\n       * If a `static get is()` getter is defined, the default implementation\n       * will return the first `<template>` in a `dom-module` whose `id`\n       * matches this element's `is`.\n       *\n       * Users may override this getter to return an arbitrary template\n       * (in which case the `is` getter is unnecessary). The template returned\n       * must be an `HTMLTemplateElement`.\n       *\n       * Note that when subclassing, if the super class overrode the default\n       * implementation and the subclass would like to provide an alternate\n       * template via a `dom-module`, it should override this getter and\n       * return `DomModule.import(this.is, 'template')`.\n       *\n       * If a subclass would like to modify the super class template, it should\n       * clone it rather than modify it in place.  If the getter does expensive\n       * work such as cloning/modifying a template, it should memoize the\n       * template for maximum performance:\n       *\n       *   let memoizedTemplate;\n       *   class MySubClass extends MySuperClass {\n       *     static get template() {\n       *       if (!memoizedTemplate) {\n       *         memoizedTemplate = super.template.cloneNode(true);\n       *         let subContent = document.createElement('div');\n       *         subContent.textContent = 'This came from MySubClass';\n       *         memoizedTemplate.content.appendChild(subContent);\n       *       }\n       *       return memoizedTemplate;\n       *     }\n       *   }\n       *\n       * @return {!HTMLTemplateElement|string} Template to be stamped\n       */\n\n    }, {\n      key: \"polymerElementVersion\",\n\n      /**\n       * Current Polymer version in Semver notation.\n       * @type {string} Semver notation of the current version of Polymer.\n       */\n      get: function get() {\n        return version;\n      }\n    }, {\n      key: \"template\",\n      get: function get() {\n        // Explanation of template-related properties:\n        // - constructor.template (this getter): the template for the class.\n        //     This can come from the prototype (for legacy elements), from a\n        //     dom-module, or from the super class's template (or can be overridden\n        //     altogether by the user)\n        // - constructor._template: memoized version of constructor.template\n        // - prototype._template: working template for the element, which will be\n        //     parsed and modified in place. It is a cloned version of\n        //     constructor.template, saved in _finalizeClass(). Note that before\n        //     this getter is called, for legacy elements this could be from a\n        //     _template field on the info object passed to Polymer(), a behavior,\n        //     or set in registered(); once the static getter runs, a clone of it\n        //     will overwrite it on the prototype as the working template.\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n          this._template = // If user has put template on prototype (e.g. in legacy via registered\n          // callback or info object), prefer that first\n          this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ? this.prototype._template : // Look in dom-module associated with this element's is\n          getTemplateFromDomModule(\n          /** @type {PolymerElementConstructor}*/\n          this.is) || // Next look for superclass template (call the super impl this\n          // way so that `this` points to the superclass)\n          Object.getPrototypeOf(\n          /** @type {PolymerElementConstructor}*/\n          this.prototype).constructor.template;\n        }\n\n        return this._template;\n      }\n      /**\n       * Set the template.\n       *\n       * @param {!HTMLTemplateElement|string} value Template to set.\n       */\n      ,\n      set: function set(value) {\n        this._template = value;\n      }\n      /**\n       * Path matching the url from which the element was imported.\n       *\n       * This path is used to resolve url's in template style cssText.\n       * The `importPath` property is also set on element instances and can be\n       * used to create bindings relative to the import path.\n       *\n       * For elements defined in ES modules, users should implement\n       * `static get importMeta() { return import.meta; }`, and the default\n       * implementation of `importPath` will  return `import.meta.url`'s path.\n       * For elements defined in HTML imports, this getter will return the path\n       * to the document containing a `dom-module` element matching this\n       * element's static `is` property.\n       *\n       * Note, this path should contain a trailing `/`.\n       *\n       * @return {string} The import path for this element class\n       * @suppress {missingProperties}\n       */\n\n    }, {\n      key: \"importPath\",\n      get: function get() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n          var meta = this.importMeta;\n\n          if (meta) {\n            this._importPath = pathFromUrl(meta.url);\n          } else {\n            var module = DomModule.import(\n            /** @type {PolymerElementConstructor} */\n            this.is);\n            this._importPath = module && module.assetpath || Object.getPrototypeOf(\n            /** @type {PolymerElementConstructor}*/\n            this.prototype).constructor.importPath;\n          }\n        }\n\n        return this._importPath;\n      }\n    }]);\n\n    function PolymerElement() {\n      var _this;\n\n      _classCallCheck(this, PolymerElement);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(PolymerElement).call(this));\n      /** @type {HTMLTemplateElement} */\n\n      _this._template;\n      /** @type {string} */\n\n      _this._importPath;\n      /** @type {string} */\n\n      _this.rootPath;\n      /** @type {string} */\n\n      _this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n\n      _this.root;\n      /** @type {!Object<string, !Element>} */\n\n      _this.$;\n      return _this;\n    }\n    /**\n     * Overrides the default `PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts}\n     */\n\n\n    _createClass(PolymerElement, [{\n      key: \"_initializeProperties\",\n      value: function _initializeProperties() {\n        instanceCount++;\n        this.constructor.finalize(); // note: finalize template when we have access to `localName` to\n        // avoid dependence on `is` for polyfilling styling.\n\n        this.constructor._finalizeTemplate(\n        /** @type {!HTMLElement} */\n        this.localName);\n\n        _get(_getPrototypeOf(PolymerElement.prototype), \"_initializeProperties\", this).call(this); // set path defaults\n\n\n        this.rootPath = rootPath;\n        this.importPath = this.constructor.importPath; // apply property defaults...\n\n        var p$ = propertyDefaults(this.constructor);\n\n        if (!p$) {\n          return;\n        }\n\n        for (var p in p$) {\n          var info = p$[p]; // Don't set default value if there is already an own property, which\n          // happens when a `properties` property with default but no effects had\n          // a property set (e.g. bound) by its host before upgrade\n\n          if (!this.hasOwnProperty(p)) {\n            var value = typeof info.value == 'function' ? info.value.call(this) : info.value; // Set via `_setProperty` if there is an accessor, to enable\n            // initializing readOnly property defaults\n\n            if (this._hasAccessor(p)) {\n              this._setPendingProperty(p, value, true);\n            } else {\n              this[p] = value;\n            }\n          }\n        }\n      }\n      /**\n       * Gather style text for a style element in the template.\n       *\n       * @param {string} cssText Text containing styling to process\n       * @param {string} baseURI Base URI to rebase CSS paths against\n       * @return {string} The processed CSS text\n       * @protected\n       */\n\n    }, {\n      key: \"connectedCallback\",\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `connectedCallback`.\n       *\n       * The default implementation enables the property effects system and\n       * flushes any pending properties, and updates shimmed CSS properties\n       * when using the ShadyCSS scoping/custom properties polyfill.\n       *\n       * @suppress {missingProperties, invalidCasts} Super may or may not implement the callback\n       * @return {void}\n       */\n      value: function connectedCallback() {\n        if (window.ShadyCSS && this._template) {\n          window.ShadyCSS.styleElement(\n          /** @type {!HTMLElement} */\n          this);\n        }\n\n        _get(_getPrototypeOf(PolymerElement.prototype), \"connectedCallback\", this).call(this);\n      }\n      /**\n       * Stamps the element template.\n       *\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"ready\",\n      value: function ready() {\n        if (this._template) {\n          this.root = this._stampTemplate(this._template);\n          this.$ = this.root.$;\n        }\n\n        _get(_getPrototypeOf(PolymerElement.prototype), \"ready\", this).call(this);\n      }\n      /**\n       * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n       * element dom by calling `_attachDom` with the dom stamped from the\n       * element's template via `_stampTemplate`. Note that this allows\n       * client dom to be attached to the element prior to any observers\n       * running.\n       *\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"_readyClients\",\n      value: function _readyClients() {\n        if (this._template) {\n          this.root = this._attachDom(\n          /** @type {StampedTemplate} */\n          this.root);\n        } // The super._readyClients here sets the clients initialized flag.\n        // We must wait to do this until after client dom is created/attached\n        // so that this flag can be checked to prevent notifications fired\n        // during this process from being handled before clients are ready.\n\n\n        _get(_getPrototypeOf(PolymerElement.prototype), \"_readyClients\", this).call(this);\n      }\n      /**\n       * Attaches an element's stamped dom to itself. By default,\n       * this method creates a `shadowRoot` and adds the dom to it.\n       * However, this method may be overridden to allow an element\n       * to put its dom in another location.\n       *\n       * @throws {Error}\n       * @suppress {missingReturn}\n       * @param {StampedTemplate} dom to attach to the element.\n       * @return {ShadowRoot} node to which the dom has been attached.\n       */\n\n    }, {\n      key: \"_attachDom\",\n      value: function _attachDom(dom) {\n        if (this.attachShadow) {\n          if (dom) {\n            if (!this.shadowRoot) {\n              this.attachShadow({\n                mode: 'open'\n              });\n            }\n\n            this.shadowRoot.appendChild(dom);\n            return this.shadowRoot;\n          }\n\n          return null;\n        } else {\n          throw new Error('ShadowDOM not available. ' + // TODO(sorvell): move to compile-time conditional when supported\n          'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n        }\n      }\n      /**\n       * When using the ShadyCSS scoping and custom property shim, causes all\n       * shimmed styles in this element (and its subtree) to be updated\n       * based on current custom property values.\n       *\n       * The optional parameter overrides inline custom property styles with an\n       * object of properties where the keys are CSS properties, and the values\n       * are strings.\n       *\n       * Example: `this.updateStyles({'--color': 'blue'})`\n       *\n       * These properties are retained unless a value of `null` is set.\n       *\n       * Note: This function does not support updating CSS mixins.\n       * You can not dynamically change the value of an `@apply`.\n       *\n       * @param {Object=} properties Bag of custom property key/values to\n       *   apply to this element.\n       * @return {void}\n       * @suppress {invalidCasts}\n       */\n\n    }, {\n      key: \"updateStyles\",\n      value: function updateStyles(properties) {\n        if (window.ShadyCSS) {\n          window.ShadyCSS.styleSubtree(\n          /** @type {!HTMLElement} */\n          this, properties);\n        }\n      }\n      /**\n       * Rewrites a given URL relative to a base URL. The base URL defaults to\n       * the original location of the document containing the `dom-module` for\n       * this element. This method will return the same URL before and after\n       * bundling.\n       *\n       * Note that this function performs no resolution for URLs that start\n       * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n       * URL resolution, use `window.URL`.\n       *\n       * @param {string} url URL to resolve.\n       * @param {string=} base Optional base URL to resolve against, defaults\n       * to the element's `importPath`\n       * @return {string} Rewritten URL relative to base\n       */\n\n    }, {\n      key: \"resolveUrl\",\n      value: function resolveUrl(url, base) {\n        if (!base && this.importPath) {\n          base = _resolveUrl(this.importPath);\n        }\n\n        return _resolveUrl(url, base);\n      }\n      /**\n       * Overrides `PropertyAccessors` to add map of dynamic functions on\n       * template info, for consumption by `PropertyEffects` template binding\n       * code. This map determines which method templates should have accessors\n       * created for them.\n       *\n       * @override\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    }], [{\n      key: \"_processStyleText\",\n      value: function _processStyleText(cssText, baseURI) {\n        return resolveCss(cssText, baseURI);\n      }\n      /**\n      * Configures an element `proto` to function with a given `template`.\n      * The element name `is` and extends `ext` must be specified for ShadyCSS\n      * style scoping.\n      *\n      * @param {string} is Tag name (or type extension name) for this element\n      * @return {void}\n      * @protected\n      */\n\n    }, {\n      key: \"_finalizeTemplate\",\n      value: function _finalizeTemplate(is) {\n        /** @const {HTMLTemplateElement} */\n        var template = this.prototype._template;\n\n        if (template && !template.__polymerFinalized) {\n          template.__polymerFinalized = true;\n          var importPath = this.importPath;\n          var baseURI = importPath ? _resolveUrl(importPath) : ''; // e.g. support `include=\"module-name\"`, and ShadyCSS\n\n          processElementStyles(this, template, is, baseURI);\n\n          this.prototype._bindTemplate(template);\n        }\n      }\n    }, {\n      key: \"_parseTemplateContent\",\n      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {\n        templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n        return _get(_getPrototypeOf(PolymerElement), \"_parseTemplateContent\", this).call(this, template, templateInfo, nodeInfo);\n      }\n    }]);\n\n    return PolymerElement;\n  }(polymerElementBase);\n\n  return PolymerElement;\n});\n/**\n * Total number of Polymer element instances created.\n * @type {number}\n */\n\nexport var instanceCount = 0;\n/**\n * Array of Polymer element classes that have been finalized.\n * @type {Array<PolymerElement>}\n */\n\nexport var registrations = [];\n/**\n * @param {!PolymerElementConstructor} prototype Element prototype to log\n * @this {this}\n * @private\n */\n\nfunction _regLog(prototype) {\n  console.log('[' + prototype.is + ']: registered');\n}\n/**\n * Registers a class prototype for telemetry purposes.\n * @param {HTMLElement} prototype Element prototype to register\n * @this {this}\n * @protected\n */\n\n\nexport function register(prototype) {\n  registrations.push(prototype);\n}\n/**\n * Logs all elements registered with an `is` to the console.\n * @public\n * @this {this}\n */\n\nexport function dumpRegistrations() {\n  registrations.forEach(_regLog);\n}\n/**\n * When using the ShadyCSS scoping and custom property shim, causes all\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n * to be updated based on current custom property values.\n *\n * The optional parameter overrides inline custom property styles with an\n * object of properties where the keys are CSS properties, and the values\n * are strings.\n *\n * Example: `updateStyles({'--color': 'blue'})`\n *\n * These properties are retained unless a value of `null` is set.\n *\n * @param {Object=} props Bag of custom property key/values to\n *   apply to the document.\n * @return {void}\n */\n\nexport var updateStyles = function updateStyles(props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}