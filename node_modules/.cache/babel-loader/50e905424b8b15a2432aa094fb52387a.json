{"ast":null,"code":"import _taggedTemplateLiteral from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/taggedTemplateLiteral\";\nimport _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: flex;\\n        flex-direction: column;\\n        height: 100%;\\n        width: 100%;\\n        outline: none;\\n        background: #fff;\\n      }\\n\\n      [part=\\\"overlay-header\\\"] {\\n        display: flex;\\n        flex-shrink: 0;\\n        flex-wrap: nowrap;\\n        align-items: center;\\n      }\\n\\n      :host(:not([fullscreen])) [part=\\\"overlay-header\\\"] {\\n        display: none;\\n      }\\n\\n      [part=\\\"label\\\"] {\\n        flex-grow: 1;\\n      }\\n\\n      [part=\\\"clear-button\\\"],\\n      [part=\\\"toggle-button\\\"],\\n      [part=\\\"years-toggle-button\\\"]::before {\\n        font-family: 'vaadin-date-picker-icons';\\n      }\\n\\n      [part=\\\"clear-button\\\"]:not([showclear]) {\\n        display: none;\\n      }\\n\\n      [part=\\\"clear-button\\\"]::before {\\n        content: \\\"\\\\e901\\\";\\n      }\\n\\n      [part=\\\"toggle-button\\\"]::before {\\n        content: \\\"\\\\e902\\\";\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"] {\\n        display: flex;\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"][desktop] {\\n        display: none;\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"]::before {\\n        content: \\\"\\\\e900\\\";\\n      }\\n\\n      :host(:not([years-visible])) [part=\\\"years-toggle-button\\\"]::before {\\n        transform: rotate(180deg);\\n      }\\n\\n      #scrollers {\\n        display: flex;\\n        height: 100%;\\n        width: 100%;\\n        position: relative;\\n        overflow: hidden;\\n      }\\n\\n      [part=\\\"months\\\"],\\n      [part=\\\"years\\\"] {\\n        height: 100%;\\n      }\\n\\n      [part=\\\"months\\\"] {\\n        --vaadin-infinite-scroller-item-height: 270px;\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        bottom: 0;\\n      }\\n\\n      #scrollers[desktop] [part=\\\"months\\\"] {\\n        right: 50px;\\n        transform: none !important;\\n      }\\n\\n      [part=\\\"years\\\"] {\\n        --vaadin-infinite-scroller-item-height: 80px;\\n        width: 50px;\\n        position: absolute;\\n        right: 0;\\n        transform: translateX(100%);\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        /* Center the year scroller position. */\\n        --vaadin-infinite-scroller-buffer-offset: 50%;\\n      }\\n\\n      #scrollers[desktop] [part=\\\"years\\\"] {\\n        position: absolute;\\n        transform: none !important;\\n      }\\n\\n      [part=\\\"years\\\"]::before {\\n        content: '';\\n        display: block;\\n        background: transparent;\\n        width: 0;\\n        height: 0;\\n        position: absolute;\\n        left: 0;\\n        top: 50%;\\n        transform: translateY(-50%);\\n        border-width: 6px;\\n        border-style: solid;\\n        border-color: transparent;\\n        border-left-color: #000;\\n      }\\n\\n      :host(.animate) [part=\\\"months\\\"],\\n      :host(.animate) [part=\\\"years\\\"] {\\n        transition: all 200ms;\\n      }\\n\\n      [part=\\\"toolbar\\\"] {\\n        display: flex;\\n        justify-content: space-between;\\n        z-index: 2;\\n        flex-shrink: 0;\\n      }\\n\\n      [part~=\\\"overlay-header\\\"]:not([desktop]) {\\n        padding-bottom: 40px;\\n      }\\n\\n      [part~=\\\"years-toggle-button\\\"] {\\n        position: absolute;\\n        top: auto;\\n        right: 8px;\\n        bottom: 0;\\n        z-index: 1;\\n        padding: 8px;\\n      }\\n\\n      #announcer {\\n        display: inline-block;\\n        position: fixed;\\n        clip: rect(0, 0, 0, 0);\\n        clip-path: inset(100%);\\n      }\\n    </style>\\n\\n    <div id=\\\"announcer\\\" role=\\\"alert\\\" aria-live=\\\"polite\\\">\\n      [[i18n.calendar]]\\n    </div>\\n\\n    <div part=\\\"overlay-header\\\" on-touchend=\\\"_preventDefault\\\" desktop$=\\\"[[_desktopMode]]\\\" aria-hidden=\\\"true\\\">\\n      <div part=\\\"label\\\">[[_formatDisplayed(selectedDate, i18n.formatDate, label)]]</div>\\n      <div part=\\\"clear-button\\\" on-tap=\\\"_clear\\\" showclear$=\\\"[[_showClear(selectedDate)]]\\\"></div>\\n      <div part=\\\"toggle-button\\\" on-tap=\\\"_cancel\\\"></div>\\n\\n      <div part=\\\"years-toggle-button\\\" desktop$=\\\"[[_desktopMode]]\\\" on-tap=\\\"_toggleYearScroller\\\" aria-hidden=\\\"true\\\">\\n        [[_yearAfterXMonths(_visibleMonthIndex)]]\\n      </div>\\n    </div>\\n\\n    <div id=\\\"scrollers\\\" desktop$=\\\"[[_desktopMode]]\\\" on-track=\\\"_track\\\">\\n      <vaadin-infinite-scroller id=\\\"monthScroller\\\" on-custom-scroll=\\\"_onMonthScroll\\\" on-touchstart=\\\"_onMonthScrollTouchStart\\\" buffer-size=\\\"3\\\" active=\\\"[[initialPosition]]\\\" part=\\\"months\\\">\\n        <template>\\n          <vaadin-month-calendar i18n=\\\"[[i18n]]\\\" month=\\\"[[_dateAfterXMonths(index)]]\\\" selected-date=\\\"{{selectedDate}}\\\" focused-date=\\\"[[focusedDate]]\\\" ignore-taps=\\\"[[_ignoreTaps]]\\\" show-week-numbers=\\\"[[showWeekNumbers]]\\\" min-date=\\\"[[minDate]]\\\" max-date=\\\"[[maxDate]]\\\" focused$=\\\"[[_focused]]\\\" part=\\\"month\\\" theme$=\\\"[[theme]]\\\">\\n          </vaadin-month-calendar>\\n        </template>\\n      </vaadin-infinite-scroller>\\n      <vaadin-infinite-scroller id=\\\"yearScroller\\\" on-tap=\\\"_onYearTap\\\" on-custom-scroll=\\\"_onYearScroll\\\" on-touchstart=\\\"_onYearScrollTouchStart\\\" buffer-size=\\\"12\\\" active=\\\"[[initialPosition]]\\\" part=\\\"years\\\">\\n        <template>\\n          <div part=\\\"year-number\\\" role=\\\"button\\\" current$=\\\"[[_isCurrentYear(index)]]\\\" selected$=\\\"[[_isSelectedYear(index, selectedDate)]]\\\">\\n            [[_yearAfterXYears(index)]]\\n          </div>\\n          <div part=\\\"year-separator\\\" aria-hidden=\\\"true\\\"></div>\\n        </template>\\n      </vaadin-infinite-scroller>\\n    </div>\\n\\n    <div on-touchend=\\\"_preventDefault\\\" role=\\\"toolbar\\\" part=\\\"toolbar\\\">\\n      <vaadin-button id=\\\"todayButton\\\" part=\\\"today-button\\\" disabled=\\\"[[!_isTodayAllowed(minDate, maxDate)]]\\\" on-tap=\\\"_onTodayTap\\\">\\n        [[i18n.today]]\\n      </vaadin-button>\\n      <vaadin-button id=\\\"cancelButton\\\" part=\\\"cancel-button\\\" on-tap=\\\"_cancel\\\">\\n        [[i18n.cancel]]\\n      </vaadin-button>\\n    </div>\\n\\n    <iron-media-query query=\\\"(min-width: 375px)\\\" query-matches=\\\"{{_desktopMode}}\\\"></iron-media-query>\\n\"], [\"\\n    <style>\\n      :host {\\n        display: flex;\\n        flex-direction: column;\\n        height: 100%;\\n        width: 100%;\\n        outline: none;\\n        background: #fff;\\n      }\\n\\n      [part=\\\"overlay-header\\\"] {\\n        display: flex;\\n        flex-shrink: 0;\\n        flex-wrap: nowrap;\\n        align-items: center;\\n      }\\n\\n      :host(:not([fullscreen])) [part=\\\"overlay-header\\\"] {\\n        display: none;\\n      }\\n\\n      [part=\\\"label\\\"] {\\n        flex-grow: 1;\\n      }\\n\\n      [part=\\\"clear-button\\\"],\\n      [part=\\\"toggle-button\\\"],\\n      [part=\\\"years-toggle-button\\\"]::before {\\n        font-family: 'vaadin-date-picker-icons';\\n      }\\n\\n      [part=\\\"clear-button\\\"]:not([showclear]) {\\n        display: none;\\n      }\\n\\n      [part=\\\"clear-button\\\"]::before {\\n        content: \\\"\\\\\\\\e901\\\";\\n      }\\n\\n      [part=\\\"toggle-button\\\"]::before {\\n        content: \\\"\\\\\\\\e902\\\";\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"] {\\n        display: flex;\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"][desktop] {\\n        display: none;\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"]::before {\\n        content: \\\"\\\\\\\\e900\\\";\\n      }\\n\\n      :host(:not([years-visible])) [part=\\\"years-toggle-button\\\"]::before {\\n        transform: rotate(180deg);\\n      }\\n\\n      #scrollers {\\n        display: flex;\\n        height: 100%;\\n        width: 100%;\\n        position: relative;\\n        overflow: hidden;\\n      }\\n\\n      [part=\\\"months\\\"],\\n      [part=\\\"years\\\"] {\\n        height: 100%;\\n      }\\n\\n      [part=\\\"months\\\"] {\\n        --vaadin-infinite-scroller-item-height: 270px;\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        bottom: 0;\\n      }\\n\\n      #scrollers[desktop] [part=\\\"months\\\"] {\\n        right: 50px;\\n        transform: none !important;\\n      }\\n\\n      [part=\\\"years\\\"] {\\n        --vaadin-infinite-scroller-item-height: 80px;\\n        width: 50px;\\n        position: absolute;\\n        right: 0;\\n        transform: translateX(100%);\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        /* Center the year scroller position. */\\n        --vaadin-infinite-scroller-buffer-offset: 50%;\\n      }\\n\\n      #scrollers[desktop] [part=\\\"years\\\"] {\\n        position: absolute;\\n        transform: none !important;\\n      }\\n\\n      [part=\\\"years\\\"]::before {\\n        content: '';\\n        display: block;\\n        background: transparent;\\n        width: 0;\\n        height: 0;\\n        position: absolute;\\n        left: 0;\\n        top: 50%;\\n        transform: translateY(-50%);\\n        border-width: 6px;\\n        border-style: solid;\\n        border-color: transparent;\\n        border-left-color: #000;\\n      }\\n\\n      :host(.animate) [part=\\\"months\\\"],\\n      :host(.animate) [part=\\\"years\\\"] {\\n        transition: all 200ms;\\n      }\\n\\n      [part=\\\"toolbar\\\"] {\\n        display: flex;\\n        justify-content: space-between;\\n        z-index: 2;\\n        flex-shrink: 0;\\n      }\\n\\n      [part~=\\\"overlay-header\\\"]:not([desktop]) {\\n        padding-bottom: 40px;\\n      }\\n\\n      [part~=\\\"years-toggle-button\\\"] {\\n        position: absolute;\\n        top: auto;\\n        right: 8px;\\n        bottom: 0;\\n        z-index: 1;\\n        padding: 8px;\\n      }\\n\\n      #announcer {\\n        display: inline-block;\\n        position: fixed;\\n        clip: rect(0, 0, 0, 0);\\n        clip-path: inset(100%);\\n      }\\n    </style>\\n\\n    <div id=\\\"announcer\\\" role=\\\"alert\\\" aria-live=\\\"polite\\\">\\n      [[i18n.calendar]]\\n    </div>\\n\\n    <div part=\\\"overlay-header\\\" on-touchend=\\\"_preventDefault\\\" desktop\\\\$=\\\"[[_desktopMode]]\\\" aria-hidden=\\\"true\\\">\\n      <div part=\\\"label\\\">[[_formatDisplayed(selectedDate, i18n.formatDate, label)]]</div>\\n      <div part=\\\"clear-button\\\" on-tap=\\\"_clear\\\" showclear\\\\$=\\\"[[_showClear(selectedDate)]]\\\"></div>\\n      <div part=\\\"toggle-button\\\" on-tap=\\\"_cancel\\\"></div>\\n\\n      <div part=\\\"years-toggle-button\\\" desktop\\\\$=\\\"[[_desktopMode]]\\\" on-tap=\\\"_toggleYearScroller\\\" aria-hidden=\\\"true\\\">\\n        [[_yearAfterXMonths(_visibleMonthIndex)]]\\n      </div>\\n    </div>\\n\\n    <div id=\\\"scrollers\\\" desktop\\\\$=\\\"[[_desktopMode]]\\\" on-track=\\\"_track\\\">\\n      <vaadin-infinite-scroller id=\\\"monthScroller\\\" on-custom-scroll=\\\"_onMonthScroll\\\" on-touchstart=\\\"_onMonthScrollTouchStart\\\" buffer-size=\\\"3\\\" active=\\\"[[initialPosition]]\\\" part=\\\"months\\\">\\n        <template>\\n          <vaadin-month-calendar i18n=\\\"[[i18n]]\\\" month=\\\"[[_dateAfterXMonths(index)]]\\\" selected-date=\\\"{{selectedDate}}\\\" focused-date=\\\"[[focusedDate]]\\\" ignore-taps=\\\"[[_ignoreTaps]]\\\" show-week-numbers=\\\"[[showWeekNumbers]]\\\" min-date=\\\"[[minDate]]\\\" max-date=\\\"[[maxDate]]\\\" focused\\\\$=\\\"[[_focused]]\\\" part=\\\"month\\\" theme\\\\$=\\\"[[theme]]\\\">\\n          </vaadin-month-calendar>\\n        </template>\\n      </vaadin-infinite-scroller>\\n      <vaadin-infinite-scroller id=\\\"yearScroller\\\" on-tap=\\\"_onYearTap\\\" on-custom-scroll=\\\"_onYearScroll\\\" on-touchstart=\\\"_onYearScrollTouchStart\\\" buffer-size=\\\"12\\\" active=\\\"[[initialPosition]]\\\" part=\\\"years\\\">\\n        <template>\\n          <div part=\\\"year-number\\\" role=\\\"button\\\" current\\\\$=\\\"[[_isCurrentYear(index)]]\\\" selected\\\\$=\\\"[[_isSelectedYear(index, selectedDate)]]\\\">\\n            [[_yearAfterXYears(index)]]\\n          </div>\\n          <div part=\\\"year-separator\\\" aria-hidden=\\\"true\\\"></div>\\n        </template>\\n      </vaadin-infinite-scroller>\\n    </div>\\n\\n    <div on-touchend=\\\"_preventDefault\\\" role=\\\"toolbar\\\" part=\\\"toolbar\\\">\\n      <vaadin-button id=\\\"todayButton\\\" part=\\\"today-button\\\" disabled=\\\"[[!_isTodayAllowed(minDate, maxDate)]]\\\" on-tap=\\\"_onTodayTap\\\">\\n        [[i18n.today]]\\n      </vaadin-button>\\n      <vaadin-button id=\\\"cancelButton\\\" part=\\\"cancel-button\\\" on-tap=\\\"_cancel\\\">\\n        [[i18n.cancel]]\\n      </vaadin-button>\\n    </div>\\n\\n    <iron-media-query query=\\\"(min-width: 375px)\\\" query-matches=\\\"{{_desktopMode}}\\\"></iron-media-query>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport '@polymer/iron-media-query/iron-media-query.js';\nimport { IronA11yKeysBehavior } from '@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';\nimport { IronA11yAnnouncer } from '@polymer/iron-a11y-announcer/iron-a11y-announcer.js';\nimport '@vaadin/vaadin-button/src/vaadin-button.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ThemePropertyMixin } from '@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js';\nimport './vaadin-month-calendar.js';\nimport './vaadin-infinite-scroller.js';\nimport { DatePickerHelper } from './vaadin-date-picker-helper.js';\nimport './vaadin-date-picker-styles.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { addListener, setTouchAction } from '@polymer/polymer/lib/utils/gestures.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\n/**\n * @memberof Vaadin\n * @private\n */\n\nvar DatePickerOverlayContentElement =\n/*#__PURE__*/\nfunction (_ThemableMixin) {\n  _inherits(DatePickerOverlayContentElement, _ThemableMixin);\n\n  function DatePickerOverlayContentElement() {\n    _classCallCheck(this, DatePickerOverlayContentElement);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DatePickerOverlayContentElement).apply(this, arguments));\n  }\n\n  _createClass(DatePickerOverlayContentElement, [{\n    key: \"ready\",\n    value: function ready() {\n      _get(_getPrototypeOf(DatePickerOverlayContentElement.prototype), \"ready\", this).call(this);\n\n      this.setAttribute('tabindex', 0);\n      this.addEventListener('keydown', this._onKeydown.bind(this));\n      addListener(this, 'tap', this._stopPropagation);\n      this.addEventListener('focus', this._onOverlayFocus.bind(this));\n      this.addEventListener('blur', this._onOverlayBlur.bind(this));\n    }\n    /**\n     * Fired when the scroller reaches the target scrolling position.\n     * @event scroll-animation-finished\n     * @param {Number} detail.position new position\n     * @param {Number} detail.oldPosition old position\n     */\n\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(DatePickerOverlayContentElement.prototype), \"connectedCallback\", this).call(this);\n\n      this._closeYearScroller();\n\n      this._toggleAnimateClass(true);\n\n      setTouchAction(this.$.scrollers, 'pan-y');\n      IronA11yAnnouncer.requestAvailability();\n    }\n  }, {\n    key: \"announceFocusedDate\",\n    value: function announceFocusedDate() {\n      var focusedDate = this._currentlyFocusedDate();\n\n      var announce = [];\n\n      if (DatePickerHelper._dateEquals(focusedDate, new Date())) {\n        announce.push(this.i18n.today);\n      }\n\n      announce = announce.concat([this.i18n.weekdays[focusedDate.getDay()], focusedDate.getDate(), this.i18n.monthNames[focusedDate.getMonth()], focusedDate.getFullYear()]);\n\n      if (this.showWeekNumbers && this.i18n.firstDayOfWeek === 1) {\n        announce.push(this.i18n.week);\n        announce.push(DatePickerHelper._getISOWeekNumber(focusedDate));\n      }\n\n      this.dispatchEvent(new CustomEvent('iron-announce', {\n        bubbles: true,\n        composed: true,\n        detail: {\n          text: announce.join(' ')\n        }\n      }));\n      return;\n    }\n    /**\n     * Focuses the cancel button\n     */\n\n  }, {\n    key: \"focusCancel\",\n    value: function focusCancel() {\n      this.$.cancelButton.focus();\n    }\n    /**\n     * Scrolls the list to the given Date.\n     */\n\n  }, {\n    key: \"scrollToDate\",\n    value: function scrollToDate(date, animate) {\n      this._scrollToPosition(this._differenceInMonths(date, this._originDate), animate);\n    }\n  }, {\n    key: \"_focusedDateChanged\",\n    value: function _focusedDateChanged(focusedDate) {\n      this.revealDate(focusedDate);\n    }\n  }, {\n    key: \"_isCurrentYear\",\n    value: function _isCurrentYear(yearsFromNow) {\n      return yearsFromNow === 0;\n    }\n  }, {\n    key: \"_isSelectedYear\",\n    value: function _isSelectedYear(yearsFromNow, selectedDate) {\n      if (selectedDate) {\n        return selectedDate.getFullYear() === this._originDate.getFullYear() + yearsFromNow;\n      }\n    }\n    /**\n     * Scrolls the month and year scrollers enough to reveal the given date.\n     */\n\n  }, {\n    key: \"revealDate\",\n    value: function revealDate(date) {\n      if (date) {\n        var diff = this._differenceInMonths(date, this._originDate);\n\n        var scrolledAboveViewport = this.$.monthScroller.position > diff;\n        var visibleItems = this.$.monthScroller.clientHeight / this.$.monthScroller.itemHeight;\n        var scrolledBelowViewport = this.$.monthScroller.position + visibleItems - 1 < diff;\n\n        if (scrolledAboveViewport) {\n          this._scrollToPosition(diff, true);\n        } else if (scrolledBelowViewport) {\n          this._scrollToPosition(diff - visibleItems + 1, true);\n        }\n      }\n    }\n  }, {\n    key: \"_onOverlayFocus\",\n    value: function _onOverlayFocus() {\n      this._focused = true;\n    }\n  }, {\n    key: \"_onOverlayBlur\",\n    value: function _onOverlayBlur() {\n      this._focused = false;\n    }\n  }, {\n    key: \"_initialPositionChanged\",\n    value: function _initialPositionChanged(initialPosition) {\n      this.scrollToDate(initialPosition);\n    }\n  }, {\n    key: \"_repositionYearScroller\",\n    value: function _repositionYearScroller() {\n      this._visibleMonthIndex = Math.floor(this.$.monthScroller.position);\n      this.$.yearScroller.position = (this.$.monthScroller.position + this._originDate.getMonth()) / 12;\n    }\n  }, {\n    key: \"_repositionMonthScroller\",\n    value: function _repositionMonthScroller() {\n      this.$.monthScroller.position = this.$.yearScroller.position * 12 - this._originDate.getMonth();\n      this._visibleMonthIndex = Math.floor(this.$.monthScroller.position);\n    }\n  }, {\n    key: \"_onMonthScroll\",\n    value: function _onMonthScroll() {\n      this._repositionYearScroller();\n\n      this._doIgnoreTaps();\n    }\n  }, {\n    key: \"_onYearScroll\",\n    value: function _onYearScroll() {\n      this._repositionMonthScroller();\n\n      this._doIgnoreTaps();\n    }\n  }, {\n    key: \"_onYearScrollTouchStart\",\n    value: function _onYearScrollTouchStart() {\n      var _this = this;\n\n      this._notTapping = false;\n      setTimeout(function () {\n        return _this._notTapping = true;\n      }, 300);\n\n      this._repositionMonthScroller();\n    }\n  }, {\n    key: \"_onMonthScrollTouchStart\",\n    value: function _onMonthScrollTouchStart() {\n      this._repositionYearScroller();\n    }\n  }, {\n    key: \"_doIgnoreTaps\",\n    value: function _doIgnoreTaps() {\n      var _this2 = this;\n\n      this._ignoreTaps = true;\n      this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(300), function () {\n        return _this2._ignoreTaps = false;\n      });\n    }\n  }, {\n    key: \"_formatDisplayed\",\n    value: function _formatDisplayed(date, formatDate, label) {\n      if (date) {\n        return formatDate(DatePickerHelper._extractDateParts(date));\n      } else {\n        return label;\n      }\n    }\n  }, {\n    key: \"_onTodayTap\",\n    value: function _onTodayTap() {\n      var today = new Date();\n\n      if (this.$.monthScroller.position === this._differenceInMonths(today, this._originDate)) {\n        // Select today only if the month scroller is positioned exactly\n        // at the beginning of the current month\n        this.selectedDate = today;\n\n        this._close();\n      } else {\n        this._scrollToCurrentMonth();\n      }\n    }\n  }, {\n    key: \"_scrollToCurrentMonth\",\n    value: function _scrollToCurrentMonth() {\n      if (this.focusedDate) {\n        this.focusedDate = new Date();\n      }\n\n      this.scrollToDate(new Date(), true);\n    }\n  }, {\n    key: \"_showClear\",\n    value: function _showClear(selectedDate) {\n      return !!selectedDate;\n    }\n  }, {\n    key: \"_onYearTap\",\n    value: function _onYearTap(e) {\n      if (!this._ignoreTaps && !this._notTapping) {\n        var scrollDelta = e.detail.y - (this.$.yearScroller.getBoundingClientRect().top + this.$.yearScroller.clientHeight / 2);\n        var yearDelta = scrollDelta / this.$.yearScroller.itemHeight;\n\n        this._scrollToPosition(this.$.monthScroller.position + yearDelta * 12, true);\n      }\n    }\n  }, {\n    key: \"_scrollToPosition\",\n    value: function _scrollToPosition(targetPosition, animate) {\n      var _this3 = this;\n\n      if (this._targetPosition !== undefined) {\n        this._targetPosition = targetPosition;\n        return;\n      }\n\n      if (!animate) {\n        this.$.monthScroller.position = targetPosition;\n        this._targetPosition = undefined;\n\n        this._repositionYearScroller();\n\n        return;\n      }\n\n      this._targetPosition = targetPosition; // http://gizma.com/easing/\n\n      var easingFunction = function easingFunction(t, b, c, d) {\n        t /= d / 2;\n\n        if (t < 1) {\n          return c / 2 * t * t + b;\n        }\n\n        t--;\n        return -c / 2 * (t * (t - 2) - 1) + b;\n      };\n\n      var duration = animate ? 300 : 0;\n      var start = 0;\n      var initialPosition = this.$.monthScroller.position;\n\n      var smoothScroll = function smoothScroll(timestamp) {\n        start = start || timestamp;\n        var currentTime = timestamp - start;\n\n        if (currentTime < duration) {\n          var currentPos = easingFunction(currentTime, initialPosition, _this3._targetPosition - initialPosition, duration);\n          _this3.$.monthScroller.position = currentPos;\n          window.requestAnimationFrame(smoothScroll);\n        } else {\n          _this3.dispatchEvent(new CustomEvent('scroll-animation-finished', {\n            bubbles: true,\n            composed: true,\n            detail: {\n              position: _this3._targetPosition,\n              oldPosition: initialPosition\n            }\n          }));\n\n          _this3.$.monthScroller.position = _this3._targetPosition;\n          _this3._targetPosition = undefined;\n        }\n\n        setTimeout(_this3._repositionYearScroller.bind(_this3), 1);\n      }; // Start the animation.\n\n\n      window.requestAnimationFrame(smoothScroll);\n    }\n  }, {\n    key: \"_limit\",\n    value: function _limit(value, range) {\n      return Math.min(range.max, Math.max(range.min, value));\n    }\n  }, {\n    key: \"_handleTrack\",\n    value: function _handleTrack(e) {\n      // Check if horizontal movement threshold (dx) not exceeded or\n      // scrolling fast vertically (ddy).\n      if (Math.abs(e.detail.dx) < 10 || Math.abs(e.detail.ddy) > 10) {\n        return;\n      } // If we're flinging quickly -> start animating already.\n\n\n      if (Math.abs(e.detail.ddx) > this._yearScrollerWidth / 3) {\n        this._toggleAnimateClass(true);\n      }\n\n      var newTranslateX = this._translateX + e.detail.ddx;\n      this._translateX = this._limit(newTranslateX, {\n        min: 0,\n        max: this._yearScrollerWidth\n      });\n    }\n  }, {\n    key: \"_track\",\n    value: function _track(e) {\n      if (this._desktopMode) {\n        // No need to track for swipe gestures on desktop.\n        return;\n      }\n\n      switch (e.detail.state) {\n        case 'start':\n          this._toggleAnimateClass(false);\n\n          break;\n\n        case 'track':\n          this._handleTrack(e);\n\n          break;\n\n        case 'end':\n          this._toggleAnimateClass(true);\n\n          if (this._translateX >= this._yearScrollerWidth / 2) {\n            this._closeYearScroller();\n          } else {\n            this._openYearScroller();\n          }\n\n          break;\n      }\n    }\n  }, {\n    key: \"_toggleAnimateClass\",\n    value: function _toggleAnimateClass(enable) {\n      if (enable) {\n        this.classList.add('animate');\n      } else {\n        this.classList.remove('animate');\n      }\n    }\n  }, {\n    key: \"_toggleYearScroller\",\n    value: function _toggleYearScroller() {\n      this._isYearScrollerVisible() ? this._closeYearScroller() : this._openYearScroller();\n    }\n  }, {\n    key: \"_openYearScroller\",\n    value: function _openYearScroller() {\n      this._translateX = 0;\n      this.setAttribute('years-visible', '');\n    }\n  }, {\n    key: \"_closeYearScroller\",\n    value: function _closeYearScroller() {\n      this.removeAttribute('years-visible');\n      this._translateX = this._yearScrollerWidth;\n    }\n  }, {\n    key: \"_isYearScrollerVisible\",\n    value: function _isYearScrollerVisible() {\n      return this._translateX < this._yearScrollerWidth / 2;\n    }\n  }, {\n    key: \"_translateXChanged\",\n    value: function _translateXChanged(x) {\n      if (!this._desktopMode) {\n        this.$.monthScroller.style.transform = 'translateX(' + (x - this._yearScrollerWidth) + 'px)';\n        this.$.yearScroller.style.transform = 'translateX(' + x + 'px)';\n      }\n    }\n  }, {\n    key: \"_yearAfterXYears\",\n    value: function _yearAfterXYears(index) {\n      var result = new Date(this._originDate);\n      result.setFullYear(parseInt(index) + this._originDate.getFullYear());\n      return result.getFullYear();\n    }\n  }, {\n    key: \"_yearAfterXMonths\",\n    value: function _yearAfterXMonths(months) {\n      return this._dateAfterXMonths(months).getFullYear();\n    }\n  }, {\n    key: \"_dateAfterXMonths\",\n    value: function _dateAfterXMonths(months) {\n      var result = new Date(this._originDate);\n      result.setDate(1);\n      result.setMonth(parseInt(months) + this._originDate.getMonth());\n      return result;\n    }\n  }, {\n    key: \"_differenceInMonths\",\n    value: function _differenceInMonths(date1, date2) {\n      var months = (date1.getFullYear() - date2.getFullYear()) * 12;\n      return months - date2.getMonth() + date1.getMonth();\n    }\n  }, {\n    key: \"_differenceInYears\",\n    value: function _differenceInYears(date1, date2) {\n      return this._differenceInMonths(date1, date2) / 12;\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      this.selectedDate = '';\n    }\n  }, {\n    key: \"_close\",\n    value: function _close() {\n      var overlayContent = this.getRootNode().host;\n      var overlay = overlayContent ? overlayContent.getRootNode().host : null;\n\n      if (overlay) {\n        overlay.opened = false;\n      }\n\n      this.dispatchEvent(new CustomEvent('close', {\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }, {\n    key: \"_cancel\",\n    value: function _cancel() {\n      this.focusedDate = this.selectedDate;\n\n      this._close();\n    }\n  }, {\n    key: \"_preventDefault\",\n    value: function _preventDefault(e) {\n      e.preventDefault();\n    }\n    /**\n     * Keyboard Navigation\n     */\n\n  }, {\n    key: \"_eventKey\",\n    value: function _eventKey(e) {\n      var keys = ['down', 'up', 'right', 'left', 'enter', 'space', 'home', 'end', 'pageup', 'pagedown', 'tab', 'esc'];\n\n      for (var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n\n        if (IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k)) {\n          return k;\n        }\n      }\n    }\n  }, {\n    key: \"_onKeydown\",\n    value: function _onKeydown(e) {\n      var _this4 = this;\n\n      var focus = this._currentlyFocusedDate(); // Cannot use (today/cancel).focused flag because vaadin-text-field removes it\n      // previously in the keydown event.\n\n\n      var isToday = e.composedPath().indexOf(this.$.todayButton) >= 0;\n      var isCancel = e.composedPath().indexOf(this.$.cancelButton) >= 0;\n      var isScroller = !isToday && !isCancel;\n\n      var eventKey = this._eventKey(e);\n\n      if (eventKey === 'tab') {\n        // We handle tabs here and don't want to bubble up.\n        e.stopPropagation();\n        var isFullscreen = this.hasAttribute('fullscreen');\n        var isShift = e.shiftKey;\n\n        if (isFullscreen) {\n          e.preventDefault();\n        } else if (isShift && isScroller || !isShift && isCancel) {\n          // Return focus back to the input field\n          e.preventDefault();\n          this.dispatchEvent(new CustomEvent('focus-input', {\n            bubbles: true,\n            composed: true\n          }));\n        } else if (isShift && isToday) {\n          // Browser returns focus back to the scrollable area. We need to set\n          // the focused flag, and move the scroll to focused date.\n          this._focused = true;\n          setTimeout(function () {\n            return _this4.revealDate(_this4.focusedDate);\n          }, 1);\n        } else {\n          // Browser moves the focus out of the scroller, hence focused flag must\n          // set to false.\n          this._focused = false;\n        }\n      } else if (eventKey) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        switch (eventKey) {\n          case 'down':\n            this._moveFocusByDays(7);\n\n            this.focus();\n            break;\n\n          case 'up':\n            this._moveFocusByDays(-7);\n\n            this.focus();\n            break;\n\n          case 'right':\n            if (isScroller) {\n              this._moveFocusByDays(1);\n            }\n\n            break;\n\n          case 'left':\n            if (isScroller) {\n              this._moveFocusByDays(-1);\n            }\n\n            break;\n\n          case 'enter':\n            if (isScroller || isCancel) {\n              this._close();\n            } else if (isToday) {\n              this._onTodayTap();\n            }\n\n            break;\n\n          case 'space':\n            if (isCancel) {\n              this._close();\n            } else if (isToday) {\n              this._onTodayTap();\n            } else {\n              var focusedDate = this.focusedDate;\n\n              if (DatePickerHelper._dateEquals(focusedDate, this.selectedDate)) {\n                this.selectedDate = '';\n                this.focusedDate = focusedDate;\n              } else {\n                this.selectedDate = focusedDate;\n              }\n            }\n\n            break;\n\n          case 'home':\n            this._moveFocusInsideMonth(focus, 'minDate');\n\n            break;\n\n          case 'end':\n            this._moveFocusInsideMonth(focus, 'maxDate');\n\n            break;\n\n          case 'pagedown':\n            this._moveFocusByMonths(e.shiftKey ? 12 : 1);\n\n            break;\n\n          case 'pageup':\n            this._moveFocusByMonths(e.shiftKey ? -12 : -1);\n\n            break;\n\n          case 'esc':\n            this._cancel();\n\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"_currentlyFocusedDate\",\n    value: function _currentlyFocusedDate() {\n      return this.focusedDate || this.selectedDate || this.initialPosition || new Date();\n    }\n  }, {\n    key: \"_focusDate\",\n    value: function _focusDate(dateToFocus) {\n      this.focusedDate = dateToFocus;\n      this._focusedMonthDate = dateToFocus.getDate();\n    }\n  }, {\n    key: \"_focusClosestDate\",\n    value: function _focusClosestDate(focus) {\n      this._focusDate(DatePickerHelper._getClosestDate(focus, [this.minDate, this.maxDate]));\n    }\n  }, {\n    key: \"_moveFocusByDays\",\n    value: function _moveFocusByDays(days) {\n      var focus = this._currentlyFocusedDate();\n\n      var dateToFocus = new Date(0, 0);\n      dateToFocus.setFullYear(focus.getFullYear());\n      dateToFocus.setMonth(focus.getMonth());\n      dateToFocus.setDate(focus.getDate() + days);\n\n      if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {\n        this._focusDate(dateToFocus);\n      } else {\n        if (this._dateAllowed(focus, this.minDate, this.maxDate)) {\n          // Move to min or max date\n          if (days > 0) {\n            // down or right\n            this._focusDate(this.maxDate);\n          } else {\n            // up or left\n            this._focusDate(this.minDate);\n          }\n        } else {\n          // Move to closest allowed date\n          this._focusClosestDate(focus);\n        }\n      }\n    }\n  }, {\n    key: \"_moveFocusByMonths\",\n    value: function _moveFocusByMonths(months) {\n      var focus = this._currentlyFocusedDate();\n\n      var dateToFocus = new Date(0, 0);\n      dateToFocus.setFullYear(focus.getFullYear());\n      dateToFocus.setMonth(focus.getMonth() + months);\n      var targetMonth = dateToFocus.getMonth();\n      dateToFocus.setDate(this._focusedMonthDate || (this._focusedMonthDate = focus.getDate()));\n\n      if (dateToFocus.getMonth() !== targetMonth) {\n        dateToFocus.setDate(0);\n      }\n\n      if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {\n        this.focusedDate = dateToFocus;\n      } else {\n        if (this._dateAllowed(focus, this.minDate, this.maxDate)) {\n          // Move to min or max date\n          if (months > 0) {\n            // pagedown\n            this._focusDate(this.maxDate);\n          } else {\n            // pageup\n            this._focusDate(this.minDate);\n          }\n        } else {\n          // Move to closest allowed date\n          this._focusClosestDate(focus);\n        }\n      }\n    }\n  }, {\n    key: \"_moveFocusInsideMonth\",\n    value: function _moveFocusInsideMonth(focusedDate, property) {\n      var dateToFocus = new Date(0, 0);\n      dateToFocus.setFullYear(focusedDate.getFullYear());\n\n      if (property === 'minDate') {\n        dateToFocus.setMonth(focusedDate.getMonth());\n        dateToFocus.setDate(1);\n      } else {\n        dateToFocus.setMonth(focusedDate.getMonth() + 1);\n        dateToFocus.setDate(0);\n      }\n\n      if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {\n        this._focusDate(dateToFocus);\n      } else {\n        if (this._dateAllowed(focusedDate, this.minDate, this.maxDate)) {\n          // Move to minDate or maxDate\n          this._focusDate(this[property]);\n        } else {\n          // Move to closest allowed date\n          this._focusClosestDate(focusedDate);\n        }\n      }\n    }\n  }, {\n    key: \"_dateAllowed\",\n    value: function _dateAllowed(date, min, max) {\n      return (!min || date >= min) && (!max || date <= max);\n    }\n  }, {\n    key: \"_isTodayAllowed\",\n    value: function _isTodayAllowed(min, max) {\n      var today = new Date();\n      var todayMidnight = new Date(0, 0);\n      todayMidnight.setFullYear(today.getFullYear());\n      todayMidnight.setMonth(today.getMonth());\n      todayMidnight.setDate(today.getDate());\n      return this._dateAllowed(todayMidnight, min, max);\n    }\n  }, {\n    key: \"_stopPropagation\",\n    value: function _stopPropagation(e) {\n      e.stopPropagation();\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-date-picker-overlay-content';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * The value for this element.\n         */\n        selectedDate: {\n          type: Date,\n          notify: true\n        },\n\n        /**\n         * Date value which is focused using keyboard.\n         */\n        focusedDate: {\n          type: Date,\n          notify: true,\n          observer: '_focusedDateChanged'\n        },\n        _focusedMonthDate: Number,\n\n        /**\n         * Date which should be visible when there is no value selected.\n         */\n        initialPosition: {\n          type: Date,\n          observer: '_initialPositionChanged'\n        },\n        _originDate: {\n          value: new Date()\n        },\n        _visibleMonthIndex: Number,\n        _desktopMode: Boolean,\n        _translateX: {\n          observer: '_translateXChanged'\n        },\n        _yearScrollerWidth: {\n          value: 50\n        },\n        i18n: {\n          type: Object\n        },\n        showWeekNumbers: {\n          type: Boolean\n        },\n        _ignoreTaps: Boolean,\n        _notTapping: Boolean,\n\n        /**\n         * The earliest date that can be selected. All earlier dates will be disabled.\n         */\n        minDate: Date,\n\n        /**\n         * The latest date that can be selected. All later dates will be disabled.\n         */\n        maxDate: Date,\n        _focused: Boolean,\n\n        /**\n         * Input label\n         */\n        label: String\n      };\n    }\n  }]);\n\n  return DatePickerOverlayContentElement;\n}(ThemableMixin(ThemePropertyMixin(GestureEventListeners(PolymerElement))));\n\ncustomElements.define(DatePickerOverlayContentElement.is, DatePickerOverlayContentElement);","map":null,"metadata":{},"sourceType":"module"}