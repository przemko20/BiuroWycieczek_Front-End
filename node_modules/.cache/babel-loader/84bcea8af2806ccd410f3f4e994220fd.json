{"ast":null,"code":"import _taggedTemplateLiteral from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/taggedTemplateLiteral\";\nimport _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: block;\\n        overflow: hidden;\\n        height: 500px;\\n      }\\n\\n      #scroller {\\n        position: relative;\\n        height: 100%;\\n        overflow: auto;\\n        outline: none;\\n        margin-right: -40px;\\n        -webkit-overflow-scrolling: touch;\\n        -ms-overflow-style: none;\\n        overflow-x: hidden;\\n      }\\n\\n      #scroller.notouchscroll {\\n        -webkit-overflow-scrolling: auto;\\n      }\\n\\n      #scroller::-webkit-scrollbar {\\n        display: none;\\n      }\\n\\n      .buffer {\\n        position: absolute;\\n        width: var(--vaadin-infinite-scroller-buffer-width, 100%);\\n        box-sizing: border-box;\\n        padding-right: 40px;\\n        top: var(--vaadin-infinite-scroller-buffer-offset, 0);\\n        animation: fadein 0.2s;\\n      }\\n\\n      @keyframes fadein {\\n        from { opacity: 0; }\\n        to { opacity: 1; }\\n      }\\n    </style>\\n\\n    <div id=\\\"scroller\\\" on-scroll=\\\"_scroll\\\">\\n      <div class=\\\"buffer\\\"></div>\\n      <div class=\\\"buffer\\\"></div>\\n      <div id=\\\"fullHeight\\\"></div>\\n    </div>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { flush } from '@polymer/polymer/lib/utils/flush.js';\nimport { templatize } from '@polymer/polymer/lib/utils/templatize.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\n/**\n * @memberof Vaadin\n * @private\n */\n\nvar InfiniteScrollerElement =\n/*#__PURE__*/\nfunction (_PolymerElement) {\n  _inherits(InfiniteScrollerElement, _PolymerElement);\n\n  function InfiniteScrollerElement() {\n    _classCallCheck(this, InfiniteScrollerElement);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(InfiniteScrollerElement).apply(this, arguments));\n  }\n\n  _createClass(InfiniteScrollerElement, [{\n    key: \"ready\",\n    value: function ready() {\n      _get(_getPrototypeOf(InfiniteScrollerElement.prototype), \"ready\", this).call(this);\n\n      this._buffers = Array.prototype.slice.call(this.root.querySelectorAll('.buffer'));\n      this.$.fullHeight.style.height = this._initialScroll * 2 + 'px';\n      var tpl = this.querySelector('template');\n      this._TemplateClass = templatize(tpl, this, {\n        forwardHostProp: function forwardHostProp(prop, value) {\n          if (prop !== 'index') {\n            this._buffers.forEach(function (buffer) {\n              [].forEach.call(buffer.children, function (insertionPoint) {\n                insertionPoint._itemWrapper.instance[prop] = value;\n              });\n            });\n          }\n        }\n      }); // Firefox interprets elements with overflow:auto as focusable\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1069739\n\n      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\n      if (isFirefox) {\n        this.$.scroller.tabIndex = -1;\n      }\n    }\n  }, {\n    key: \"_activated\",\n    value: function _activated(active) {\n      if (active && !this._initialized) {\n        this._createPool();\n\n        this._initialized = true;\n      }\n    }\n  }, {\n    key: \"_finishInit\",\n    value: function _finishInit() {\n      var _this = this;\n\n      if (!this._initDone) {\n        // Once the first set of items start fading in, stamp the rest\n        this._buffers.forEach(function (buffer) {\n          [].forEach.call(buffer.children, function (insertionPoint) {\n            return _this._ensureStampedInstance(insertionPoint._itemWrapper);\n          });\n        }, this);\n\n        if (!this._buffers[0].translateY) {\n          this._reset();\n        }\n\n        this._initDone = true;\n      }\n    }\n  }, {\n    key: \"_translateBuffer\",\n    value: function _translateBuffer(up) {\n      var index = up ? 1 : 0;\n      this._buffers[index].translateY = this._buffers[index ? 0 : 1].translateY + this._bufferHeight * (index ? -1 : 1);\n      this._buffers[index].style.transform = 'translate3d(0, ' + this._buffers[index].translateY + 'px, 0)';\n      this._buffers[index].updated = false;\n\n      this._buffers.reverse();\n    }\n  }, {\n    key: \"_scroll\",\n    value: function _scroll() {\n      var _this2 = this;\n\n      if (this._scrollDisabled) {\n        return;\n      }\n\n      var scrollTop = this.$.scroller.scrollTop;\n\n      if (scrollTop < this._bufferHeight || scrollTop > this._initialScroll * 2 - this._bufferHeight) {\n        // Scrolled near the end/beginning of the scrollable area -> reset.\n        this._initialIndex = ~~this.position;\n\n        this._reset();\n      } // Check if we scrolled enough to translate the buffer positions.\n\n\n      var bufferOffset = this.root.querySelector('.buffer').offsetTop;\n      var upperThresholdReached = scrollTop > this._buffers[1].translateY + this.itemHeight + bufferOffset;\n      var lowerThresholdReached = scrollTop < this._buffers[0].translateY + this.itemHeight + bufferOffset;\n\n      if (upperThresholdReached || lowerThresholdReached) {\n        this._translateBuffer(lowerThresholdReached);\n\n        this._updateClones();\n      }\n\n      if (!this._preventScrollEvent) {\n        this.dispatchEvent(new CustomEvent('custom-scroll', {\n          bubbles: false,\n          composed: true\n        }));\n        this._mayHaveMomentum = true;\n      }\n\n      this._preventScrollEvent = false;\n      this._debouncerScrollFinish = Debouncer.debounce(this._debouncerScrollFinish, timeOut.after(200), function () {\n        var scrollerRect = _this2.$.scroller.getBoundingClientRect();\n\n        if (!_this2._isVisible(_this2._buffers[0], scrollerRect) && !_this2._isVisible(_this2._buffers[1], scrollerRect)) {\n          _this2.position = _this2.position;\n        }\n      });\n    }\n    /**\n     * Current scroller position as index. Can be a fractional number.\n     *\n     * @type {Number}\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      var _this3 = this;\n\n      this._scrollDisabled = true;\n      this.$.scroller.scrollTop = this._initialScroll;\n      this._buffers[0].translateY = this._initialScroll - this._bufferHeight;\n      this._buffers[1].translateY = this._initialScroll;\n\n      this._buffers.forEach(function (buffer) {\n        buffer.style.transform = 'translate3d(0, ' + buffer.translateY + 'px, 0)';\n      });\n\n      this._buffers[0].updated = this._buffers[1].updated = false;\n\n      this._updateClones(true);\n\n      this._debouncerUpdateClones = Debouncer.debounce(this._debouncerUpdateClones, timeOut.after(200), function () {\n        _this3._buffers[0].updated = _this3._buffers[1].updated = false;\n\n        _this3._updateClones();\n      });\n      this._scrollDisabled = false;\n    }\n  }, {\n    key: \"_createPool\",\n    value: function _createPool() {\n      var _this4 = this;\n\n      var container = this.getBoundingClientRect();\n\n      this._buffers.forEach(function (buffer) {\n        var _loop = function _loop() {\n          var itemWrapper = document.createElement('div');\n          itemWrapper.style.height = _this4.itemHeight + 'px';\n          itemWrapper.instance = {};\n          var contentId = InfiniteScrollerElement._contentIndex = InfiniteScrollerElement._contentIndex + 1 || 0;\n          var slotName = 'vaadin-infinite-scroller-item-content-' + contentId;\n          var insertionPoint = document.createElement('slot');\n          insertionPoint.setAttribute('name', slotName);\n          insertionPoint._itemWrapper = itemWrapper;\n          buffer.appendChild(insertionPoint);\n          itemWrapper.setAttribute('slot', slotName);\n\n          _this4.appendChild(itemWrapper); // This is needed by IE\n\n\n          flush();\n          setTimeout(function () {\n            // Only stamp the visible instances first\n            if (_this4._isVisible(itemWrapper, container)) {\n              _this4._ensureStampedInstance(itemWrapper);\n            }\n          }, 1); // Wait for first reset\n        };\n\n        for (var i = 0; i < _this4.bufferSize; i++) {\n          _loop();\n        }\n      }, this);\n\n      setTimeout(function () {\n        afterNextRender(_this4, _this4._finishInit.bind(_this4));\n      }, 1);\n    }\n  }, {\n    key: \"_ensureStampedInstance\",\n    value: function _ensureStampedInstance(itemWrapper) {\n      if (itemWrapper.firstElementChild) {\n        return;\n      }\n\n      var tmpInstance = itemWrapper.instance;\n      itemWrapper.instance = new this._TemplateClass({});\n      itemWrapper.appendChild(itemWrapper.instance.root);\n      Object.keys(tmpInstance).forEach(function (prop) {\n        itemWrapper.instance.set(prop, tmpInstance[prop]);\n      });\n    }\n  }, {\n    key: \"_updateClones\",\n    value: function _updateClones(viewPortOnly) {\n      var _this5 = this;\n\n      this._firstIndex = ~~((this._buffers[0].translateY - this._initialScroll) / this.itemHeight) + this._initialIndex;\n      var scrollerRect = viewPortOnly ? this.$.scroller.getBoundingClientRect() : undefined;\n\n      this._buffers.forEach(function (buffer, bufferIndex) {\n        if (!buffer.updated) {\n          var firstIndex = _this5._firstIndex + _this5.bufferSize * bufferIndex;\n          [].forEach.call(buffer.children, function (insertionPoint, index) {\n            var itemWrapper = insertionPoint._itemWrapper;\n\n            if (!viewPortOnly || _this5._isVisible(itemWrapper, scrollerRect)) {\n              itemWrapper.instance.index = firstIndex + index;\n            }\n          });\n          buffer.updated = true;\n        }\n      }, this);\n    }\n  }, {\n    key: \"_isVisible\",\n    value: function _isVisible(element, container) {\n      var rect = element.getBoundingClientRect();\n      return rect.bottom > container.top && rect.top < container.bottom;\n    }\n  }, {\n    key: \"position\",\n    set: function set(index) {\n      var _this6 = this;\n\n      this._preventScrollEvent = true;\n\n      if (index > this._firstIndex && index < this._firstIndex + this.bufferSize * 2) {\n        this.$.scroller.scrollTop = this.itemHeight * (index - this._firstIndex) + this._buffers[0].translateY;\n      } else {\n        this._initialIndex = ~~index;\n\n        this._reset();\n\n        this._scrollDisabled = true;\n        this.$.scroller.scrollTop += index % 1 * this.itemHeight;\n        this._scrollDisabled = false;\n      }\n\n      if (this._mayHaveMomentum) {\n        // Stop the possible iOS Safari momentum with -webkit-overflow-scrolling: auto;\n        this.$.scroller.classList.add('notouchscroll');\n        this._mayHaveMomentum = false;\n        setTimeout(function () {\n          // Restore -webkit-overflow-scrolling: touch; after a small delay.\n          _this6.$.scroller.classList.remove('notouchscroll');\n        }, 10);\n      }\n    }\n    /**\n     * @private\n     */\n    ,\n    get: function get() {\n      return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;\n    }\n  }, {\n    key: \"itemHeight\",\n    get: function get() {\n      if (!this._itemHeightVal) {\n        var itemHeight = window.ShadyCSS ? window.ShadyCSS.getComputedStyleValue(this, '--vaadin-infinite-scroller-item-height') : getComputedStyle(this).getPropertyValue('--vaadin-infinite-scroller-item-height'); // Use background-position temp inline style for unit conversion\n\n        var tmpStyleProp = 'background-position';\n        this.$.fullHeight.style.setProperty(tmpStyleProp, itemHeight);\n        var itemHeightPx = getComputedStyle(this.$.fullHeight).getPropertyValue(tmpStyleProp);\n        this.$.fullHeight.style.removeProperty(tmpStyleProp);\n        this._itemHeightVal = parseFloat(itemHeightPx);\n      }\n\n      return this._itemHeightVal;\n    }\n  }, {\n    key: \"_bufferHeight\",\n    get: function get() {\n      return this.itemHeight * this.bufferSize;\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-infinite-scroller';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * Count of individual items in each buffer.\n         * The scroller has 2 buffers altogether so bufferSize of 20\n         * will result in 40 buffered DOM items in total.\n         * Changing after initialization not supported.\n         */\n        bufferSize: {\n          type: Number,\n          value: 20\n        },\n\n        /**\n         * The amount of initial scroll top. Needed in order for the\n         * user to be able to scroll backwards.\n         */\n        _initialScroll: {\n          value: 500000\n        },\n\n        /**\n         * The index/position mapped at _initialScroll point.\n         */\n        _initialIndex: {\n          value: 0\n        },\n        _buffers: Array,\n        _preventScrollEvent: Boolean,\n        _mayHaveMomentum: Boolean,\n        _initialized: Boolean,\n        active: {\n          type: Boolean,\n          observer: '_activated'\n        }\n      };\n    }\n  }]);\n\n  return InfiniteScrollerElement;\n}(PolymerElement);\n\ncustomElements.define(InfiniteScrollerElement.is, InfiniteScrollerElement);","map":null,"metadata":{},"sourceType":"module"}