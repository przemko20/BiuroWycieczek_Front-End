{"ast":null,"code":"import _taggedTemplateLiteral from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/taggedTemplateLiteral\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _wrapNativeSuper from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/wrapNativeSuper\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        z-index: 200;\\n        position: fixed;\\n\\n        /*\\n          Despite of what the names say, <vaadin-overlay> is just a container\\n          for position/sizing/alignment. The actual overlay is the overlay part.\\n        */\\n\\n        /*\\n          Default position constraints: the entire viewport. Note: themes can\\n          override this to introduce gaps between the overlay and the viewport.\\n        */\\n        top: 0;\\n        right: 0;\\n        bottom: var(--vaadin-overlay-viewport-bottom);\\n        left: 0;\\n\\n        /* Use flexbox alignment for the overlay part. */\\n        display: flex;\\n        flex-direction: column; /* makes dropdowns sizing easier */\\n        /* Align to center by default. */\\n        align-items: center;\\n        justify-content: center;\\n\\n        /* Allow centering when max-width/max-height applies. */\\n        margin: auto;\\n\\n        /* The host is not clickable, only the overlay part is. */\\n        pointer-events: none;\\n\\n        /* Remove tap highlight on touch devices. */\\n        -webkit-tap-highlight-color: transparent;\\n\\n        /* CSS API for host */\\n        --vaadin-overlay-viewport-bottom: 0;\\n      }\\n\\n      :host([hidden]),\\n      :host(:not([opened]):not([closing])) {\\n        display: none !important;\\n      }\\n\\n      [part=\\\"overlay\\\"] {\\n        -webkit-overflow-scrolling: touch;\\n        overflow: auto;\\n        pointer-events: auto;\\n\\n        /* Prevent overflowing the host in MSIE 11 */\\n        max-width: 100%;\\n        box-sizing: border-box;\\n\\n        -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */\\n      }\\n\\n      [part=\\\"backdrop\\\"] {\\n        z-index: -1;\\n        content: \\\"\\\";\\n        background: rgba(0, 0, 0, 0.5);\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        bottom: 0;\\n        right: 0;\\n        pointer-events: auto;\\n      }\\n    </style>\\n\\n    <div id=\\\"backdrop\\\" part=\\\"backdrop\\\" hidden$=\\\"{{!withBackdrop}}\\\"></div>\\n    <div part=\\\"overlay\\\" id=\\\"overlay\\\" tabindex=\\\"0\\\">\\n      <div part=\\\"content\\\" id=\\\"content\\\">\\n        <slot></slot>\\n      </div>\\n    </div>\\n\"], [\"\\n    <style>\\n      :host {\\n        z-index: 200;\\n        position: fixed;\\n\\n        /*\\n          Despite of what the names say, <vaadin-overlay> is just a container\\n          for position/sizing/alignment. The actual overlay is the overlay part.\\n        */\\n\\n        /*\\n          Default position constraints: the entire viewport. Note: themes can\\n          override this to introduce gaps between the overlay and the viewport.\\n        */\\n        top: 0;\\n        right: 0;\\n        bottom: var(--vaadin-overlay-viewport-bottom);\\n        left: 0;\\n\\n        /* Use flexbox alignment for the overlay part. */\\n        display: flex;\\n        flex-direction: column; /* makes dropdowns sizing easier */\\n        /* Align to center by default. */\\n        align-items: center;\\n        justify-content: center;\\n\\n        /* Allow centering when max-width/max-height applies. */\\n        margin: auto;\\n\\n        /* The host is not clickable, only the overlay part is. */\\n        pointer-events: none;\\n\\n        /* Remove tap highlight on touch devices. */\\n        -webkit-tap-highlight-color: transparent;\\n\\n        /* CSS API for host */\\n        --vaadin-overlay-viewport-bottom: 0;\\n      }\\n\\n      :host([hidden]),\\n      :host(:not([opened]):not([closing])) {\\n        display: none !important;\\n      }\\n\\n      [part=\\\"overlay\\\"] {\\n        -webkit-overflow-scrolling: touch;\\n        overflow: auto;\\n        pointer-events: auto;\\n\\n        /* Prevent overflowing the host in MSIE 11 */\\n        max-width: 100%;\\n        box-sizing: border-box;\\n\\n        -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */\\n      }\\n\\n      [part=\\\"backdrop\\\"] {\\n        z-index: -1;\\n        content: \\\"\\\";\\n        background: rgba(0, 0, 0, 0.5);\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        bottom: 0;\\n        right: 0;\\n        pointer-events: auto;\\n      }\\n    </style>\\n\\n    <div id=\\\"backdrop\\\" part=\\\"backdrop\\\" hidden\\\\$=\\\"{{!withBackdrop}}\\\"></div>\\n    <div part=\\\"overlay\\\" id=\\\"overlay\\\" tabindex=\\\"0\\\">\\n      <div part=\\\"content\\\" id=\\\"content\\\">\\n        <slot></slot>\\n      </div>\\n    </div>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { templatize } from '@polymer/polymer/lib/utils/templatize.js';\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { FocusablesHelper } from './vaadin-focusables-helper.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nvar overlayContentCounter = 0;\n\nvar createOverlayContent = function createOverlayContent(cssText) {\n  overlayContentCounter++;\n  var is = \"vaadin-overlay-content-\".concat(overlayContentCounter);\n  var styledTemplate = document.createElement('template');\n  var style = document.createElement('style');\n  style.textContent = ':host { display: block; }' + cssText;\n  styledTemplate.content.appendChild(style);\n\n  if (window.ShadyCSS) {\n    window.ShadyCSS.prepareTemplate(styledTemplate, is);\n  } // NOTE(platosha): Have to use an awkward IIFE returning class here\n  // to prevent this class from showing up in analysis.json & API docs.\n\n  /** @private */\n\n\n  var klass = function () {\n    return (\n      /*#__PURE__*/\n      function (_HTMLElement) {\n        _inherits(_class, _HTMLElement);\n\n        function _class() {\n          _classCallCheck(this, _class);\n\n          return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));\n        }\n\n        _createClass(_class, [{\n          key: \"connectedCallback\",\n          value: function connectedCallback() {\n            if (window.ShadyCSS) {\n              window.ShadyCSS.styleElement(this);\n            }\n\n            if (!this.shadowRoot) {\n              this.attachShadow({\n                mode: 'open'\n              });\n              this.shadowRoot.appendChild(document.importNode(styledTemplate.content, true));\n            }\n          }\n        }], [{\n          key: \"is\",\n          get: function get() {\n            return is;\n          }\n        }]);\n\n        return _class;\n      }(_wrapNativeSuper(HTMLElement))\n    );\n  }();\n\n  customElements.define(klass.is, klass);\n  return document.createElement(is);\n};\n/**\n *\n * `<vaadin-overlay>` is a Web Component for creating overlays. The content of the overlay\n * can be populated in two ways: imperatively by using renderer callback function and\n * declaratively by using Polymer's Templates.\n *\n * ### Rendering\n *\n * By default, the overlay uses the content provided by using the renderer callback function.\n *\n * The renderer function provides `root`, `owner`, `model` arguments when applicable.\n * Generate DOM content by using `model` object properties if needed, append it to the `root`\n * element and control the state of the host element by accessing `owner`. Before generating new\n * content, users are able to check if there is already content in `root` for reusing it.\n *\n * ```html\n * <vaadin-overlay id=\"overlay\"></vaadin-overlay>\n * ```\n * ```js\n * const overlay = document.querySelector('#overlay');\n * overlay.renderer = function(root) {\n *  root.textContent = \"Overlay content\";\n * };\n * ```\n *\n * Renderer is called on the opening of the overlay and each time the related model is updated.\n * DOM generated during the renderer call can be reused\n * in the next renderer call and will be provided with the `root` argument.\n * On first call it will be empty.\n *\n * **NOTE:** when the renderer property is defined, the `<template>` content is not used.\n *\n * ### Templating\n *\n * Alternatively, the content can be provided with Polymer Template.\n * Overlay finds the first child template and uses that in case renderer callback function\n * is not provided. You can also set a custom template using the `template` property.\n *\n * After the content from the template is stamped, the `content` property\n * points to the content container.\n *\n * The overlay provides `forwardHostProp` when calling\n * `Polymer.Templatize.templatize` for the template, so that the bindings\n * from the parent scope propagate to the content.  You can also pass\n * custom `instanceProps` object using the `instanceProps` property.\n *\n * ```html\n * <vaadin-overlay>\n *   <template>Overlay content</template>\n * </vaadin-overlay>\n * ```\n *\n * **NOTE:** when using `instanceProps`: because of the Polymer limitation,\n * every template can only be templatized once, so it is important\n * to set `instanceProps` before the `template` is assigned to the overlay.\n *\n * ### Styling\n *\n * To style the overlay content, use styles in the parent scope:\n *\n * - If the overlay is used in a component, then the component styles\n *   apply the overlay content.\n * - If the overlay is used in the global DOM scope, then global styles\n *   apply to the overlay content.\n *\n * See examples for styling the overlay content in the live demos.\n *\n * The following Shadow DOM parts are available for styling the overlay component itself:\n *\n * Part name  | Description\n * -----------|---------------------------------------------------------|\n * `backdrop` | Backdrop of the overlay\n * `overlay`  | Container for position/sizing/alignment of the content\n * `content`  | Content of the overlay\n *\n * The following state attributes are available for styling:\n *\n * Attribute | Description | Part\n * ---|---|---\n * `opening` | Applied just after the overlay is attached to the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n * `closing` | Applied just before the overlay is detached from the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n *\n * The following custom CSS properties are available for styling:\n *\n * Custom CSS property | Description | Default value\n * ---|---|---\n * `--vaadin-overlay-viewport-bottom` | Bottom offset of the visible viewport area | `0` or detected offset\n *\n * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @memberof Vaadin\n * @mixes Vaadin.ThemableMixin\n * @demo demo/index.html\n */\n\n\nvar OverlayElement =\n/*#__PURE__*/\nfunction (_ThemableMixin) {\n  _inherits(OverlayElement, _ThemableMixin);\n\n  _createClass(OverlayElement, null, [{\n    key: \"template\",\n    get: function get() {\n      return html(_templateObject());\n    }\n  }, {\n    key: \"is\",\n    get: function get() {\n      return 'vaadin-overlay';\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        opened: {\n          type: Boolean,\n          notify: true,\n          observer: '_openedChanged',\n          reflectToAttribute: true\n        },\n\n        /**\n         * Owner element passed with renderer function\n         */\n        owner: Element,\n\n        /**\n         * Custom function for rendering the content of the overlay.\n         * Receives three arguments:\n         *\n         * - `root` The root container DOM element. Append your content to it.\n         * - `owner` The host element of the renderer function.\n         * - `model` The object with the properties related with rendering.\n         */\n        renderer: Function,\n\n        /**\n         * The template of the overlay content.\n         */\n        template: {\n          type: Object,\n          notify: true\n        },\n\n        /**\n         * Optional argument for `Polymer.Templatize.templatize`.\n         */\n        instanceProps: {\n          type: Object\n        },\n\n        /**\n         * References the content container after the template is stamped.\n         */\n        content: {\n          type: Object,\n          notify: true\n        },\n        withBackdrop: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true\n        },\n\n        /**\n         * Object with properties that is passed to `renderer` function\n         */\n        model: Object,\n\n        /**\n         * When true the overlay won't disable the main content, showing\n         * it doesn’t change the functionality of the user interface.\n         */\n        modeless: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true,\n          observer: '_modelessChanged'\n        },\n\n        /**\n         * When set to true, the overlay is hidden. This also closes the overlay\n         * immediately in case there is a closing animation in progress.\n         */\n        hidden: {\n          type: Boolean,\n          reflectToAttribute: true,\n          observer: '_hiddenChanged'\n        },\n\n        /**\n         * When true move focus to the first focusable element in the overlay,\n         * or to the overlay if there are no focusable elements.\n         */\n        focusTrap: {\n          type: Boolean,\n          value: false\n        },\n\n        /**\n         * Set to true to enable restoring of focus when overlay is closed.\n         */\n        restoreFocusOnClose: {\n          type: Boolean,\n          value: false\n        },\n        _mouseDownInside: {\n          type: Boolean\n        },\n        _mouseUpInside: {\n          type: Boolean\n        },\n        _instance: {\n          type: Object\n        },\n        _originalContentPart: Object,\n        _contentNodes: Array,\n        _oldOwner: Element,\n        _oldModel: Object,\n        _oldTemplate: Object,\n        _oldInstanceProps: Object,\n        _oldRenderer: Object,\n        _oldOpened: Boolean\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['_templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened)'];\n    }\n  }]);\n\n  function OverlayElement() {\n    var _this;\n\n    _classCallCheck(this, OverlayElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OverlayElement).call(this));\n    _this._boundMouseDownListener = _this._mouseDownListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._boundMouseUpListener = _this._mouseUpListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._boundOutsideClickListener = _this._outsideClickListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._boundKeydownListener = _this._keydownListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._observer = new FlattenedNodesObserver(_assertThisInitialized(_assertThisInitialized(_this)), function (info) {\n      _this._setTemplateFromNodes(info.addedNodes);\n    }); // Listener for preventing closing of the paper-dialog and all components extending `iron-overlay-behavior`.\n\n    _this._boundIronOverlayCanceledListener = _this._ironOverlayCanceled.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {\n      _this._boundIosResizeListener = function () {\n        return _this._detectIosNavbar();\n      };\n    }\n\n    return _this;\n  }\n\n  _createClass(OverlayElement, [{\n    key: \"ready\",\n    value: function ready() {\n      _get(_getPrototypeOf(OverlayElement.prototype), \"ready\", this).call(this);\n\n      this._observer.flush(); // Need to add dummy click listeners to this and the backdrop or else\n      // the document click event listener (_outsideClickListener) may never\n      // get invoked on iOS Safari (reproducible in <vaadin-dialog>\n      // and <vaadin-context-menu>).\n\n\n      this.addEventListener('click', function () {});\n      this.$.backdrop.addEventListener('click', function () {});\n    }\n  }, {\n    key: \"_detectIosNavbar\",\n    value: function _detectIosNavbar() {\n      if (!this.opened) {\n        return;\n      }\n\n      var innerHeight = window.innerHeight;\n      var innerWidth = window.innerWidth;\n      var landscape = innerWidth > innerHeight;\n      var clientHeight = document.documentElement.clientHeight;\n\n      if (landscape && clientHeight > innerHeight) {\n        this.style.setProperty('--vaadin-overlay-viewport-bottom', clientHeight - innerHeight + 'px');\n      } else {\n        this.style.setProperty('--vaadin-overlay-viewport-bottom', '0');\n      }\n    }\n  }, {\n    key: \"_setTemplateFromNodes\",\n    value: function _setTemplateFromNodes(nodes) {\n      this.template = nodes.filter(function (node) {\n        return node.localName && node.localName === 'template';\n      })[0] || this.template;\n    }\n    /**\n     * @event vaadin-overlay-close\n     * fired before the `vaadin-overlay` will be closed. If canceled the closing of the overlay is canceled as well.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(sourceEvent) {\n      var evt = new CustomEvent('vaadin-overlay-close', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          sourceEvent: sourceEvent\n        }\n      });\n      this.dispatchEvent(evt);\n\n      if (!evt.defaultPrevented) {\n        this.opened = false;\n      }\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(OverlayElement.prototype), \"connectedCallback\", this).call(this);\n\n      if (this._boundIosResizeListener) {\n        this._detectIosNavbar();\n\n        window.addEventListener('resize', this._boundIosResizeListener);\n      }\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(OverlayElement.prototype), \"disconnectedCallback\", this).call(this);\n\n      this._boundIosResizeListener && window.removeEventListener('resize', this._boundIosResizeListener);\n    }\n  }, {\n    key: \"_ironOverlayCanceled\",\n    value: function _ironOverlayCanceled(event) {\n      event.preventDefault();\n    }\n  }, {\n    key: \"_mouseDownListener\",\n    value: function _mouseDownListener(event) {\n      this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n    }\n  }, {\n    key: \"_mouseUpListener\",\n    value: function _mouseUpListener(event) {\n      this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n    }\n    /**\n     * We need to listen on 'click' / 'tap' event and capture it and close the overlay before\n     * propagating the event to the listener in the button. Otherwise, if the clicked button would call\n     * open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4\n     *\n     * @event vaadin-overlay-outside-click\n     * fired before the `vaadin-overlay` will be closed on outside click. If canceled the closing of the overlay is canceled as well.\n     */\n\n  }, {\n    key: \"_outsideClickListener\",\n    value: function _outsideClickListener(event) {\n      if (event.composedPath().indexOf(this.$.overlay) !== -1 || this._mouseDownInside || this._mouseUpInside) {\n        this._mouseDownInside = false;\n        this._mouseUpInside = false;\n        return;\n      }\n\n      if (!this._last) {\n        return;\n      }\n\n      var evt = new CustomEvent('vaadin-overlay-outside-click', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          sourceEvent: event\n        }\n      });\n      this.dispatchEvent(evt);\n\n      if (this.opened && !evt.defaultPrevented) {\n        this.close(event);\n      }\n    }\n    /**\n     * @event vaadin-overlay-escape-press\n     * fired before the `vaadin-overlay` will be closed on ESC button press. If canceled the closing of the overlay is canceled as well.\n     */\n\n  }, {\n    key: \"_keydownListener\",\n    value: function _keydownListener(event) {\n      if (!this._last) {\n        return;\n      } // TAB\n\n\n      if (event.key === 'Tab' && this.focusTrap) {\n        // if only tab key is pressed, cycle forward, else cycle backwards.\n        this._cycleTab(event.shiftKey ? -1 : 1);\n\n        event.preventDefault(); // ESC\n      } else if (event.key === 'Escape' || event.key === 'Esc') {\n        var evt = new CustomEvent('vaadin-overlay-escape-press', {\n          bubbles: true,\n          cancelable: true,\n          detail: {\n            sourceEvent: event\n          }\n        });\n        this.dispatchEvent(evt);\n\n        if (this.opened && !evt.defaultPrevented) {\n          this.close(event);\n        }\n      }\n    }\n  }, {\n    key: \"_ensureTemplatized\",\n    value: function _ensureTemplatized() {\n      this._setTemplateFromNodes(Array.from(this.children));\n    }\n    /**\n     * @event vaadin-overlay-open\n     * fired after the `vaadin-overlay` is opened.\n     */\n\n  }, {\n    key: \"_openedChanged\",\n    value: function _openedChanged(opened, wasOpened) {\n      var _this2 = this;\n\n      if (!this._instance) {\n        this._ensureTemplatized();\n      }\n\n      if (opened) {\n        // Store focused node.\n        this.__restoreFocusNode = this._getActiveElement();\n\n        this._animatedOpening();\n\n        afterNextRender(this, function () {\n          if (_this2.focusTrap && !_this2.contains(document._activeElement || document.activeElement)) {\n            _this2._cycleTab(0, 0);\n          }\n\n          var evt = new CustomEvent('vaadin-overlay-open', {\n            bubbles: true\n          });\n\n          _this2.dispatchEvent(evt);\n        });\n\n        if (!this.modeless) {\n          this._enterModalState();\n        }\n      } else if (wasOpened) {\n        this._animatedClosing();\n\n        this._exitModalState();\n      }\n    }\n  }, {\n    key: \"_hiddenChanged\",\n    value: function _hiddenChanged(hidden) {\n      if (hidden && this.hasAttribute('closing')) {\n        this._flushAnimation('closing');\n      }\n    }\n  }, {\n    key: \"_shouldAnimate\",\n    value: function _shouldAnimate() {\n      var name = getComputedStyle(this).getPropertyValue('animation-name');\n      var hidden = getComputedStyle(this).getPropertyValue('display') === 'none';\n      return !hidden && name && name != 'none';\n    }\n  }, {\n    key: \"_enqueueAnimation\",\n    value: function _enqueueAnimation(type, callback) {\n      var _this3 = this;\n\n      var handler = \"__\".concat(type, \"Handler\");\n\n      var listener = function listener() {\n        callback();\n\n        _this3.removeEventListener('animationend', listener);\n\n        delete _this3[handler];\n      };\n\n      this[handler] = listener;\n      this.addEventListener('animationend', listener);\n    }\n  }, {\n    key: \"_flushAnimation\",\n    value: function _flushAnimation(type) {\n      var handler = \"__\".concat(type, \"Handler\");\n\n      if (typeof this[handler] === 'function') {\n        this[handler]();\n      }\n    }\n  }, {\n    key: \"_animatedOpening\",\n    value: function _animatedOpening() {\n      var _this4 = this;\n\n      if (this.parentNode === document.body && this.hasAttribute('closing')) {\n        this._flushAnimation('closing');\n      }\n\n      this._attachOverlay();\n\n      this.setAttribute('opening', '');\n\n      var finishOpening = function finishOpening() {\n        _this4.removeAttribute('opening');\n\n        document.addEventListener('iron-overlay-canceled', _this4._boundIronOverlayCanceledListener);\n      };\n\n      if (this._shouldAnimate()) {\n        this._enqueueAnimation('opening', finishOpening);\n      } else {\n        finishOpening();\n      }\n    }\n  }, {\n    key: \"_attachOverlay\",\n    value: function _attachOverlay() {\n      this._placeholder = document.createComment('vaadin-overlay-placeholder');\n      this.parentNode.insertBefore(this._placeholder, this);\n      document.body.appendChild(this);\n    }\n  }, {\n    key: \"_animatedClosing\",\n    value: function _animatedClosing() {\n      var _this5 = this;\n\n      if (this.hasAttribute('opening')) {\n        this._flushAnimation('opening');\n      }\n\n      if (this._placeholder) {\n        this.setAttribute('closing', '');\n\n        var finishClosing = function finishClosing() {\n          document.removeEventListener('iron-overlay-canceled', _this5._boundIronOverlayCanceledListener);\n\n          _this5._detachOverlay();\n\n          _this5.removeAttribute('closing');\n\n          if (_this5.restoreFocusOnClose && _this5.__restoreFocusNode) {\n            // If the activeElement is `<body>` or inside the overlay,\n            // we are allowed to restore the focus. In all the other\n            // cases focus might have been moved elsewhere by another\n            // component or by the user interaction (e.g. click on a\n            // button outside the overlay).\n            var activeElement = _this5._getActiveElement();\n\n            if (activeElement === document.body || _this5._deepContains(activeElement)) {\n              _this5.__restoreFocusNode.focus();\n            }\n\n            _this5.__restoreFocusNode = null;\n          }\n        };\n\n        if (this._shouldAnimate()) {\n          this._enqueueAnimation('closing', finishClosing);\n        } else {\n          finishClosing();\n        }\n      }\n    }\n  }, {\n    key: \"_detachOverlay\",\n    value: function _detachOverlay() {\n      this._placeholder.parentNode.insertBefore(this, this._placeholder);\n\n      this._placeholder.parentNode.removeChild(this._placeholder);\n    }\n    /**\n     * Returns all attached overlays.\n     */\n\n  }, {\n    key: \"_modelessChanged\",\n    value: function _modelessChanged(modeless) {\n      if (!modeless) {\n        if (this.opened) {\n          this._enterModalState();\n        }\n      } else {\n        this._exitModalState();\n      }\n    }\n  }, {\n    key: \"_enterModalState\",\n    value: function _enterModalState() {\n      var _this6 = this;\n\n      document.addEventListener('mousedown', this._boundMouseDownListener);\n      document.addEventListener('mouseup', this._boundMouseUpListener);\n      document.addEventListener('click', this._boundOutsideClickListener, true);\n      document.addEventListener('keydown', this._boundKeydownListener);\n\n      if (document.body.style.pointerEvents !== 'none') {\n        // Set body pointer-events to 'none' to disable mouse interactions with\n        // other document nodes.\n        this._previousDocumentPointerEvents = document.body.style.pointerEvents;\n        document.body.style.pointerEvents = 'none';\n      } // Disable pointer events in other attached overlays\n\n\n      OverlayElement.__attachedInstances.forEach(function (el) {\n        if (el !== _this6) {\n          el.shadowRoot.querySelector('[part=\"overlay\"]').style.pointerEvents = 'none';\n        }\n      });\n    }\n  }, {\n    key: \"_exitModalState\",\n    value: function _exitModalState() {\n      document.removeEventListener('mousedown', this._boundMouseDownListener);\n      document.removeEventListener('mouseup', this._boundMouseUpListener);\n      document.removeEventListener('click', this._boundOutsideClickListener, true);\n      document.removeEventListener('keydown', this._boundKeydownListener);\n\n      if (this._previousDocumentPointerEvents !== undefined) {\n        // Restore body pointer-events\n        document.body.style.pointerEvents = this._previousDocumentPointerEvents;\n        delete this._previousDocumentPointerEvents;\n      } // Restore pointer events in the previous overlay(s)\n\n\n      var instances = OverlayElement.__attachedInstances;\n      var el; // Use instances.pop() to ensure the reverse order\n\n      while (el = instances.pop()) {\n        if (el === this) {\n          // Skip the current instance\n          continue;\n        }\n\n        el.shadowRoot.querySelector('[part=\"overlay\"]').style.removeProperty('pointer-events');\n\n        if (!el.modeless) {\n          // Stop after the last modal\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_removeOldContent\",\n    value: function _removeOldContent() {\n      var _this7 = this;\n\n      if (!this.content || !this._contentNodes) {\n        return;\n      }\n\n      this._observer.disconnect();\n\n      this._contentNodes.forEach(function (node) {\n        if (node.parentNode === _this7.content) {\n          _this7.content.removeChild(node);\n        }\n      });\n\n      if (this._originalContentPart) {\n        // Restore the original <div part=\"content\">\n        this.$.content.parentNode.replaceChild(this._originalContentPart, this.$.content);\n        this.$.content = this._originalContentPart;\n        this._originalContentPart = undefined;\n      }\n\n      this._observer.connect();\n\n      this._contentNodes = undefined;\n      this.content = undefined;\n    }\n  }, {\n    key: \"_stampOverlayTemplate\",\n    value: function _stampOverlayTemplate(template, instanceProps) {\n      this._removeOldContent();\n\n      if (!template._Templatizer) {\n        template._Templatizer = templatize(template, this, {\n          instanceProps: instanceProps,\n          forwardHostProp: function forwardHostProp(prop, value) {\n            if (this._instance) {\n              this._instance.forwardHostProp(prop, value);\n            }\n          }\n        });\n      }\n\n      this._instance = new template._Templatizer({});\n      this._contentNodes = Array.from(this._instance.root.childNodes);\n      var templateRoot = template._templateRoot || (template._templateRoot = template.getRootNode());\n\n      var _isScoped = templateRoot !== document;\n\n      if (_isScoped) {\n        if (!this.$.content.shadowRoot) {\n          this.$.content.attachShadow({\n            mode: 'open'\n          });\n        }\n\n        var scopeCssText = Array.from(templateRoot.querySelectorAll('style')).reduce(function (result, style) {\n          return result + style.textContent;\n        }, '');\n\n        if (window.ShadyCSS && !window.ShadyCSS.nativeShadow) {\n          // NOTE(platosha): ShadyCSS removes <style>’s from templates, so\n          // we have to use these protected APIs to get their contents back\n          var styleInfo = window.ShadyCSS.ScopingShim._styleInfoForNode(templateRoot.host);\n\n          if (styleInfo) {\n            scopeCssText += styleInfo._getStyleRules().parsedCssText;\n            scopeCssText += '}';\n          }\n        } // The overlay root’s :host styles should not apply inside the overlay\n\n\n        scopeCssText = scopeCssText.replace(/:host/g, ':host-nomatch');\n\n        if (scopeCssText) {\n          if (window.ShadyCSS && !window.ShadyCSS.nativeShadow) {\n            // ShadyDOM: replace the <div part=\"content\"> with a generated\n            // styled custom element\n            var contentPart = createOverlayContent(scopeCssText);\n            contentPart.id = 'content';\n            contentPart.setAttribute('part', 'content');\n            this.$.content.parentNode.replaceChild(contentPart, this.$.content); // NOTE(platosha): carry the style scope of the content part\n\n            contentPart.className = this.$.content.className;\n            this._originalContentPart = this.$.content;\n            this.$.content = contentPart;\n          } else {\n            // Shadow DOM: append a style to the content shadowRoot\n            var style = document.createElement('style');\n            style.textContent = scopeCssText;\n            this.$.content.shadowRoot.appendChild(style);\n\n            this._contentNodes.unshift(style);\n          }\n        }\n\n        this.$.content.shadowRoot.appendChild(this._instance.root);\n        this.content = this.$.content.shadowRoot;\n      } else {\n        this.appendChild(this._instance.root);\n        this.content = this;\n      }\n    }\n  }, {\n    key: \"_removeNewRendererOrTemplate\",\n    value: function _removeNewRendererOrTemplate(template, oldTemplate, renderer, oldRenderer) {\n      if (template !== oldTemplate) {\n        this.template = undefined;\n      } else if (renderer !== oldRenderer) {\n        this.renderer = undefined;\n      }\n    }\n    /**\n     * Manually invoke existing renderer.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.renderer) {\n        this.renderer.call(this.owner, this.content, this.owner, this.model);\n      }\n    }\n  }, {\n    key: \"_templateOrRendererChanged\",\n    value: function _templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened) {\n      if (template && renderer) {\n        this._removeNewRendererOrTemplate(template, this._oldTemplate, renderer, this._oldRenderer);\n\n        throw new Error('You should only use either a renderer or a template for overlay content');\n      }\n\n      var ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;\n      this._oldModel = model;\n      this._oldOwner = owner;\n      var templateOrInstancePropsChanged = this._oldInstanceProps !== instanceProps || this._oldTemplate !== template;\n      this._oldInstanceProps = instanceProps;\n      this._oldTemplate = template;\n      var rendererChanged = this._oldRenderer !== renderer;\n      this._oldRenderer = renderer;\n      var openedChanged = this._oldOpened !== opened;\n      this._oldOpened = opened;\n\n      if (template && templateOrInstancePropsChanged) {\n        this._stampOverlayTemplate(template, instanceProps);\n      } else if (renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {\n        this.content = this;\n\n        if (rendererChanged) {\n          while (this.content.firstChild) {\n            this.content.removeChild(this.content.firstChild);\n          }\n        }\n\n        if (opened) {\n          this.render();\n        }\n      }\n    }\n  }, {\n    key: \"_isFocused\",\n    value: function _isFocused(element) {\n      return element && element.getRootNode().activeElement === element;\n    }\n  }, {\n    key: \"_focusedIndex\",\n    value: function _focusedIndex(elements) {\n      elements = elements || this._getFocusableElements();\n      return elements.indexOf(elements.filter(this._isFocused).pop());\n    }\n  }, {\n    key: \"_cycleTab\",\n    value: function _cycleTab(increment, index) {\n      var focusableElements = this._getFocusableElements();\n\n      if (index === undefined) {\n        index = this._focusedIndex(focusableElements);\n      }\n\n      index += increment; // rollover to first item\n\n      if (index >= focusableElements.length) {\n        index = 0; // go to last item\n      } else if (index < 0) {\n        index = focusableElements.length - 1;\n      }\n\n      focusableElements[index].focus();\n    }\n  }, {\n    key: \"_getFocusableElements\",\n    value: function _getFocusableElements() {\n      // collect all focusable elements\n      return FocusablesHelper.getTabbableNodes(this.$.overlay);\n    }\n  }, {\n    key: \"_getActiveElement\",\n    value: function _getActiveElement() {\n      var active = document._activeElement || document.activeElement; // document.activeElement can be null\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n      // In IE 11, it can also be an object when operating in iframes\n      // or document.documentElement (when overlay closed on outside click).\n      // In these cases, default it to document.body.\n\n      if (!active || active === document.documentElement || active instanceof Element === false) {\n        active = document.body;\n      }\n\n      while (active.shadowRoot && active.shadowRoot.activeElement) {\n        active = active.shadowRoot.activeElement;\n      }\n\n      return active;\n    }\n  }, {\n    key: \"_deepContains\",\n    value: function _deepContains(node) {\n      if (this.contains(node)) {\n        return true;\n      }\n\n      var n = node;\n      var doc = node.ownerDocument; // walk from node to `this` or `document`\n\n      while (n && n !== doc && n !== this) {\n        n = n.parentNode || n.host;\n      }\n\n      return n === this;\n    }\n  }, {\n    key: \"_last\",\n\n    /**\n     * returns true if this is the last one in the opened overlays stack\n     */\n    get: function get() {\n      return this === OverlayElement.__attachedInstances.pop();\n    }\n  }], [{\n    key: \"__attachedInstances\",\n    get: function get() {\n      return Array.from(document.body.children).filter(function (el) {\n        return el instanceof OverlayElement;\n      });\n    }\n  }]);\n\n  return OverlayElement;\n}(ThemableMixin(PolymerElement));\n\ncustomElements.define(OverlayElement.is, OverlayElement);\nexport { OverlayElement };","map":null,"metadata":{},"sourceType":"module"}