{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { calculateSplices } from '../utils/array-splice.js';\nimport { ElementMixin } from '../mixins/element-mixin.js';\n/**\n * Element mixin for recording dynamic associations between item paths in a\n * master `items` array and a `selected` array such that path changes to the\n * master array (at the host) element or elsewhere via data-binding) are\n * correctly propagated to items in the selected array and vice-versa.\n *\n * The `items` property accepts an array of user data, and via the\n * `select(item)` and `deselect(item)` API, updates the `selected` property\n * which may be bound to other parts of the application, and any changes to\n * sub-fields of `selected` item(s) will be kept in sync with items in the\n * `items` array.  When `multi` is false, `selected` is a property\n * representing the last selected item.  When `multi` is true, `selected`\n * is an array of multiply selected items.\n *\n * @polymer\n * @mixinFunction\n * @appliesMixin ElementMixin\n * @summary Element mixin for recording dynamic associations between item paths in a\n * master `items` array and a `selected` array\n */\n\nvar ArraySelectorMixin = dedupingMixin(function (superClass) {\n  /**\n   * @constructor\n   * @extends {superClass}\n   * @implements {Polymer_ElementMixin}\n   * @private\n   */\n  var elementBase = ElementMixin(superClass);\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_ArraySelectorMixin}\n   * @unrestricted\n   */\n\n  var ArraySelectorMixin =\n  /*#__PURE__*/\n  function (_elementBase) {\n    _inherits(ArraySelectorMixin, _elementBase);\n\n    _createClass(ArraySelectorMixin, null, [{\n      key: \"properties\",\n      get: function get() {\n        return {\n          /**\n           * An array containing items from which selection will be made.\n           */\n          items: {\n            type: Array\n          },\n\n          /**\n           * When `true`, multiple items may be selected at once (in this case,\n           * `selected` is an array of currently selected items).  When `false`,\n           * only one item may be selected at a time.\n           */\n          multi: {\n            type: Boolean,\n            value: false\n          },\n\n          /**\n           * When `multi` is true, this is an array that contains any selected.\n           * When `multi` is false, this is the currently selected item, or `null`\n           * if no item is selected.\n           * @type {?(Object|Array<!Object>)}\n           */\n          selected: {\n            type: Object,\n            notify: true\n          },\n\n          /**\n           * When `multi` is false, this is the currently selected item, or `null`\n           * if no item is selected.\n           * @type {?Object}\n           */\n          selectedItem: {\n            type: Object,\n            notify: true\n          },\n\n          /**\n           * When `true`, calling `select` on an item that is already selected\n           * will deselect the item.\n           */\n          toggle: {\n            type: Boolean,\n            value: false\n          }\n        };\n      }\n    }, {\n      key: \"observers\",\n      get: function get() {\n        return ['__updateSelection(multi, items.*)'];\n      }\n    }]);\n\n    function ArraySelectorMixin() {\n      var _this;\n\n      _classCallCheck(this, ArraySelectorMixin);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ArraySelectorMixin).call(this));\n      _this.__lastItems = null;\n      _this.__lastMulti = null;\n      _this.__selectedMap = null;\n      return _this;\n    }\n\n    _createClass(ArraySelectorMixin, [{\n      key: \"__updateSelection\",\n      value: function __updateSelection(multi, itemsInfo) {\n        var path = itemsInfo.path;\n\n        if (path == 'items') {\n          // Case 1 - items array changed, so diff against previous array and\n          // deselect any removed items and adjust selected indices\n          var newItems = itemsInfo.base || [];\n          var lastItems = this.__lastItems;\n          var lastMulti = this.__lastMulti;\n\n          if (multi !== lastMulti) {\n            this.clearSelection();\n          }\n\n          if (lastItems) {\n            var splices = calculateSplices(newItems, lastItems);\n\n            this.__applySplices(splices);\n          }\n\n          this.__lastItems = newItems;\n          this.__lastMulti = multi;\n        } else if (itemsInfo.path == 'items.splices') {\n          // Case 2 - got specific splice information describing the array mutation:\n          // deselect any removed items and adjust selected indices\n          this.__applySplices(itemsInfo.value.indexSplices);\n        } else {\n          // Case 3 - an array element was changed, so deselect the previous\n          // item for that index if it was previously selected\n          var part = path.slice('items.'.length);\n          var idx = parseInt(part, 10);\n\n          if (part.indexOf('.') < 0 && part == idx) {\n            this.__deselectChangedIdx(idx);\n          }\n        }\n      }\n    }, {\n      key: \"__applySplices\",\n      value: function __applySplices(splices) {\n        var _this2 = this;\n\n        var selected = this.__selectedMap; // Adjust selected indices and mark removals\n\n        var _loop = function _loop(i) {\n          var s = splices[i];\n          selected.forEach(function (idx, item) {\n            if (idx < s.index) {// no change\n            } else if (idx >= s.index + s.removed.length) {\n              // adjust index\n              selected.set(item, idx + s.addedCount - s.removed.length);\n            } else {\n              // remove index\n              selected.set(item, -1);\n            }\n          });\n\n          for (var j = 0; j < s.addedCount; j++) {\n            var idx = s.index + j;\n\n            if (selected.has(_this2.items[idx])) {\n              selected.set(_this2.items[idx], idx);\n            }\n          }\n        };\n\n        for (var i = 0; i < splices.length; i++) {\n          _loop(i);\n        } // Update linked paths\n\n\n        this.__updateLinks(); // Remove selected items that were removed from the items array\n\n\n        var sidx = 0;\n        selected.forEach(function (idx, item) {\n          if (idx < 0) {\n            if (_this2.multi) {\n              _this2.splice('selected', sidx, 1);\n            } else {\n              _this2.selected = _this2.selectedItem = null;\n            }\n\n            selected.delete(item);\n          } else {\n            sidx++;\n          }\n        });\n      }\n    }, {\n      key: \"__updateLinks\",\n      value: function __updateLinks() {\n        var _this3 = this;\n\n        this.__dataLinkedPaths = {};\n\n        if (this.multi) {\n          var sidx = 0;\n\n          this.__selectedMap.forEach(function (idx) {\n            if (idx >= 0) {\n              _this3.linkPaths('items.' + idx, 'selected.' + sidx++);\n            }\n          });\n        } else {\n          this.__selectedMap.forEach(function (idx) {\n            _this3.linkPaths('selected', 'items.' + idx);\n\n            _this3.linkPaths('selectedItem', 'items.' + idx);\n          });\n        }\n      }\n      /**\n       * Clears the selection state.\n       * @return {void}\n       */\n\n    }, {\n      key: \"clearSelection\",\n      value: function clearSelection() {\n        // Unbind previous selection\n        this.__dataLinkedPaths = {}; // The selected map stores 3 pieces of information:\n        // key: items array object\n        // value: items array index\n        // order: selected array index\n\n        this.__selectedMap = new Map(); // Initialize selection\n\n        this.selected = this.multi ? [] : null;\n        this.selectedItem = null;\n      }\n      /**\n       * Returns whether the item is currently selected.\n       *\n       * @param {*} item Item from `items` array to test\n       * @return {boolean} Whether the item is selected\n       */\n\n    }, {\n      key: \"isSelected\",\n      value: function isSelected(item) {\n        return this.__selectedMap.has(item);\n      }\n      /**\n       * Returns whether the item is currently selected.\n       *\n       * @param {number} idx Index from `items` array to test\n       * @return {boolean} Whether the item is selected\n       */\n\n    }, {\n      key: \"isIndexSelected\",\n      value: function isIndexSelected(idx) {\n        return this.isSelected(this.items[idx]);\n      }\n    }, {\n      key: \"__deselectChangedIdx\",\n      value: function __deselectChangedIdx(idx) {\n        var _this4 = this;\n\n        var sidx = this.__selectedIndexForItemIndex(idx);\n\n        if (sidx >= 0) {\n          var i = 0;\n\n          this.__selectedMap.forEach(function (idx, item) {\n            if (sidx == i++) {\n              _this4.deselect(item);\n            }\n          });\n        }\n      }\n    }, {\n      key: \"__selectedIndexForItemIndex\",\n      value: function __selectedIndexForItemIndex(idx) {\n        var selected = this.__dataLinkedPaths['items.' + idx];\n\n        if (selected) {\n          return parseInt(selected.slice('selected.'.length), 10);\n        }\n      }\n      /**\n       * Deselects the given item if it is already selected.\n       *\n       * @param {*} item Item from `items` array to deselect\n       * @return {void}\n       */\n\n    }, {\n      key: \"deselect\",\n      value: function deselect(item) {\n        var idx = this.__selectedMap.get(item);\n\n        if (idx >= 0) {\n          this.__selectedMap.delete(item);\n\n          var sidx;\n\n          if (this.multi) {\n            sidx = this.__selectedIndexForItemIndex(idx);\n          }\n\n          this.__updateLinks();\n\n          if (this.multi) {\n            this.splice('selected', sidx, 1);\n          } else {\n            this.selected = this.selectedItem = null;\n          }\n        }\n      }\n      /**\n       * Deselects the given index if it is already selected.\n       *\n       * @param {number} idx Index from `items` array to deselect\n       * @return {void}\n       */\n\n    }, {\n      key: \"deselectIndex\",\n      value: function deselectIndex(idx) {\n        this.deselect(this.items[idx]);\n      }\n      /**\n       * Selects the given item.  When `toggle` is true, this will automatically\n       * deselect the item if already selected.\n       *\n       * @param {*} item Item from `items` array to select\n       * @return {void}\n       */\n\n    }, {\n      key: \"select\",\n      value: function select(item) {\n        this.selectIndex(this.items.indexOf(item));\n      }\n      /**\n       * Selects the given index.  When `toggle` is true, this will automatically\n       * deselect the item if already selected.\n       *\n       * @param {number} idx Index from `items` array to select\n       * @return {void}\n       */\n\n    }, {\n      key: \"selectIndex\",\n      value: function selectIndex(idx) {\n        var item = this.items[idx];\n\n        if (!this.isSelected(item)) {\n          if (!this.multi) {\n            this.__selectedMap.clear();\n          }\n\n          this.__selectedMap.set(item, idx);\n\n          this.__updateLinks();\n\n          if (this.multi) {\n            this.push('selected', item);\n          } else {\n            this.selected = this.selectedItem = item;\n          }\n        } else if (this.toggle) {\n          this.deselectIndex(idx);\n        }\n      }\n    }]);\n\n    return ArraySelectorMixin;\n  }(elementBase);\n\n  return ArraySelectorMixin;\n}); // export mixin\n\nexport { ArraySelectorMixin };\n/**\n * @constructor\n * @extends {PolymerElement}\n * @implements {Polymer_ArraySelectorMixin}\n * @private\n */\n\nvar baseArraySelector = ArraySelectorMixin(PolymerElement);\n/**\n * Element implementing the `ArraySelector` mixin, which records\n * dynamic associations between item paths in a master `items` array and a\n * `selected` array such that path changes to the master array (at the host)\n * element or elsewhere via data-binding) are correctly propagated to items\n * in the selected array and vice-versa.\n *\n * The `items` property accepts an array of user data, and via the\n * `select(item)` and `deselect(item)` API, updates the `selected` property\n * which may be bound to other parts of the application, and any changes to\n * sub-fields of `selected` item(s) will be kept in sync with items in the\n * `items` array.  When `multi` is false, `selected` is a property\n * representing the last selected item.  When `multi` is true, `selected`\n * is an array of multiply selected items.\n *\n * Example:\n *\n * ```js\n * import {PolymerElement} from '@polymer/polymer';\n * import '@polymer/polymer/lib/elements/array-selector.js';\n *\n * class EmployeeList extends PolymerElement {\n *   static get _template() {\n *     return html`\n *         <div> Employee list: </div>\n *         <dom-repeat id=\"employeeList\" items=\"{{employees}}\">\n *           <template>\n *             <div>First name: <span>{{item.first}}</span></div>\n *               <div>Last name: <span>{{item.last}}</span></div>\n *               <button on-click=\"toggleSelection\">Select</button>\n *           </template>\n *         </dom-repeat>\n *\n *         <array-selector id=\"selector\"\n *                         items=\"{{employees}}\"\n *                         selected=\"{{selected}}\"\n *                         multi toggle></array-selector>\n *\n *         <div> Selected employees: </div>\n *         <dom-repeat items=\"{{selected}}\">\n *           <template>\n *             <div>First name: <span>{{item.first}}</span></div>\n *             <div>Last name: <span>{{item.last}}</span></div>\n *           </template>\n *         </dom-repeat>`;\n *   }\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n *   toggleSelection(e) {\n *     const item = this.$.employeeList.itemForElement(e.target);\n *     this.$.selector.select(item);\n *   }\n * }\n * ```\n *\n * @polymer\n * @customElement\n * @extends {baseArraySelector}\n * @appliesMixin ArraySelectorMixin\n * @summary Custom element that links paths between an input `items` array and\n *   an output `selected` item or array based on calls to its selection API.\n */\n\nvar ArraySelector =\n/*#__PURE__*/\nfunction (_baseArraySelector) {\n  _inherits(ArraySelector, _baseArraySelector);\n\n  function ArraySelector() {\n    _classCallCheck(this, ArraySelector);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ArraySelector).apply(this, arguments));\n  }\n\n  _createClass(ArraySelector, null, [{\n    key: \"is\",\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    get: function get() {\n      return 'array-selector';\n    }\n  }]);\n\n  return ArraySelector;\n}(baseArraySelector);\n\ncustomElements.define(ArraySelector.is, ArraySelector);\nexport { ArraySelector };","map":null,"metadata":{},"sourceType":"module"}