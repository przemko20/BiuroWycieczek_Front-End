{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { root, isAncestor, isDescendant, get as _get2, translate, isPath, set as _set, normalize } from '../utils/path.js';\n/* for notify, reflect */\n\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertyAccessors } from './property-accessors.js';\n/* for annotated effects */\n\nimport { TemplateStamp } from './template-stamp.js';\nimport { sanitizeDOMValue } from '../utils/settings.js'; // Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\n\nvar dedupeId = 0;\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\n\nvar TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\n/** @const {RegExp} */\n\nvar capitalAttributeRegex = /[A-Z]/;\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\n\nvar DataTrigger; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\n\nvar DataEffect; //eslint-disable-line no-unused-vars\n\nvar PropertyEffectsType; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\n\nfunction ensureOwnEffectMap(model, type) {\n  var effects = model[type];\n\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n\n    for (var p in effects) {\n      var protoFx = effects[p];\n      var instFx = effects[p] = Array(protoFx.length);\n\n      for (var i = 0; i < protoFx.length; i++) {\n        instFx[i] = protoFx[i];\n      }\n    }\n  }\n\n  return effects;\n} // -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!PropertyEffectsType} inst The instance with effects to run\n * @param {Object} effects Object map of property-to-Array of effects\n * @param {Object} props Bag of current property changes\n * @param {Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\n\n\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    var ran = false;\n    var id = dedupeId++;\n\n    for (var prop in props) {\n      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {\n        ran = true;\n      }\n    }\n\n    return ran;\n  }\n\n  return false;\n}\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!PropertyEffectsType} inst The instance with effects to run\n * @param {Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\n\n\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  var ran = false;\n  var rootProperty = hasPaths ? root(prop) : prop;\n  var fxs = effects[rootProperty];\n\n  if (fxs) {\n    for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n\n  return ran;\n}\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\n\n\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    var triggerPath = trigger.name;\n    return triggerPath == path || trigger.structured && isAncestor(triggerPath, path) || trigger.wildcard && isDescendant(triggerPath, path);\n  } else {\n    return true;\n  }\n}\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\n\n\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  var fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  var changedProp = info.property;\n\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!PropertyEffectsType} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\n\n\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  var fxs = inst[TYPES.NOTIFY];\n  var notified;\n  var id = dedupeId++; // Try normal notify effects; if none, fall back to try path notification\n\n  for (var prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  } // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n\n\n  var host;\n\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!PropertyEffectsType} inst The element from which to fire the event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\n\n\nfunction notifyPath(inst, path, props) {\n  var rootProperty = root(path);\n\n  if (rootProperty !== path) {\n    var eventName = camelToDashCase(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!PropertyEffectsType} inst The element from which to fire the event\n * @param {string} eventName The name of the event to send ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property changed, the path\n *   that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\n\n\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  var detail = {\n    value: value,\n    queueProperty: true\n  };\n\n  if (path) {\n    detail.path = path;\n  }\n  /** @type {!HTMLElement} */\n\n\n  inst.dispatchEvent(new CustomEvent(eventName, {\n    detail: detail\n  }));\n}\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\n\n\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  var rootProperty = hasPaths ? root(property) : property;\n  var path = rootProperty != property ? property : null;\n  var value = path ? _get2(inst, path) : inst.__data[property];\n\n  if (path && value === undefined) {\n    value = props[property]; // specifically for .splices\n  }\n\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!PropertyEffectsType} inst Host element instance handling the notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\n\n\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  var value;\n  var detail =\n  /** @type {Object} */\n  event.detail;\n  var fromPath = detail && detail.path;\n\n  if (fromPath) {\n    toPath = translate(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.currentTarget[fromProp];\n  }\n\n  value = negate ? !value : value;\n\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\n\n\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  var value = inst.__data[property];\n\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, info.attrName, 'attribute',\n    /** @type {Node} */\n    inst);\n  }\n\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {!Object} changedProps Bag of changed properties\n * @param {!Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\n\n\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  var computeEffects = inst[TYPES.COMPUTE];\n\n  if (computeEffects) {\n    var inputProps = changedProps;\n\n    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n      Object.assign(oldProps, inst.__dataOld);\n      Object.assign(changedProps, inst.__dataPending);\n      inputProps = inst.__dataPending;\n      inst.__dataPending = null;\n    }\n  }\n}\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\n\n\nfunction runComputedEffect(inst, property, props, oldProps, info) {\n  var result = runMethodEffect(inst, property, props, oldProps, info);\n  var computedProp = info.methodInfo;\n\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n  }\n}\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!PropertyEffectsType} inst The instance whose props are changing\n * @param {string | !Array<(string|number)>} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\n\n\nfunction computeLinkedPaths(inst, path, value) {\n  var links = inst.__dataLinkedPaths;\n\n  if (links) {\n    var link;\n\n    for (var a in links) {\n      var b = links[a];\n\n      if (isDescendant(a, path)) {\n        link = translate(a, b, path);\n\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if (isDescendant(b, path)) {\n        link = translate(b, a, path);\n\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n} // -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\n\n\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  var\n  /** Binding */\n  binding = {\n    kind: kind,\n    target: target,\n    parts: parts,\n    literal: literal,\n    isCompound: parts.length !== 1\n  };\n  nodeInfo.bindings.push(binding); // Add listener info to binding metadata\n\n  if (shouldAddListener(binding)) {\n    var _binding$parts$ = binding.parts[0],\n        event = _binding$parts$.event,\n        negate = _binding$parts$.negate;\n    binding.listenerEvent = event || camelToDashCase(target) + '-changed';\n    binding.listenerNegate = negate;\n  } // Add \"propagate\" property effects to templateInfo\n\n\n  var index = templateInfo.nodeInfoList.length;\n\n  for (var i = 0; i < binding.parts.length; i++) {\n    var part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\n\n\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n    } else {\n      var dependencies = part.dependencies;\n      var info = {\n        index: index,\n        binding: binding,\n        part: part,\n        evaluator: constructor\n      };\n\n      for (var j = 0; j < dependencies.length; j++) {\n        var trigger = dependencies[j];\n\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info: info,\n          trigger: trigger\n        });\n      }\n    }\n  }\n}\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\n\n\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  var node = nodeList[info.index];\n  var binding = info.binding;\n  var part = info.part; // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n\n  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    var value = props[path];\n    path = translate(part.source, binding.target, path);\n\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths); // Propagate value to child\n\n\n    applyBindingValue(inst, node, binding, part, _value);\n  }\n}\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!PropertyEffectsType} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\n\n\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, binding.target, binding.kind, node);\n  }\n\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute(\n    /** @type {Element} */\n    node, value, binding.target);\n  } else {\n    // Property binding\n    var prop = binding.target;\n\n    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\n\n\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    var storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {\n      value = value == undefined ? '' : value;\n    }\n  }\n\n  return value;\n}\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\n\n\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n}\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!PropertyEffectsType} inst Instance that bas been previously bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\n\n\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  var nodeList = templateInfo.nodeList,\n      nodeInfoList = templateInfo.nodeInfoList;\n\n  if (nodeInfoList.length) {\n    for (var i = 0; i < nodeInfoList.length; i++) {\n      var info = nodeInfoList[i];\n      var node = nodeList[i];\n      var bindings = info.bindings;\n\n      if (bindings) {\n        for (var _i = 0; _i < bindings.length; _i++) {\n          var binding = bindings[_i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n\n      node.__dataHost = inst;\n    }\n  }\n}\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\n\n\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n    var parts = binding.parts; // Copy literals from parts into storage for this binding\n\n    var literals = new Array(parts.length);\n\n    for (var j = 0; j < parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n\n    var target = binding.target;\n    storage[target] = literals; // Configure properties with their literal parts\n\n    if (binding.literal && binding.kind == 'property') {\n      node[target] = binding.literal;\n    }\n  }\n}\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!PropertyEffectsType} inst Host element instance to handle notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\n\n\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    var part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function (e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n} // -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {void}\n * @private\n */\n\n\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);\n  var info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo: methodInfo,\n    dynamicFn: dynamicFn\n  };\n\n  for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn,\n        info: info,\n        trigger: arg\n      });\n    }\n  }\n\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn,\n      info: info\n    });\n  }\n}\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!PropertyEffectsType} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\n\n\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  var context = inst._methodHost || inst;\n  var fn = context[info.methodName];\n\n  if (fn) {\n    var args = inst._marshalArgs(info.args, property, props);\n\n    return fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\n\nvar emptyArray = []; // Regular expressions used for binding\n\nvar IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nvar NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nvar SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nvar DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nvar STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nvar ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\\\s*' + ')';\nvar ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nvar ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\nvar BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n\nvar OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nvar CLOSE_BRACKET = '(?:]]|}})';\nvar NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n\nvar EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nvar bindingRegex = new RegExp(EXPRESSION, \"g\");\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\n\nfunction literalFromParts(parts) {\n  var s = '';\n\n  for (var i = 0; i < parts.length; i++) {\n    var literal = parts[i].literal;\n    s += literal || '';\n  }\n\n  return s;\n}\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\n\n\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  var m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n\n  if (m) {\n    var methodName = m[1];\n    var sig = {\n      methodName: methodName,\n      static: true,\n      args: emptyArray\n    };\n\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      var args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n\n  return null;\n}\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\n\n\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function (rawArg) {\n    var arg = parseArg(rawArg);\n\n    if (!arg.literal) {\n      sig.static = false;\n    }\n\n    return arg;\n  }, this);\n  return sig;\n}\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\n\n\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  var arg = rawArg.trim() // replace comma entity with comma\n  .replace(/&comma;/g, ',') // repair extra escape sequences; note only commas strictly need\n  // escaping, but we allow any other char to be escaped since its\n  // likely users will do this\n  .replace(/\\\\(.)/g, '\\$1'); // basic argument descriptor\n\n  var a = {\n    name: arg,\n    value: '',\n    literal: false\n  }; // detect literal value (must be String or Number)\n\n  var fc = arg[0];\n\n  if (fc === '-') {\n    fc = arg[1];\n  }\n\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n\n  switch (fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  } // if not literal, look for structured path\n\n\n  if (!a.literal) {\n    a.rootProperty = root(arg); // detect structured path (has dots)\n\n    a.structured = isPath(arg);\n\n    if (a.structured) {\n      a.wildcard = arg.slice(-2) == '.*';\n\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n\n  return a;\n} // data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!PropertyEffectsType} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\n\n\nfunction _notifySplices(inst, array, path, splices) {\n  var splicesPath = path + '.splices';\n  inst.notifyPath(splicesPath, {\n    indexSplices: splices\n  });\n  inst.notifyPath(path + '.length', array.length); // Null here to allow potentially large splice records to be GC'ed.\n\n  inst.__data[splicesPath] = {\n    indexSplices: null\n  };\n}\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!PropertyEffectsType} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\n\n\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  _notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\n\n\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n/**\n * Element class mixin that provides meta-programming for Polymer's template\n * binding and data observation (collectively, \"property effects\") system.\n *\n * This mixin uses provides the following key static methods for adding\n * property effects to an element class:\n * - `addPropertyEffect`\n * - `createPropertyObserver`\n * - `createMethodObserver`\n * - `createNotifyingProperty`\n * - `createReadOnlyProperty`\n * - `createReflectedProperty`\n * - `createComputedProperty`\n * - `bindTemplate`\n *\n * Each method creates one or more property accessors, along with metadata\n * used by this mixin's implementation of `_propertiesChanged` to perform\n * the property effects.\n *\n * Underscored versions of the above methods also exist on the element\n * prototype for adding property effects on instances at runtime.\n *\n * Note that this mixin overrides several `PropertyAccessors` methods, in\n * many cases to maintain guarantees provided by the Polymer 1.x features;\n * notably it changes property accessors to be synchronous by default\n * whereas the default when using `PropertyAccessors` standalone is to be\n * async by default.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin TemplateStamp\n * @appliesMixin PropertyAccessors\n * @summary Element class mixin that provides meta-programming for Polymer's\n * template binding and data observation system.\n */\n\n\nexport var PropertyEffects = dedupingMixin(function (superClass) {\n  /**\n   * @constructor\n   * @extends {superClass}\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */\n  var propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n\n  var PropertyEffects =\n  /*#__PURE__*/\n  function (_propertyEffectsBase) {\n    _inherits(PropertyEffects, _propertyEffectsBase);\n\n    function PropertyEffects() {\n      var _this;\n\n      _classCallCheck(this, PropertyEffects);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(PropertyEffects).call(this));\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n\n      _this.__isPropertyEffectsClient = true;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      // path changes dirty check against `__dataTemp` only during one \"turn\"\n      // and are cleared when `__dataCounter` returns to 0.\n\n      _this.__dataCounter = 0;\n      /** @type {boolean} */\n\n      _this.__dataClientsReady;\n      /** @type {Array} */\n\n      _this.__dataPendingClients;\n      /** @type {Object} */\n\n      _this.__dataToNotify;\n      /** @type {Object} */\n\n      _this.__dataLinkedPaths;\n      /** @type {boolean} */\n\n      _this.__dataHasPaths;\n      /** @type {Object} */\n\n      _this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n\n      _this.__dataHost;\n      /** @type {!Object} */\n\n      _this.__dataTemp;\n      /** @type {boolean} */\n\n      _this.__dataClientsInitialized;\n      /** @type {!Object} */\n\n      _this.__data;\n      /** @type {!Object} */\n\n      _this.__dataPending;\n      /** @type {!Object} */\n\n      _this.__dataOld;\n      /** @type {Object} */\n\n      _this.__computeEffects;\n      /** @type {Object} */\n\n      _this.__reflectEffects;\n      /** @type {Object} */\n\n      _this.__notifyEffects;\n      /** @type {Object} */\n\n      _this.__propagateEffects;\n      /** @type {Object} */\n\n      _this.__observeEffects;\n      /** @type {Object} */\n\n      _this.__readOnly;\n      /** @type {!TemplateInfo} */\n\n      _this.__templateInfo;\n      return _this;\n    }\n\n    _createClass(PropertyEffects, [{\n      key: \"_initializeProperties\",\n\n      /**\n       * @return {void}\n       */\n      value: function _initializeProperties() {\n        _get(_getPrototypeOf(PropertyEffects.prototype), \"_initializeProperties\", this).call(this);\n\n        hostStack.registerHost(this);\n        this.__dataClientsReady = false;\n        this.__dataPendingClients = null;\n        this.__dataToNotify = null;\n        this.__dataLinkedPaths = null;\n        this.__dataHasPaths = false; // May be set on instance prior to upgrade\n\n        this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n        this.__dataHost = this.__dataHost || null;\n        this.__dataTemp = {};\n        this.__dataClientsInitialized = false;\n      }\n      /**\n       * Overrides `PropertyAccessors` implementation to provide a\n       * more efficient implementation of initializing properties from\n       * the prototype on the instance.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the prototype\n       * @return {void}\n       */\n\n    }, {\n      key: \"_initializeProtoProperties\",\n      value: function _initializeProtoProperties(props) {\n        this.__data = Object.create(props);\n        this.__dataPending = Object.create(props);\n        this.__dataOld = {};\n      }\n      /**\n       * Overrides `PropertyAccessors` implementation to avoid setting\n       * `_setProperty`'s `shouldNotify: true`.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the instance\n       * @return {void}\n       */\n\n    }, {\n      key: \"_initializeInstanceProperties\",\n      value: function _initializeInstanceProperties(props) {\n        var readOnly = this[TYPES.READ_ONLY];\n\n        for (var prop in props) {\n          if (!readOnly || !readOnly[prop]) {\n            this.__dataPending = this.__dataPending || {};\n            this.__dataOld = this.__dataOld || {};\n            this.__data[prop] = this.__dataPending[prop] = props[prop];\n          }\n        }\n      } // Prototype setup ----------------------------------------\n\n      /**\n       * Equivalent to static `addPropertyEffect` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_addPropertyEffect\",\n      value: function _addPropertyEffect(property, type, effect) {\n        this._createPropertyAccessor(property, type == TYPES.READ_ONLY); // effects are accumulated into arrays per property based on type\n\n\n        var effects = ensureOwnEffectMap(this, type)[property];\n\n        if (!effects) {\n          effects = this[type][property] = [];\n        }\n\n        effects.push(effect);\n      }\n      /**\n       * Removes the given property effect.\n       *\n       * @param {string} property Property the effect was associated with\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object to remove\n       * @return {void}\n       */\n\n    }, {\n      key: \"_removePropertyEffect\",\n      value: function _removePropertyEffect(property, type, effect) {\n        var effects = ensureOwnEffectMap(this, type)[property];\n        var idx = effects.indexOf(effect);\n\n        if (idx >= 0) {\n          effects.splice(idx, 1);\n        }\n      }\n      /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: \"_hasPropertyEffect\",\n      value: function _hasPropertyEffect(property, type) {\n        var effects = this[type];\n        return Boolean(effects && effects[property]);\n      }\n      /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: \"_hasReadOnlyEffect\",\n      value: function _hasReadOnlyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n      }\n      /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: \"_hasNotifyEffect\",\n      value: function _hasNotifyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.NOTIFY);\n      }\n      /**\n       * Returns whether the current prototype/instance has a \"reflect to attribute\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: \"_hasReflectEffect\",\n      value: function _hasReflectEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.REFLECT);\n      }\n      /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    }, {\n      key: \"_hasComputedEffect\",\n      value: function _hasComputedEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.COMPUTE);\n      } // Runtime ----------------------------------------\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @param {string | !Array<number|string>} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify Set to true if this change should\n       *  cause a property notification event dispatch\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n\n    }, {\n      key: \"_setPendingPropertyOrPath\",\n      value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n        if (isPathNotification || root(Array.isArray(path) ? path[0] : path) !== path) {\n          // Dirty check changes being set to a path against the actual object,\n          // since this is the entry point for paths into the system; from here\n          // the only dirty checks are against the `__dataTemp` cache to prevent\n          // duplicate work in the same turn only. Note, if this was a notification\n          // of a change already set to a path (isPathNotification: true),\n          // we always let the change through and skip the `set` since it was\n          // already dirty checked at the point of entry and the underlying\n          // object has already been updated\n          if (!isPathNotification) {\n            var old = _get2(this, path);\n\n            path =\n            /** @type {string} */\n            _set(this, path, value); // Use property-accessor's simpler dirty check\n\n            if (!path || !_get(_getPrototypeOf(PropertyEffects.prototype), \"_shouldPropertyChange\", this).call(this, path, value, old)) {\n              return false;\n            }\n          }\n\n          this.__dataHasPaths = true;\n\n          if (this._setPendingProperty(\n          /**@type{string}*/\n          path, value, shouldNotify)) {\n            computeLinkedPaths(this, path, value);\n            return true;\n          }\n        } else {\n          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n            return this._setPendingProperty(\n            /**@type{string}*/\n            path, value, shouldNotify);\n          } else {\n            this[path] = value;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * Applies a value to a non-Polymer element/node's property.\n       *\n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting `<input>.value` resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information.\n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @param {!Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_setUnmanagedPropertyToNode\",\n      value: function _setUnmanagedPropertyToNode(node, prop, value) {\n        // It is a judgment call that resetting primitives is\n        // \"bad\" and resettings objects is also \"good\"; alternatively we could\n        // implement a whitelist of tag & property values that should never\n        // be reset (e.g. <input>.value && <select>.value)\n        if (value !== node[prop] || typeof value == 'object') {\n          node[prop] = value;\n        }\n      }\n      /**\n       * Overrides the `PropertiesChanged` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChanged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @override\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify True if property should fire notification\n       *   event (applies only for `notify: true` properties)\n       * @return {boolean} Returns true if the property changed\n       */\n\n    }, {\n      key: \"_setPendingProperty\",\n      value: function _setPendingProperty(property, value, shouldNotify) {\n        var propIsPath = this.__dataHasPaths && isPath(property);\n        var prevProps = propIsPath ? this.__dataTemp : this.__data;\n\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          } // Ensure old is captured from the last turn\n\n\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          } // Paths are stored in temporary cache (cleared at end of turn),\n          // which is used for dirty-checking, all others stored in __data\n\n\n          if (propIsPath) {\n            this.__dataTemp[property] = value;\n          } else {\n            this.__data[property] = value;\n          } // All changes go into pending property bag, passed to _propertiesChanged\n\n\n          this.__dataPending[property] = value; // Track properties that should notify separately\n\n          if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {\n            this.__dataToNotify = this.__dataToNotify || {};\n            this.__dataToNotify[property] = shouldNotify;\n          }\n\n          return true;\n        }\n\n        return false;\n      }\n      /**\n       * Overrides base implementation to ensure all accessors set `shouldNotify`\n       * to true, for per-property notification tracking.\n       *\n       * @override\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       */\n\n    }, {\n      key: \"_setProperty\",\n      value: function _setProperty(property, value) {\n        if (this._setPendingProperty(property, value, true)) {\n          this._invalidateProperties();\n        }\n      }\n      /**\n       * Overrides `PropertyAccessor`'s default async queuing of\n       * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       * @return {void}\n       */\n\n    }, {\n      key: \"_invalidateProperties\",\n      value: function _invalidateProperties() {\n        if (this.__dataReady) {\n          this._flushProperties();\n        }\n      }\n      /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @param {Object} client PropertyEffects client to enqueue\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_enqueueClient\",\n      value: function _enqueueClient(client) {\n        this.__dataPendingClients = this.__dataPendingClients || [];\n\n        if (client !== this) {\n          this.__dataPendingClients.push(client);\n        }\n      }\n      /**\n       * Overrides superclass implementation.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_flushProperties\",\n      value: function _flushProperties() {\n        this.__dataCounter++;\n\n        _get(_getPrototypeOf(PropertyEffects.prototype), \"_flushProperties\", this).call(this);\n\n        this.__dataCounter--;\n      }\n      /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_flushClients\",\n      value: function _flushClients() {\n        if (!this.__dataClientsReady) {\n          this.__dataClientsReady = true;\n\n          this._readyClients(); // Override point where accessors are turned on; importantly,\n          // this is after clients have fully readied, providing a guarantee\n          // that any property effects occur only after all clients are ready.\n\n\n          this.__dataReady = true;\n        } else {\n          this.__enableOrFlushClients();\n        }\n      } // NOTE: We ensure clients either enable or flush as appropriate. This\n      // handles two corner cases:\n      // (1) clients flush properly when connected/enabled before the host\n      // enables; e.g.\n      //   (a) Templatize stamps with no properties and does not flush and\n      //   (b) the instance is inserted into dom and\n      //   (c) then the instance flushes.\n      // (2) clients enable properly when not connected/enabled when the host\n      // flushes; e.g.\n      //   (a) a template is runtime stamped and not yet connected/enabled\n      //   (b) a host sets a property, causing stamped dom to flush\n      //   (c) the stamped dom enables.\n\n    }, {\n      key: \"__enableOrFlushClients\",\n      value: function __enableOrFlushClients() {\n        var clients = this.__dataPendingClients;\n\n        if (clients) {\n          this.__dataPendingClients = null;\n\n          for (var i = 0; i < clients.length; i++) {\n            var client = clients[i];\n\n            if (!client.__dataEnabled) {\n              client._enableProperties();\n            } else if (client.__dataPending) {\n              client._flushProperties();\n            }\n          }\n        }\n      }\n      /**\n       * Perform any initial setup on client dom. Called before the first\n       * `_flushProperties` call on client dom and before any element\n       * observers are called.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_readyClients\",\n      value: function _readyClients() {\n        this.__enableOrFlushClients();\n      }\n      /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * Property names must be simple properties, not paths.  Batched\n       * path propagation is not supported.\n       *\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       * @param {boolean=} setReadOnly When true, any private values set in\n       *   `props` will be set. By default, `setProperties` will not set\n       *   `readOnly: true` root properties.\n       * @return {void}\n       * @public\n       */\n\n    }, {\n      key: \"setProperties\",\n      value: function setProperties(props, setReadOnly) {\n        for (var path in props) {\n          if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n            //TODO(kschaaf): explicitly disallow paths in setProperty?\n            // wildcard observers currently only pass the first changed path\n            // in the `info` object, and you could do some odd things batching\n            // paths, e.g. {'foo.bar': {...}, 'foo': null}\n            this._setPendingPropertyOrPath(path, props[path], true);\n          }\n        }\n\n        this._invalidateProperties();\n      }\n      /**\n       * Overrides `PropertyAccessors` so that property accessor\n       * side effects are not enabled until after client dom is fully ready.\n       * Also calls `_flushClients` callback to ensure client dom is enabled\n       * that was not enabled as a result of flushing properties.\n       *\n       * @override\n       * @return {void}\n       */\n\n    }, {\n      key: \"ready\",\n      value: function ready() {\n        // It is important that `super.ready()` is not called here as it\n        // immediately turns on accessors. Instead, we wait until `readyClients`\n        // to enable accessors to provide a guarantee that clients are ready\n        // before processing any accessors side effects.\n        this._flushProperties(); // If no data was pending, `_flushProperties` will not `flushClients`\n        // so ensure this is done.\n\n\n        if (!this.__dataClientsReady) {\n          this._flushClients();\n        } // Before ready, client notifications do not trigger _flushProperties.\n        // Therefore a flush is necessary here if data has been set.\n\n\n        if (this.__dataPending) {\n          this._flushProperties();\n        }\n      }\n      /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       */\n\n    }, {\n      key: \"_propertiesChanged\",\n      value: function _propertiesChanged(currentProps, changedProps, oldProps) {\n        // ----------------------------\n        // let c = Object.getOwnPropertyNames(changedProps || {});\n        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n        // if (window.debug) { debugger; }\n        // ----------------------------\n        var hasPaths = this.__dataHasPaths;\n        this.__dataHasPaths = false; // Compute properties\n\n        runComputedEffects(this, changedProps, oldProps, hasPaths); // Clear notify properties prior to possible reentry (propagate, observe),\n        // but after computing effects have a chance to add to them\n\n        var notifyProps = this.__dataToNotify;\n        this.__dataToNotify = null; // Propagate properties to clients\n\n        this._propagatePropertyChanges(changedProps, oldProps, hasPaths); // Flush clients\n\n\n        this._flushClients(); // Reflect properties\n\n\n        runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths); // Observe properties\n\n        runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths); // Notify properties to host\n\n        if (notifyProps) {\n          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n        } // Clear temporary cache at end of turn\n\n\n        if (this.__dataCounter == 1) {\n          this.__dataTemp = {};\n        } // ----------------------------\n        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n        // ----------------------------\n\n      }\n      /**\n       * Called to propagate any property changes to stamped template nodes\n       * managed by this element.\n       *\n       * @param {Object} changedProps Bag of changed properties\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_propagatePropertyChanges\",\n      value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n        if (this[TYPES.PROPAGATE]) {\n          runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n        }\n\n        var templateInfo = this.__templateInfo;\n\n        while (templateInfo) {\n          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n          templateInfo = templateInfo.nextTemplateInfo;\n        }\n      }\n      /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @return {void}\n       * @public\n       */\n\n    }, {\n      key: \"linkPaths\",\n      value: function linkPaths(to, from) {\n        to = normalize(to);\n        from = normalize(from);\n        this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n        this.__dataLinkedPaths[to] = from;\n      }\n      /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @return {void}\n       * @public\n       */\n\n    }, {\n      key: \"unlinkPaths\",\n      value: function unlinkPaths(path) {\n        path = normalize(path);\n\n        if (this.__dataLinkedPaths) {\n          delete this.__dataLinkedPaths[path];\n        }\n      }\n      /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, object: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       * @return {void}\n       * @public\n      */\n\n    }, {\n      key: \"notifySplices\",\n      value: function notifySplices(path, splices) {\n        var info = {\n          path: ''\n        };\n\n        var array =\n        /** @type {Array} */\n        _get2(this, path, info);\n\n        _notifySplices(this, array, info.path, splices);\n      }\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(path, root) {\n        return _get2(root || this, path);\n      }\n      /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @return {void}\n       * @public\n      */\n\n    }, {\n      key: \"set\",\n      value: function set(path, value, root) {\n        if (root) {\n          _set(root, path, value);\n        } else {\n          if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][\n          /** @type {string} */\n          path]) {\n            if (this._setPendingPropertyOrPath(path, value, true)) {\n              this._invalidateProperties();\n            }\n          }\n        }\n      }\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n\n    }, {\n      key: \"push\",\n      value: function push(path) {\n        var info = {\n          path: ''\n        };\n\n        var array =\n        /** @type {Array}*/\n        _get2(this, path, info);\n\n        var len = array.length;\n\n        for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          items[_key - 1] = arguments[_key];\n        }\n\n        var ret = array.push.apply(array, items);\n\n        if (items.length) {\n          notifySplice(this, array, info.path, len, items.length, []);\n        }\n\n        return ret;\n      }\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n\n    }, {\n      key: \"pop\",\n      value: function pop(path) {\n        var info = {\n          path: ''\n        };\n\n        var array =\n        /** @type {Array} */\n        _get2(this, path, info);\n\n        var hadLength = Boolean(array.length);\n        var ret = array.pop();\n\n        if (hadLength) {\n          notifySplice(this, array, info.path, array.length, 0, [ret]);\n        }\n\n        return ret;\n      }\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number=} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of removed items.\n       * @public\n       */\n\n    }, {\n      key: \"splice\",\n      value: function splice(path, start, deleteCount) {\n        for (var _len2 = arguments.length, items = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          items[_key2 - 3] = arguments[_key2];\n        }\n\n        var info = {\n          path: ''\n        };\n\n        var array =\n        /** @type {Array} */\n        _get2(this, path, info); // Normalize fancy native splice handling of crazy start values\n\n\n        if (start < 0) {\n          start = array.length - Math.floor(-start);\n        } else if (start) {\n          start = Math.floor(start);\n        } // array.splice does different things based on the number of arguments\n        // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n        // do different things. In the former, the whole array is cleared. In the\n        // latter, no items are removed.\n        // This means that we need to detect whether 1. one of the arguments\n        // is actually passed in and then 2. determine how many arguments\n        // we should pass on to the native array.splice\n        //\n\n\n        var ret; // Omit any additional arguments if they were not passed in\n\n        if (arguments.length === 2) {\n          ret = array.splice(start); // Either start was undefined and the others were defined, but in this\n          // case we can safely pass on all arguments\n          //\n          // Note: this includes the case where none of the arguments were passed in,\n          // e.g. this.splice('array'). However, if both start and deleteCount\n          // are undefined, array.splice will not modify the array (as expected)\n        } else {\n          ret = array.splice.apply(array, [start, deleteCount].concat(items));\n        } // At the end, check whether any items were passed in (e.g. insertions)\n        // or if the return array contains items (e.g. deletions).\n        // Only notify if items were added or deleted.\n\n\n        if (items.length || ret.length) {\n          notifySplice(this, array, info.path, start, items.length, ret);\n        }\n\n        return ret;\n      }\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n\n    }, {\n      key: \"shift\",\n      value: function shift(path) {\n        var info = {\n          path: ''\n        };\n\n        var array =\n        /** @type {Array} */\n        _get2(this, path, info);\n\n        var hadLength = Boolean(array.length);\n        var ret = array.shift();\n\n        if (hadLength) {\n          notifySplice(this, array, info.path, 0, 0, [ret]);\n        }\n\n        return ret;\n      }\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n\n    }, {\n      key: \"unshift\",\n      value: function unshift(path) {\n        var info = {\n          path: ''\n        };\n\n        var array =\n        /** @type {Array} */\n        _get2(this, path, info);\n\n        for (var _len3 = arguments.length, items = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          items[_key3 - 1] = arguments[_key3];\n        }\n\n        var ret = array.unshift.apply(array, items);\n\n        if (items.length) {\n          notifySplice(this, array, info.path, 0, items.length, []);\n        }\n\n        return ret;\n      }\n      /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @return {void}\n       * @public\n      */\n\n    }, {\n      key: \"notifyPath\",\n      value: function notifyPath(path, value) {\n        /** @type {string} */\n        var propPath;\n\n        if (arguments.length == 1) {\n          // Get value if not supplied\n          var info = {\n            path: ''\n          };\n          value = _get2(this, path, info);\n          propPath = info.path;\n        } else if (Array.isArray(path)) {\n          // Normalize path if needed\n          propPath = normalize(path);\n        } else {\n          propPath =\n          /** @type{string} */\n          path;\n        }\n\n        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n          this._invalidateProperties();\n        }\n      }\n      /**\n       * Equivalent to static `createReadOnlyProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_createReadOnlyProperty\",\n      value: function _createReadOnlyProperty(property, protectedSetter) {\n        this._addPropertyEffect(property, TYPES.READ_ONLY);\n\n        if (protectedSetter) {\n          this['_set' + upper(property)] =\n          /** @this {PropertyEffects} */\n          function (value) {\n            this._setProperty(property, value);\n          };\n        }\n      }\n      /**\n       * Equivalent to static `createPropertyObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {string|function(*,*)} method Function or name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_createPropertyObserver\",\n      value: function _createPropertyObserver(property, method, dynamicFn) {\n        var info = {\n          property: property,\n          method: method,\n          dynamicFn: Boolean(dynamicFn)\n        };\n\n        this._addPropertyEffect(property, TYPES.OBSERVE, {\n          fn: runObserverEffect,\n          info: info,\n          trigger: {\n            name: property\n          }\n        });\n\n        if (dynamicFn) {\n          this._addPropertyEffect(\n          /** @type {string} */\n          method, TYPES.OBSERVE, {\n            fn: runObserverEffect,\n            info: info,\n            trigger: {\n              name: method\n            }\n          });\n        }\n      }\n      /**\n       * Equivalent to static `createMethodObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_createMethodObserver\",\n      value: function _createMethodObserver(expression, dynamicFn) {\n        var sig = parseMethod(expression);\n\n        if (!sig) {\n          throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n        }\n\n        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n      }\n      /**\n       * Equivalent to static `createNotifyingProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_createNotifyingProperty\",\n      value: function _createNotifyingProperty(property) {\n        this._addPropertyEffect(property, TYPES.NOTIFY, {\n          fn: runNotifyEffect,\n          info: {\n            eventName: camelToDashCase(property) + '-changed',\n            property: property\n          }\n        });\n      }\n      /**\n       * Equivalent to static `createReflectedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_createReflectedProperty\",\n      value: function _createReflectedProperty(property) {\n        var attr = this.constructor.attributeNameForProperty(property);\n\n        if (attr[0] === '-') {\n          console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n        } else {\n          this._addPropertyEffect(property, TYPES.REFLECT, {\n            fn: runReflectEffect,\n            info: {\n              attrName: attr\n            }\n          });\n        }\n      }\n      /**\n       * Equivalent to static `createComputedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_createComputedProperty\",\n      value: function _createComputedProperty(property, expression, dynamicFn) {\n        var sig = parseMethod(expression);\n\n        if (!sig) {\n          throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n        }\n\n        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      }\n      /**\n       * Gather the argument values for a method specified in the provided array\n       * of argument metadata.\n       *\n       * The `path` and `value` arguments are used to fill in wildcard descriptor\n       * when the method is being called as a result of a path notification.\n       *\n       * @param {!Array<!MethodArg>} args Array of argument metadata\n       * @param {string} path Property/path name that triggered the method effect\n       * @param {Object} props Bag of current property changes\n       * @return {Array<*>} Array of argument values\n       * @private\n       */\n\n    }, {\n      key: \"_marshalArgs\",\n      value: function _marshalArgs(args, path, props) {\n        var data = this.__data;\n        var values = [];\n\n        for (var i = 0, l = args.length; i < l; i++) {\n          var arg = args[i];\n          var name = arg.name;\n          var v = void 0;\n\n          if (arg.literal) {\n            v = arg.value;\n          } else {\n            if (arg.structured) {\n              v = _get2(data, name); // when data is not stored e.g. `splices`\n\n              if (v === undefined) {\n                v = props[name];\n              }\n            } else {\n              v = data[name];\n            }\n          }\n\n          if (arg.wildcard) {\n            // Only send the actual path changed info if the change that\n            // caused the observer to run matched the wildcard\n            var baseChanged = name.indexOf(path + '.') === 0;\n            var matches = path.indexOf(name) === 0 && !baseChanged;\n            values[i] = {\n              path: matches ? path : name,\n              value: matches ? props[path] : v,\n              base: v\n            };\n          } else {\n            values[i] = v;\n          }\n        }\n\n        return values;\n      } // -- static class methods ------------\n\n      /**\n       * Ensures an accessor exists for the specified property, and adds\n       * to a list of \"property effects\" that will run when the accessor for\n       * the specified property is set.  Effects are grouped by \"type\", which\n       * roughly corresponds to a phase in effect processing.  The effect\n       * metadata should be in the following form:\n       *\n       *     {\n       *       fn: effectFunction, // Reference to function to call to perform effect\n       *       info: { ... }       // Effect metadata passed to function\n       *       trigger: {          // Optional triggering metadata; if not provided\n       *         name: string      // the property is treated as a wildcard\n       *         structured: boolean\n       *         wildcard: boolean\n       *       }\n       *     }\n       *\n       * Effects are called from `_propertiesChanged` in the following order by\n       * type:\n       *\n       * 1. COMPUTE\n       * 2. PROPAGATE\n       * 3. REFLECT\n       * 4. OBSERVE\n       * 5. NOTIFY\n       *\n       * Effect functions are called with the following signature:\n       *\n       *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_bindTemplate\",\n      // -- binding ----------------------------------------------\n\n      /**\n       * Equivalent to static `bindTemplate` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * This method may be called on the prototype (for prototypical template\n       * binding, to avoid creating accessors every instance) once per prototype,\n       * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n       * create and link an instance of the template metadata associated with a\n       * particular stamping.\n       *\n       * @param {!HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @param {boolean=} instanceBinding When false (default), performs\n       *   \"prototypical\" binding of the template and overwrites any previously\n       *   bound template for the class. When true (as passed from\n       *   `_stampTemplate`), the template info is instanced and linked into\n       *   the list of bound templates.\n       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n       *   this is an instance of the prototypical template info\n       * @protected\n       */\n      value: function _bindTemplate(template, instanceBinding) {\n        var templateInfo = this.constructor._parseTemplate(template);\n\n        var wasPreBound = this.__templateInfo == templateInfo; // Optimization: since this is called twice for proto-bound templates,\n        // don't attempt to recreate accessors if this template was pre-bound\n\n        if (!wasPreBound) {\n          for (var prop in templateInfo.propertyEffects) {\n            this._createPropertyAccessor(prop);\n          }\n        }\n\n        if (instanceBinding) {\n          // For instance-time binding, create instance of template metadata\n          // and link into list of templates if necessary\n          templateInfo =\n          /** @type {!TemplateInfo} */\n          Object.create(templateInfo);\n          templateInfo.wasPreBound = wasPreBound;\n\n          if (!wasPreBound && this.__templateInfo) {\n            var last = this.__templateInfoLast || this.__templateInfo;\n            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;\n            templateInfo.previousTemplateInfo = last;\n            return templateInfo;\n          }\n        }\n\n        return this.__templateInfo = templateInfo;\n      }\n      /**\n       * Adds a property effect to the given template metadata, which is run\n       * at the \"propagate\" stage of `_propertiesChanged` when the template\n       * has been bound to the element via `_bindTemplate`.\n       *\n       * The `effect` object should match the format in `_addPropertyEffect`.\n       *\n       * @param {Object} templateInfo Template metadata to add effect to\n       * @param {string} prop Property that should trigger the effect\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_stampTemplate\",\n\n      /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * This method may be called more than once; however note that due to\n       * `shadycss` polyfill limitations, only styles from templates prepared\n       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n       * to the shadow root and support CSS custom properties), and note that\n       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n       * any styles required by in runtime-stamped templates must be included\n       * in the main element template.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @return {!StampedTemplate} Cloned template content\n       * @override\n       * @protected\n       */\n      value: function _stampTemplate(template) {\n        // Ensures that created dom is `_enqueueClient`'d to this element so\n        // that it can be flushed on next call to `_flushProperties`\n        hostStack.beginHosting(this);\n\n        var dom = _get(_getPrototypeOf(PropertyEffects.prototype), \"_stampTemplate\", this).call(this, template);\n\n        hostStack.endHosting(this);\n\n        var templateInfo =\n        /** @type {!TemplateInfo} */\n        this._bindTemplate(template, true); // Add template-instance-specific data to instanced templateInfo\n\n\n        templateInfo.nodeList = dom.nodeList; // Capture child nodes to allow unstamping of non-prototypical templates\n\n        if (!templateInfo.wasPreBound) {\n          var nodes = templateInfo.childNodes = [];\n\n          for (var n = dom.firstChild; n; n = n.nextSibling) {\n            nodes.push(n);\n          }\n        }\n\n        dom.templateInfo = templateInfo; // Setup compound storage, 2-way listeners, and dataHost for bindings\n\n        setupBindings(this, templateInfo); // Flush properties into template nodes if already booted\n\n        if (this.__dataReady) {\n          runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);\n        }\n\n        return dom;\n      }\n      /**\n       * Removes and unbinds the nodes previously contained in the provided\n       * DocumentFragment returned from `_stampTemplate`.\n       *\n       * @param {!StampedTemplate} dom DocumentFragment previously returned\n       *   from `_stampTemplate` associated with the nodes to be removed\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"_removeBoundDom\",\n      value: function _removeBoundDom(dom) {\n        // Unlink template info\n        var templateInfo = dom.templateInfo;\n\n        if (templateInfo.previousTemplateInfo) {\n          templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;\n        }\n\n        if (templateInfo.nextTemplateInfo) {\n          templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;\n        }\n\n        if (this.__templateInfoLast == templateInfo) {\n          this.__templateInfoLast = templateInfo.previousTemplateInfo;\n        }\n\n        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null; // Remove stamped nodes\n\n        var nodes = templateInfo.childNodes;\n\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          node.parentNode.removeChild(node);\n        }\n      }\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    }, {\n      key: \"PROPERTY_EFFECT_TYPES\",\n      get: function get() {\n        return TYPES;\n      }\n    }], [{\n      key: \"addPropertyEffect\",\n      value: function addPropertyEffect(property, type, effect) {\n        this.prototype._addPropertyEffect(property, type, effect);\n      }\n      /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string|function(*,*)} method Function or name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"createPropertyObserver\",\n      value: function createPropertyObserver(property, method, dynamicFn) {\n        this.prototype._createPropertyObserver(property, method, dynamicFn);\n      }\n      /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal JavaScript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       * @return {void}\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n\n    }, {\n      key: \"createMethodObserver\",\n      value: function createMethodObserver(expression, dynamicFn) {\n        this.prototype._createMethodObserver(expression, dynamicFn);\n      }\n      /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"createNotifyingProperty\",\n      value: function createNotifyingProperty(property) {\n        this.prototype._createNotifyingProperty(property);\n      }\n      /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"createReadOnlyProperty\",\n      value: function createReadOnlyProperty(property, protectedSetter) {\n        this.prototype._createReadOnlyProperty(property, protectedSetter);\n      }\n      /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"createReflectedProperty\",\n      value: function createReflectedProperty(property) {\n        this.prototype._createReflectedProperty(property);\n      }\n      /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal JavaScript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n       *   method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    }, {\n      key: \"createComputedProperty\",\n      value: function createComputedProperty(property, expression, dynamicFn) {\n        this.prototype._createComputedProperty(property, expression, dynamicFn);\n      }\n      /**\n       * Parses the provided template to ensure binding effects are created\n       * for them, and then ensures property accessors are created for any\n       * dependent properties in the template.  Binding effects for bound\n       * templates are stored in a linked list on the instance so that\n       * templates can be efficiently stamped and unstamped.\n       *\n       * @param {!HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @return {!TemplateInfo} Template metadata object\n       * @protected\n       */\n\n    }, {\n      key: \"bindTemplate\",\n      value: function bindTemplate(template) {\n        return this.prototype._bindTemplate(template);\n      }\n    }, {\n      key: \"_addTemplatePropertyEffect\",\n      value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {\n        var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n        hostProps[prop] = true;\n        var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n        var propEffects = effects[prop] = effects[prop] || [];\n        propEffects.push(effect);\n      }\n    }, {\n      key: \"_parseTemplateNode\",\n      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {\n        var noted = _get(_getPrototypeOf(PropertyEffects), \"_parseTemplateNode\", this).call(this, node, templateInfo, nodeInfo);\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          var parts = this._parseBindings(node.textContent, templateInfo);\n\n          if (parts) {\n            // Initialize the textContent with any literal parts\n            // NOTE: default to a space here so the textNode remains; some browsers\n            // (IE) omit an empty textNode following cloneNode/importNode.\n            node.textContent = literalFromParts(parts) || ' ';\n            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n            noted = true;\n          }\n        }\n\n        return noted;\n      }\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from attributes.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Element} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @param {string} name Attribute name\n       * @param {string} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    }, {\n      key: \"_parseTemplateNodeAttribute\",\n      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        var parts = this._parseBindings(value, templateInfo);\n\n        if (parts) {\n          // Attribute or property\n          var origName = name;\n          var kind = 'property'; // The only way we see a capital letter here is if the attr has\n          // a capital letter in it per spec. In this case, to make sure\n          // this binding works, we go ahead and make the binding to the attribute.\n\n          if (capitalAttributeRegex.test(name)) {\n            kind = 'attribute';\n          } else if (name[name.length - 1] == '$') {\n            name = name.slice(0, -1);\n            kind = 'attribute';\n          } // Initialize attribute bindings with any literal parts\n\n\n          var literal = literalFromParts(parts);\n\n          if (literal && kind == 'attribute') {\n            node.setAttribute(name, literal);\n          } // Clear attribute before removing, since IE won't allow removing\n          // `value` attribute if it previously had a value (can't\n          // unconditionally set '' before removing since attributes with `$`\n          // can't be set using setAttribute)\n\n\n          if (node.localName === 'input' && origName === 'value') {\n            node.setAttribute(origName, '');\n          } // Remove annotation\n\n\n          node.removeAttribute(origName); // Case hackery: attributes are lower-case, but bind targets\n          // (properties) are case sensitive. Gambit is to map dash-case to\n          // camel-case: `foo-bar` becomes `fooBar`.\n          // Attribute bindings are excepted.\n\n          if (kind === 'property') {\n            name = dashToCamelCase(name);\n          }\n\n          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n          return true;\n        } else {\n          return _get(_getPrototypeOf(PropertyEffects), \"_parseTemplateNodeAttribute\", this).call(this, node, templateInfo, nodeInfo, name, value);\n        }\n      }\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * binding the properties that a nested template depends on to the template\n       * as `_host_<property>`.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    }, {\n      key: \"_parseTemplateNestedTemplate\",\n      value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n        var noted = _get(_getPrototypeOf(PropertyEffects), \"_parseTemplateNestedTemplate\", this).call(this, node, templateInfo, nodeInfo); // Merge host props into outer template and add bindings\n\n\n        var hostProps = nodeInfo.templateInfo.hostProps;\n        var mode = '{';\n\n        for (var source in hostProps) {\n          var parts = [{\n            mode: mode,\n            source: source,\n            dependencies: [source]\n          }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n\n        return noted;\n      }\n      /**\n       * Called to parse text in a template (either attribute values or\n       * textContent) into binding metadata.\n       *\n       * Any overrides of this method should return an array of binding part\n       * metadata  representing one or more bindings found in the provided text\n       * and any \"literal\" text in between.  Any non-literal parts will be passed\n       * to `_evaluateBinding` when any dependencies change.  The only required\n       * fields of each \"part\" in the returned array are as follows:\n       *\n       * - `dependencies` - Array containing trigger metadata for each property\n       *   that should trigger the binding to update\n       * - `literal` - String containing text if the part represents a literal;\n       *   in this case no `dependencies` are needed\n       *\n       * Additional metadata for use by `_evaluateBinding` may be provided in\n       * each part object as needed.\n       *\n       * The default implementation handles the following types of bindings\n       * (one or more may be intermixed with literal strings):\n       * - Property binding: `[[prop]]`\n       * - Path binding: `[[object.prop]]`\n       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n       * - Two-way property or path bindings (supports negation):\n       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n       * - Inline computed method (supports negation):\n       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n       *\n       * The default implementation uses a regular expression for best\n       * performance. However, the regular expression uses a white-list of\n       * allowed characters in a data-binding, which causes problems for\n       * data-bindings that do use characters not in this white-list.\n       *\n       * Instead of updating the white-list with all allowed characters,\n       * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n       * that uses a state machine instead. This state machine is able to handle\n       * all characters. However, it is slightly less performant, therefore we\n       * extracted it into a separate optional mixin.\n       *\n       * @param {string} text Text to parse from attribute or textContent\n       * @param {Object} templateInfo Current template metadata\n       * @return {Array<!BindingPart>} Array of binding part metadata\n       * @protected\n       */\n\n    }, {\n      key: \"_parseBindings\",\n      value: function _parseBindings(text, templateInfo) {\n        var parts = [];\n        var lastIndex = 0;\n        var m; // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n        // Regex matches:\n        //        Iteration 1:  Iteration 2:\n        // m[1]: '{{'          '[['\n        // m[2]: ''            '!'\n        // m[3]: 'prop'        'compute(foo,bar)'\n\n        while ((m = bindingRegex.exec(text)) !== null) {\n          // Add literal part\n          if (m.index > lastIndex) {\n            parts.push({\n              literal: text.slice(lastIndex, m.index)\n            });\n          } // Add binding part\n\n\n          var mode = m[1][0];\n          var negate = Boolean(m[2]);\n          var source = m[3].trim();\n          var customEvent = false,\n              notifyEvent = '',\n              colon = -1;\n\n          if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n            notifyEvent = source.substring(colon + 2);\n            source = source.substring(0, colon);\n            customEvent = true;\n          }\n\n          var signature = parseMethod(source);\n          var dependencies = [];\n\n          if (signature) {\n            // Inline computed function\n            var args = signature.args,\n                methodName = signature.methodName;\n\n            for (var i = 0; i < args.length; i++) {\n              var arg = args[i];\n\n              if (!arg.literal) {\n                dependencies.push(arg);\n              }\n            }\n\n            var dynamicFns = templateInfo.dynamicFns;\n\n            if (dynamicFns && dynamicFns[methodName] || signature.static) {\n              dependencies.push(methodName);\n              signature.dynamicFn = true;\n            }\n          } else {\n            // Property or path\n            dependencies.push(source);\n          }\n\n          parts.push({\n            source: source,\n            mode: mode,\n            negate: negate,\n            customEvent: customEvent,\n            signature: signature,\n            dependencies: dependencies,\n            event: notifyEvent\n          });\n          lastIndex = bindingRegex.lastIndex;\n        } // Add a final literal part\n\n\n        if (lastIndex && lastIndex < text.length) {\n          var literal = text.substring(lastIndex);\n\n          if (literal) {\n            parts.push({\n              literal: literal\n            });\n          }\n        }\n\n        if (parts.length) {\n          return parts;\n        } else {\n          return null;\n        }\n      }\n      /**\n       * Called to evaluate a previously parsed binding part based on a set of\n       * one or more changed dependencies.\n       *\n       * @param {this} inst Element that should be used as scope for\n       *   binding dependencies\n       * @param {BindingPart} part Binding part metadata\n       * @param {string} path Property/path that triggered this effect\n       * @param {Object} props Bag of current property changes\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {*} Value the binding part evaluated to\n       * @protected\n       */\n\n    }, {\n      key: \"_evaluateBinding\",\n      value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n        var value;\n\n        if (part.signature) {\n          value = runMethodEffect(inst, path, props, oldProps, part.signature);\n        } else if (path != part.source) {\n          value = _get2(inst, part.source);\n        } else {\n          if (hasPaths && isPath(path)) {\n            value = _get2(inst, path);\n          } else {\n            value = inst.__data[path];\n          }\n        }\n\n        if (part.negate) {\n          value = !value;\n        }\n\n        return value;\n      }\n    }]);\n\n    return PropertyEffects;\n  }(propertyEffectsBase); // make a typing for closure :P\n\n\n  PropertyEffectsType = PropertyEffects;\n  return PropertyEffects;\n});\n/**\n * Helper api for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\n\nvar HostStack =\n/*#__PURE__*/\nfunction () {\n  function HostStack() {\n    _classCallCheck(this, HostStack);\n\n    this.stack = [];\n  }\n  /**\n   * @param {*} inst Instance to add to hostStack\n   * @return {void}\n   */\n\n\n  _createClass(HostStack, [{\n    key: \"registerHost\",\n    value: function registerHost(inst) {\n      if (this.stack.length) {\n        var host = this.stack[this.stack.length - 1];\n\n        host._enqueueClient(inst);\n      }\n    }\n    /**\n     * @param {*} inst Instance to begin hosting\n     * @return {void}\n     */\n\n  }, {\n    key: \"beginHosting\",\n    value: function beginHosting(inst) {\n      this.stack.push(inst);\n    }\n    /**\n     * @param {*} inst Instance to end hosting\n     * @return {void}\n     */\n\n  }, {\n    key: \"endHosting\",\n    value: function endHosting(inst) {\n      var stackLen = this.stack.length;\n\n      if (stackLen && this.stack[stackLen - 1] == inst) {\n        this.stack.pop();\n      }\n    }\n  }]);\n\n  return HostStack;\n}();\n\nvar hostStack = new HostStack();","map":null,"metadata":{},"sourceType":"module"}