{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '@webcomponents/shadycss/entrypoints/apply-shim.js';\nimport { ElementMixin } from '../mixins/element-mixin.js';\nimport { GestureEventListeners } from '../mixins/gesture-event-listeners.js';\nimport { DirMixin } from '../mixins/dir-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport '../utils/render-status.js';\nimport '../utils/unresolved.js';\nimport { dom, matchesSelector } from './polymer.dom.js';\nimport { setTouchAction } from '../utils/gestures.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { get } from '../utils/path.js';\nvar styleInterface = window.ShadyCSS;\n/**\n * Element class mixin that provides Polymer's \"legacy\" API intended to be\n * backward-compatible to the greatest extent possible with the API\n * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements\n * defined using the `Polymer({...})` function.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @appliesMixin GestureEventListeners\n * @property isAttached {boolean} Set to `true` in this element's\n *   `connectedCallback` and `false` in `disconnectedCallback`\n * @summary Element class mixin that provides Polymer's \"legacy\" API\n */\n\nexport var LegacyElementMixin = dedupingMixin(function (base) {\n  /**\n   * @constructor\n   * @extends {base}\n   * @implements {Polymer_ElementMixin}\n   * @implements {Polymer_GestureEventListeners}\n   * @implements {Polymer_DirMixin}\n   * @private\n   */\n  var legacyElementBase = DirMixin(GestureEventListeners(ElementMixin(base)));\n  /**\n   * Map of simple names to touch action names\n   * @dict\n   */\n\n  var DIRECTION_MAP = {\n    'x': 'pan-x',\n    'y': 'pan-y',\n    'none': 'none',\n    'all': 'auto'\n  };\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {legacyElementBase}\n   * @implements {Polymer_LegacyElementMixin}\n   * @unrestricted\n   */\n\n  var LegacyElement =\n  /*#__PURE__*/\n  function (_legacyElementBase) {\n    _inherits(LegacyElement, _legacyElementBase);\n\n    function LegacyElement() {\n      var _this;\n\n      _classCallCheck(this, LegacyElement);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(LegacyElement).call(this));\n      /** @type {boolean} */\n\n      _this.isAttached;\n      /** @type {WeakMap<!Element, !Object<string, !Function>>} */\n\n      _this.__boundListeners;\n      /** @type {Object<string, Function>} */\n\n      _this._debouncers; // Ensure listeners are applied immediately so that they are\n      // added before declarative event listeners. This allows an element to\n      // decorate itself via an event prior to any declarative listeners\n      // seeing the event. Note, this ensures compatibility with 1.x ordering.\n\n      _this._applyListeners();\n\n      return _this;\n    }\n    /**\n     * Forwards `importMeta` from the prototype (i.e. from the info object\n     * passed to `Polymer({...})`) to the static API.\n     *\n     * @return {!Object} The `import.meta` object set on the prototype\n     * @suppress {missingProperties} `this` is always in the instance in\n     *  closure for some reason even in a static method, rather than the class\n     */\n\n\n    _createClass(LegacyElement, [{\n      key: \"created\",\n\n      /**\n       * Legacy callback called during the `constructor`, for overriding\n       * by the user.\n       * @return {void}\n       */\n      value: function created() {}\n      /**\n       * Provides an implementation of `connectedCallback`\n       * which adds Polymer legacy API's `attached` method.\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(LegacyElement.prototype), \"connectedCallback\", this).call(this);\n\n        this.isAttached = true;\n        this.attached();\n      }\n      /**\n       * Legacy callback called during `connectedCallback`, for overriding\n       * by the user.\n       * @return {void}\n       */\n\n    }, {\n      key: \"attached\",\n      value: function attached() {}\n      /**\n       * Provides an implementation of `disconnectedCallback`\n       * which adds Polymer legacy API's `detached` method.\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(LegacyElement.prototype), \"disconnectedCallback\", this).call(this);\n\n        this.isAttached = false;\n        this.detached();\n      }\n      /**\n       * Legacy callback called during `disconnectedCallback`, for overriding\n       * by the user.\n       * @return {void}\n       */\n\n    }, {\n      key: \"detached\",\n      value: function detached() {}\n      /**\n       * Provides an override implementation of `attributeChangedCallback`\n       * which adds the Polymer legacy API's `attributeChanged` method.\n       * @param {string} name Name of attribute.\n       * @param {?string} old Old value of attribute.\n       * @param {?string} value Current value of attribute.\n       * @param {?string} namespace Attribute namespace.\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"attributeChangedCallback\",\n      value: function attributeChangedCallback(name, old, value, namespace) {\n        if (old !== value) {\n          _get(_getPrototypeOf(LegacyElement.prototype), \"attributeChangedCallback\", this).call(this, name, old, value, namespace);\n\n          this.attributeChanged(name, old, value);\n        }\n      }\n      /**\n       * Legacy callback called during `attributeChangedChallback`, for overriding\n       * by the user.\n       * @param {string} name Name of attribute.\n       * @param {?string} old Old value of attribute.\n       * @param {?string} value Current value of attribute.\n       * @return {void}\n       */\n\n    }, {\n      key: \"attributeChanged\",\n      value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars\n\n      /**\n       * Overrides the default `Polymer.PropertyEffects` implementation to\n       * add support for class initialization via the `_registered` callback.\n       * This is called only when the first instance of the element is created.\n       *\n       * @return {void}\n       * @override\n       * @suppress {invalidCasts}\n       */\n\n    }, {\n      key: \"_initializeProperties\",\n      value: function _initializeProperties() {\n        var proto = Object.getPrototypeOf(this);\n\n        if (!proto.hasOwnProperty('__hasRegisterFinished')) {\n          proto.__hasRegisterFinished = true;\n\n          this._registered();\n        }\n\n        _get(_getPrototypeOf(LegacyElement.prototype), \"_initializeProperties\", this).call(this);\n\n        this.root =\n        /** @type {HTMLElement} */\n        this;\n        this.created();\n      }\n      /**\n       * Called automatically when an element is initializing.\n       * Users may override this method to perform class registration time\n       * work. The implementation should ensure the work is performed\n       * only once for the class.\n       * @protected\n       * @return {void}\n       */\n\n    }, {\n      key: \"_registered\",\n      value: function _registered() {}\n      /**\n       * Overrides the default `Polymer.PropertyEffects` implementation to\n       * add support for installing `hostAttributes` and `listeners`.\n       *\n       * @return {void}\n       * @override\n       */\n\n    }, {\n      key: \"ready\",\n      value: function ready() {\n        this._ensureAttributes();\n\n        _get(_getPrototypeOf(LegacyElement.prototype), \"ready\", this).call(this);\n      }\n      /**\n       * Ensures an element has required attributes. Called when the element\n       * is being readied via `ready`. Users should override to set the\n       * element's required attributes. The implementation should be sure\n       * to check and not override existing attributes added by\n       * the user of the element. Typically, setting attributes should be left\n       * to the element user and not done here; reasonable exceptions include\n       * setting aria roles and focusability.\n       * @protected\n       * @return {void}\n       */\n\n    }, {\n      key: \"_ensureAttributes\",\n      value: function _ensureAttributes() {}\n      /**\n       * Adds element event listeners. Called when the element\n       * is being readied via `ready`. Users should override to\n       * add any required element event listeners.\n       * In performance critical elements, the work done here should be kept\n       * to a minimum since it is done before the element is rendered. In\n       * these elements, consider adding listeners asynchronously so as not to\n       * block render.\n       * @protected\n       * @return {void}\n       */\n\n    }, {\n      key: \"_applyListeners\",\n      value: function _applyListeners() {}\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features. To customize\n       * how properties are serialized to attributes for attribute bindings and\n       * `reflectToAttribute: true` properties as well as this method, override\n       * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.\n       *\n       * @param {*} value Value to deserialize\n       * @return {string | undefined} Serialized value\n       */\n\n    }, {\n      key: \"serialize\",\n      value: function serialize(value) {\n        return this._serializeValue(value);\n      }\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features.  To customize\n       * how attributes are deserialized to properties for in\n       * `attributeChangedCallback`, override `_deserializeValue` method\n       * provided by `Polymer.PropertyAccessors`.\n       *\n       * @param {string} value String to deserialize\n       * @param {*} type Type to deserialize the string to\n       * @return {*} Returns the deserialized value in the `type` given.\n       */\n\n    }, {\n      key: \"deserialize\",\n      value: function deserialize(value, type) {\n        return this._deserializeValue(value, type);\n      }\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect.\n       * @param {*=} value Property value to reflect.\n       * @return {void}\n       */\n\n    }, {\n      key: \"reflectPropertyToAttribute\",\n      value: function reflectPropertyToAttribute(property, attribute, value) {\n        this._propertyToAttribute(property, attribute, value);\n      }\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features.\n       *\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       * @param {Element} node Element to set attribute to.\n       * @return {void}\n       */\n\n    }, {\n      key: \"serializeValueToAttribute\",\n      value: function serializeValueToAttribute(value, attribute, node) {\n        this._valueToNodeAttribute(\n        /** @type {Element} */\n        node || this, value, attribute);\n      }\n      /**\n       * Copies own properties (including accessor descriptors) from a source\n       * object to a target object.\n       *\n       * @param {Object} prototype Target object to copy properties to.\n       * @param {Object} api Source object to copy properties from.\n       * @return {Object} prototype object that was passed as first argument.\n       */\n\n    }, {\n      key: \"extend\",\n      value: function extend(prototype, api) {\n        if (!(prototype && api)) {\n          return prototype || api;\n        }\n\n        var n$ = Object.getOwnPropertyNames(api);\n\n        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {\n          var pd = Object.getOwnPropertyDescriptor(api, n);\n\n          if (pd) {\n            Object.defineProperty(prototype, n, pd);\n          }\n        }\n\n        return prototype;\n      }\n      /**\n       * Copies props from a source object to a target object.\n       *\n       * Note, this method uses a simple `for...in` strategy for enumerating\n       * properties.  To ensure only `ownProperties` are copied from source\n       * to target and that accessor implementations are copied, use `extend`.\n       *\n       * @param {!Object} target Target object to copy properties to.\n       * @param {!Object} source Source object to copy properties from.\n       * @return {!Object} Target object that was passed as first argument.\n       */\n\n    }, {\n      key: \"mixin\",\n      value: function mixin(target, source) {\n        for (var i in source) {\n          target[i] = source[i];\n        }\n\n        return target;\n      }\n      /**\n       * Sets the prototype of an object.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features.\n       * @param {Object} object The object on which to set the prototype.\n       * @param {Object} prototype The prototype that will be set on the given\n       * `object`.\n       * @return {Object} Returns the given `object` with its prototype set\n       * to the given `prototype` object.\n       */\n\n    }, {\n      key: \"chainObject\",\n      value: function chainObject(object, prototype) {\n        if (object && prototype && object !== prototype) {\n          object.__proto__ = prototype;\n        }\n\n        return object;\n      }\n      /* **** Begin Template **** */\n\n      /**\n       * Calls `importNode` on the `content` of the `template` specified and\n       * returns a document fragment containing the imported content.\n       *\n       * @param {HTMLTemplateElement} template HTML template element to instance.\n       * @return {!DocumentFragment} Document fragment containing the imported\n       *   template content.\n      */\n\n    }, {\n      key: \"instanceTemplate\",\n      value: function instanceTemplate(template) {\n        var content = this.constructor._contentForTemplate(template);\n\n        var dom =\n        /** @type {!DocumentFragment} */\n        document.importNode(content, true);\n        return dom;\n      }\n      /* **** Begin Events **** */\n\n      /**\n       * Dispatches a custom event with an optional detail value.\n       *\n       * @param {string} type Name of event type.\n       * @param {*=} detail Detail value containing event-specific\n       *   payload.\n       * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}\n       *  options Object specifying options.  These may include:\n       *  `bubbles` (boolean, defaults to `true`),\n       *  `cancelable` (boolean, defaults to false), and\n       *  `node` on which to fire the event (HTMLElement, defaults to `this`).\n       * @return {!Event} The new event that was fired.\n       */\n\n    }, {\n      key: \"fire\",\n      value: function fire(type, detail, options) {\n        options = options || {};\n        detail = detail === null || detail === undefined ? {} : detail;\n        var event = new Event(type, {\n          bubbles: options.bubbles === undefined ? true : options.bubbles,\n          cancelable: Boolean(options.cancelable),\n          composed: options.composed === undefined ? true : options.composed\n        });\n        event.detail = detail;\n        var node = options.node || this;\n        node.dispatchEvent(event);\n        return event;\n      }\n      /**\n       * Convenience method to add an event listener on a given element,\n       * late bound to a named method on this element.\n       *\n       * @param {?EventTarget} node Element to add event listener to.\n       * @param {string} eventName Name of event to listen for.\n       * @param {string} methodName Name of handler method on `this` to call.\n       * @return {void}\n       */\n\n    }, {\n      key: \"listen\",\n      value: function listen(node, eventName, methodName) {\n        node =\n        /** @type {!EventTarget} */\n        node || this;\n        var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());\n        var bl = hbl.get(node);\n\n        if (!bl) {\n          bl = {};\n          hbl.set(node, bl);\n        }\n\n        var key = eventName + methodName;\n\n        if (!bl[key]) {\n          bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);\n        }\n      }\n      /**\n       * Convenience method to remove an event listener from a given element,\n       * late bound to a named method on this element.\n       *\n       * @param {?EventTarget} node Element to remove event listener from.\n       * @param {string} eventName Name of event to stop listening to.\n       * @param {string} methodName Name of handler method on `this` to not call\n       anymore.\n       * @return {void}\n       */\n\n    }, {\n      key: \"unlisten\",\n      value: function unlisten(node, eventName, methodName) {\n        node =\n        /** @type {!EventTarget} */\n        node || this;\n\n        var bl = this.__boundListeners && this.__boundListeners.get(node);\n\n        var key = eventName + methodName;\n        var handler = bl && bl[key];\n\n        if (handler) {\n          this._removeEventListenerFromNode(node, eventName, handler);\n\n          bl[key] = null;\n        }\n      }\n      /**\n       * Override scrolling behavior to all direction, one direction, or none.\n       *\n       * Valid scroll directions:\n       *   - 'all': scroll in any direction\n       *   - 'x': scroll only in the 'x' direction\n       *   - 'y': scroll only in the 'y' direction\n       *   - 'none': disable scrolling for this node\n       *\n       * @param {string=} direction Direction to allow scrolling\n       * Defaults to `all`.\n       * @param {Element=} node Element to apply scroll direction setting.\n       * Defaults to `this`.\n       * @return {void}\n       */\n\n    }, {\n      key: \"setScrollDirection\",\n      value: function setScrollDirection(direction, node) {\n        setTouchAction(\n        /** @type {Element} */\n        node || this, DIRECTION_MAP[direction] || 'auto');\n      }\n      /* **** End Events **** */\n\n      /**\n       * Convenience method to run `querySelector` on this local DOM scope.\n       *\n       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.\n       *\n       * @param {string} slctr Selector to run on this local DOM scope\n       * @return {Element} Element found by the selector, or null if not found.\n       */\n\n    }, {\n      key: \"$$\",\n      value: function $$(slctr) {\n        return this.root.querySelector(slctr);\n      }\n      /**\n       * Return the element whose local dom within which this element\n       * is contained. This is a shorthand for\n       * `this.getRootNode().host`.\n       * @this {Element}\n       */\n\n    }, {\n      key: \"distributeContent\",\n\n      /**\n       * Force this element to distribute its children to its local dom.\n       * This should not be necessary as of Polymer 2.0.2 and is provided only\n       * for backwards compatibility.\n       * @return {void}\n       */\n      value: function distributeContent() {\n        if (window.ShadyDOM && this.shadowRoot) {\n          ShadyDOM.flush();\n        }\n      }\n      /**\n       * Returns a list of nodes that are the effective childNodes. The effective\n       * childNodes list is the same as the element's childNodes except that\n       * any `<content>` elements are replaced with the list of nodes distributed\n       * to the `<content>`, the result of its `getDistributedNodes` method.\n       * @return {!Array<!Node>} List of effective child nodes.\n       * @suppress {invalidCasts} LegacyElementMixin must be applied to an HTMLElement\n       */\n\n    }, {\n      key: \"getEffectiveChildNodes\",\n      value: function getEffectiveChildNodes() {\n        var thisEl =\n        /** @type {Element} */\n        this;\n        var domApi =\n        /** @type {DomApi} */\n        dom(thisEl);\n        return domApi.getEffectiveChildNodes();\n      }\n      /**\n       * Returns a list of nodes distributed within this element that match\n       * `selector`. These can be dom children or elements distributed to\n       * children that are insertion points.\n       * @param {string} selector Selector to run.\n       * @return {!Array<!Node>} List of distributed elements that match selector.\n       * @suppress {invalidCasts} LegacyElementMixin must be applied to an HTMLElement\n       */\n\n    }, {\n      key: \"queryDistributedElements\",\n      value: function queryDistributedElements(selector) {\n        var thisEl =\n        /** @type {Element} */\n        this;\n        var domApi =\n        /** @type {DomApi} */\n        dom(thisEl);\n        return domApi.queryDistributedElements(selector);\n      }\n      /**\n       * Returns a list of elements that are the effective children. The effective\n       * children list is the same as the element's children except that\n       * any `<content>` elements are replaced with the list of elements\n       * distributed to the `<content>`.\n       *\n       * @return {!Array<!Node>} List of effective children.\n       */\n\n    }, {\n      key: \"getEffectiveChildren\",\n      value: function getEffectiveChildren() {\n        var list = this.getEffectiveChildNodes();\n        return list.filter(function (\n        /** @type {!Node} */\n        n) {\n          return n.nodeType === Node.ELEMENT_NODE;\n        });\n      }\n      /**\n       * Returns a string of text content that is the concatenation of the\n       * text content's of the element's effective childNodes (the elements\n       * returned by <a href=\"#getEffectiveChildNodes>getEffectiveChildNodes</a>.\n       *\n       * @return {string} List of effective children.\n       */\n\n    }, {\n      key: \"getEffectiveTextContent\",\n      value: function getEffectiveTextContent() {\n        var cn = this.getEffectiveChildNodes();\n        var tc = [];\n\n        for (var i = 0, c; c = cn[i]; i++) {\n          if (c.nodeType !== Node.COMMENT_NODE) {\n            tc.push(c.textContent);\n          }\n        }\n\n        return tc.join('');\n      }\n      /**\n       * Returns the first effective childNode within this element that\n       * match `selector`. These can be dom child nodes or elements distributed\n       * to children that are insertion points.\n       * @param {string} selector Selector to run.\n       * @return {Node} First effective child node that matches selector.\n       */\n\n    }, {\n      key: \"queryEffectiveChildren\",\n      value: function queryEffectiveChildren(selector) {\n        var e$ = this.queryDistributedElements(selector);\n        return e$ && e$[0];\n      }\n      /**\n       * Returns a list of effective childNodes within this element that\n       * match `selector`. These can be dom child nodes or elements distributed\n       * to children that are insertion points.\n       * @param {string} selector Selector to run.\n       * @return {!Array<!Node>} List of effective child nodes that match selector.\n       */\n\n    }, {\n      key: \"queryAllEffectiveChildren\",\n      value: function queryAllEffectiveChildren(selector) {\n        return this.queryDistributedElements(selector);\n      }\n      /**\n       * Returns a list of nodes distributed to this element's `<slot>`.\n       *\n       * If this element contains more than one `<slot>` in its local DOM,\n       * an optional selector may be passed to choose the desired content.\n       *\n       * @param {string=} slctr CSS selector to choose the desired\n       *   `<slot>`.  Defaults to `content`.\n       * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.\n       */\n\n    }, {\n      key: \"getContentChildNodes\",\n      value: function getContentChildNodes(slctr) {\n        var content = this.root.querySelector(slctr || 'slot');\n        return content ?\n        /** @type {DomApi} */\n        dom(content).getDistributedNodes() : [];\n      }\n      /**\n       * Returns a list of element children distributed to this element's\n       * `<slot>`.\n       *\n       * If this element contains more than one `<slot>` in its\n       * local DOM, an optional selector may be passed to choose the desired\n       * content.  This method differs from `getContentChildNodes` in that only\n       * elements are returned.\n       *\n       * @param {string=} slctr CSS selector to choose the desired\n       *   `<content>`.  Defaults to `content`.\n       * @return {!Array<!HTMLElement>} List of distributed nodes for the\n       *   `<slot>`.\n       * @suppress {invalidCasts}\n       */\n\n    }, {\n      key: \"getContentChildren\",\n      value: function getContentChildren(slctr) {\n        var children =\n        /** @type {!Array<!HTMLElement>} */\n        this.getContentChildNodes(slctr).filter(function (n) {\n          return n.nodeType === Node.ELEMENT_NODE;\n        });\n        return children;\n      }\n      /**\n       * Checks whether an element is in this element's light DOM tree.\n       *\n       * @param {?Node} node The element to be checked.\n       * @return {boolean} true if node is in this element's light DOM tree.\n       * @suppress {invalidCasts} LegacyElementMixin must be applied to an HTMLElement\n       */\n\n    }, {\n      key: \"isLightDescendant\",\n      value: function isLightDescendant(node) {\n        var thisNode =\n        /** @type {Node} */\n        this;\n        return thisNode !== node && thisNode.contains(node) && thisNode.getRootNode() === node.getRootNode();\n      }\n      /**\n       * Checks whether an element is in this element's local DOM tree.\n       *\n       * @param {!Element} node The element to be checked.\n       * @return {boolean} true if node is in this element's local DOM tree.\n       */\n\n    }, {\n      key: \"isLocalDescendant\",\n      value: function isLocalDescendant(node) {\n        return this.root === node.getRootNode();\n      }\n      /**\n       * No-op for backwards compatibility. This should now be handled by\n       * ShadyCss library.\n       * @param  {*} container Unused\n       * @param  {*} shouldObserve Unused\n       * @return {void}\n       */\n\n    }, {\n      key: \"scopeSubtree\",\n      value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars\n\n      /**\n       * Returns the computed style value for the given property.\n       * @param {string} property The css property name.\n       * @return {string} Returns the computed css property value for the given\n       * `property`.\n       * @suppress {invalidCasts} LegacyElementMixin must be applied to an HTMLElement\n       */\n\n    }, {\n      key: \"getComputedStyleValue\",\n      value: function getComputedStyleValue(property) {\n        return styleInterface.getComputedStyleValue(\n        /** @type {!Element} */\n        this, property);\n      } // debounce\n\n      /**\n       * Call `debounce` to collapse multiple requests for a named task into\n       * one invocation which is made after the wait time has elapsed with\n       * no new request.  If no wait time is given, the callback will be called\n       * at microtask timing (guaranteed before paint).\n       *\n       *     debouncedClickAction(e) {\n       *       // will not call `processClick` more than once per 100ms\n       *       this.debounce('click', function() {\n       *        this.processClick();\n       *       } 100);\n       *     }\n       *\n       * @param {string} jobName String to identify the debounce job.\n       * @param {function():void} callback Function that is called (with `this`\n       *   context) when the wait time elapses.\n       * @param {number} wait Optional wait time in milliseconds (ms) after the\n       *   last signal that must elapse before invoking `callback`\n       * @return {!Object} Returns a debouncer object on which exists the\n       * following methods: `isActive()` returns true if the debouncer is\n       * active; `cancel()` cancels the debouncer if it is active;\n       * `flush()` immediately invokes the debounced callback if the debouncer\n       * is active.\n       */\n\n    }, {\n      key: \"debounce\",\n      value: function debounce(jobName, callback, wait) {\n        this._debouncers = this._debouncers || {};\n        return this._debouncers[jobName] = Debouncer.debounce(this._debouncers[jobName], wait > 0 ? timeOut.after(wait) : microTask, callback.bind(this));\n      }\n      /**\n       * Returns whether a named debouncer is active.\n       *\n       * @param {string} jobName The name of the debouncer started with `debounce`\n       * @return {boolean} Whether the debouncer is active (has not yet fired).\n       */\n\n    }, {\n      key: \"isDebouncerActive\",\n      value: function isDebouncerActive(jobName) {\n        this._debouncers = this._debouncers || {};\n        var debouncer = this._debouncers[jobName];\n        return !!(debouncer && debouncer.isActive());\n      }\n      /**\n       * Immediately calls the debouncer `callback` and inactivates it.\n       *\n       * @param {string} jobName The name of the debouncer started with `debounce`\n       * @return {void}\n       */\n\n    }, {\n      key: \"flushDebouncer\",\n      value: function flushDebouncer(jobName) {\n        this._debouncers = this._debouncers || {};\n        var debouncer = this._debouncers[jobName];\n\n        if (debouncer) {\n          debouncer.flush();\n        }\n      }\n      /**\n       * Cancels an active debouncer.  The `callback` will not be called.\n       *\n       * @param {string} jobName The name of the debouncer started with `debounce`\n       * @return {void}\n       */\n\n    }, {\n      key: \"cancelDebouncer\",\n      value: function cancelDebouncer(jobName) {\n        this._debouncers = this._debouncers || {};\n        var debouncer = this._debouncers[jobName];\n\n        if (debouncer) {\n          debouncer.cancel();\n        }\n      }\n      /**\n       * Runs a callback function asynchronously.\n       *\n       * By default (if no waitTime is specified), async callbacks are run at\n       * microtask timing, which will occur before paint.\n       *\n       * @param {!Function} callback The callback function to run, bound to `this`.\n       * @param {number=} waitTime Time to wait before calling the\n       *   `callback`.  If unspecified or 0, the callback will be run at microtask\n       *   timing (before paint).\n       * @return {number} Handle that may be used to cancel the async job.\n       */\n\n    }, {\n      key: \"async\",\n      value: function async(callback, waitTime) {\n        return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) : ~microTask.run(callback.bind(this));\n      }\n      /**\n       * Cancels an async operation started with `async`.\n       *\n       * @param {number} handle Handle returned from original `async` call to\n       *   cancel.\n       * @return {void}\n       */\n\n    }, {\n      key: \"cancelAsync\",\n      value: function cancelAsync(handle) {\n        handle < 0 ? microTask.cancel(~handle) : timeOut.cancel(handle);\n      } // other\n\n      /**\n       * Convenience method for creating an element and configuring it.\n       *\n       * @param {string} tag HTML element tag to create.\n       * @param {Object=} props Object of properties to configure on the\n       *    instance.\n       * @return {!Element} Newly created and configured element.\n       */\n\n    }, {\n      key: \"create\",\n      value: function create(tag, props) {\n        var elt = document.createElement(tag);\n\n        if (props) {\n          if (elt.setProperties) {\n            elt.setProperties(props);\n          } else {\n            for (var n in props) {\n              elt[n] = props[n];\n            }\n          }\n        }\n\n        return elt;\n      }\n      /**\n       * Polyfill for Element.prototype.matches, which is sometimes still\n       * prefixed.\n       *\n       * @param {string} selector Selector to test.\n       * @param {!Element=} node Element to test the selector against.\n       * @return {boolean} Whether the element matches the selector.\n       */\n\n    }, {\n      key: \"elementMatches\",\n      value: function elementMatches(selector, node) {\n        return matchesSelector(node || this, selector);\n      }\n      /**\n       * Toggles an HTML attribute on or off.\n       *\n       * @param {string} name HTML attribute name\n       * @param {boolean=} bool Boolean to force the attribute on or off.\n       *    When unspecified, the state of the attribute will be reversed.\n       * @return {boolean} true if the attribute now exists\n       */\n\n    }, {\n      key: \"toggleAttribute\",\n      value: function toggleAttribute(name, bool) {\n        var node =\n        /** @type {Element} */\n        this;\n\n        if (arguments.length === 3) {\n          node =\n          /** @type {Element} */\n          arguments[2];\n        }\n\n        if (arguments.length == 1) {\n          bool = !node.hasAttribute(name);\n        }\n\n        if (bool) {\n          node.setAttribute(name, '');\n          return true;\n        } else {\n          node.removeAttribute(name);\n          return false;\n        }\n      }\n      /**\n       * Toggles a CSS class on or off.\n       *\n       * @param {string} name CSS class name\n       * @param {boolean=} bool Boolean to force the class on or off.\n       *    When unspecified, the state of the class will be reversed.\n       * @param {Element=} node Node to target.  Defaults to `this`.\n       * @return {void}\n       */\n\n    }, {\n      key: \"toggleClass\",\n      value: function toggleClass(name, bool, node) {\n        node =\n        /** @type {Element} */\n        node || this;\n\n        if (arguments.length == 1) {\n          bool = !node.classList.contains(name);\n        }\n\n        if (bool) {\n          node.classList.add(name);\n        } else {\n          node.classList.remove(name);\n        }\n      }\n      /**\n       * Cross-platform helper for setting an element's CSS `transform` property.\n       *\n       * @param {string} transformText Transform setting.\n       * @param {Element=} node Element to apply the transform to.\n       * Defaults to `this`\n       * @return {void}\n       */\n\n    }, {\n      key: \"transform\",\n      value: function transform(transformText, node) {\n        node =\n        /** @type {Element} */\n        node || this;\n        node.style.webkitTransform = transformText;\n        node.style.transform = transformText;\n      }\n      /**\n       * Cross-platform helper for setting an element's CSS `translate3d`\n       * property.\n       *\n       * @param {number} x X offset.\n       * @param {number} y Y offset.\n       * @param {number} z Z offset.\n       * @param {Element=} node Element to apply the transform to.\n       * Defaults to `this`.\n       * @return {void}\n       */\n\n    }, {\n      key: \"translate3d\",\n      value: function translate3d(x, y, z, node) {\n        node =\n        /** @type {Element} */\n        node || this;\n        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n      }\n      /**\n       * Removes an item from an array, if it exists.\n       *\n       * If the array is specified by path, a change notification is\n       * generated, so that observers, data bindings and computed\n       * properties watching that path can update.\n       *\n       * If the array is passed directly, **no change\n       * notification is generated**.\n       *\n       * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item\n       *   (or the array itself).\n       * @param {*} item Item to remove.\n       * @return {Array} Array containing item removed.\n       */\n\n    }, {\n      key: \"arrayDelete\",\n      value: function arrayDelete(arrayOrPath, item) {\n        var index;\n\n        if (Array.isArray(arrayOrPath)) {\n          index = arrayOrPath.indexOf(item);\n\n          if (index >= 0) {\n            return arrayOrPath.splice(index, 1);\n          }\n        } else {\n          var arr = get(this, arrayOrPath);\n          index = arr.indexOf(item);\n\n          if (index >= 0) {\n            return this.splice(arrayOrPath, index, 1);\n          }\n        }\n\n        return null;\n      } // logging\n\n      /**\n       * Facades `console.log`/`warn`/`error` as override point.\n       *\n       * @param {string} level One of 'log', 'warn', 'error'\n       * @param {Array} args Array of strings or objects to log\n       * @return {void}\n       */\n\n    }, {\n      key: \"_logger\",\n      value: function _logger(level, args) {\n        var _console;\n\n        // accept ['foo', 'bar'] and [['foo', 'bar']]\n        if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {\n          args = args[0];\n        }\n\n        switch (level) {\n          case 'log':\n          case 'warn':\n          case 'error':\n            (_console = console)[level].apply(_console, _toConsumableArray(args));\n\n        }\n      }\n      /**\n       * Facades `console.log` as an override point.\n       *\n       * @param {...*} args Array of strings or objects to log\n       * @return {void}\n       */\n\n    }, {\n      key: \"_log\",\n      value: function _log() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        this._logger('log', args);\n      }\n      /**\n       * Facades `console.warn` as an override point.\n       *\n       * @param {...*} args Array of strings or objects to log\n       * @return {void}\n       */\n\n    }, {\n      key: \"_warn\",\n      value: function _warn() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        this._logger('warn', args);\n      }\n      /**\n       * Facades `console.error` as an override point.\n       *\n       * @param {...*} args Array of strings or objects to log\n       * @return {void}\n       */\n\n    }, {\n      key: \"_error\",\n      value: function _error() {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        this._logger('error', args);\n      }\n      /**\n       * Formats a message using the element type an a method name.\n       *\n       * @param {string} methodName Method name to associate with message\n       * @param {...*} args Array of strings or objects to log\n       * @return {Array} Array with formatting information for `console`\n       *   logging.\n       */\n\n    }, {\n      key: \"_logf\",\n      value: function _logf(methodName) {\n        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n\n        return ['[%s::%s]', this.is, methodName].concat(args);\n      }\n    }, {\n      key: \"domHost\",\n      get: function get() {\n        var root = this.getRootNode();\n        return root instanceof DocumentFragment ?\n        /** @type {ShadowRoot} */\n        root.host : root;\n      }\n    }], [{\n      key: \"importMeta\",\n      get: function get() {\n        return this.prototype.importMeta;\n      }\n    }]);\n\n    return LegacyElement;\n  }(legacyElementBase);\n\n  LegacyElement.prototype.is = '';\n  return LegacyElement;\n});","map":null,"metadata":{},"sourceType":"module"}