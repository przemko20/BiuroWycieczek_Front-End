{"ast":null,"code":"import _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\n\n/**\n * A private mixin to avoid problems with dynamic properties and Polymer Analyzer.\n * No need to expose these properties in the API docs.\n * @polymerMixin\n */\nvar TabIndexMixin = function TabIndexMixin(superClass) {\n  return (\n    /*#__PURE__*/\n    function (_superClass) {\n      _inherits(VaadinTabIndexMixin, _superClass);\n\n      function VaadinTabIndexMixin() {\n        _classCallCheck(this, VaadinTabIndexMixin);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(VaadinTabIndexMixin).apply(this, arguments));\n      }\n\n      _createClass(VaadinTabIndexMixin, null, [{\n        key: \"properties\",\n        get: function get() {\n          var properties = {\n            /**\n             * Internal property needed to listen to `tabindex` attribute changes.\n             *\n             * For changing the tabindex of this component use the native `tabIndex` property.\n             * @private\n             */\n            tabindex: {\n              type: Number,\n              value: 0,\n              reflectToAttribute: true,\n              observer: '_tabindexChanged'\n            }\n          };\n\n          if (window.ShadyDOM) {\n            // ShadyDOM browsers need the `tabIndex` in order to notify when the user changes it programmatically.\n            properties['tabIndex'] = properties.tabindex;\n          }\n\n          return properties;\n        }\n      }]);\n\n      return VaadinTabIndexMixin;\n    }(superClass)\n  );\n};\n/**\n * Polymer.IronControlState is not a proper 2.0 class, also, its tabindex\n * implementation fails in the shadow dom, so we have this for vaadin elements.\n * @polymerMixin\n */\n\n\nexport var ControlStateMixin = function ControlStateMixin(superClass) {\n  return (\n    /*#__PURE__*/\n    function (_TabIndexMixin) {\n      _inherits(VaadinControlStateMixin, _TabIndexMixin);\n\n      function VaadinControlStateMixin() {\n        _classCallCheck(this, VaadinControlStateMixin);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(VaadinControlStateMixin).apply(this, arguments));\n      }\n\n      _createClass(VaadinControlStateMixin, [{\n        key: \"ready\",\n        value: function ready() {\n          var _this = this;\n\n          this.addEventListener('focusin', function (e) {\n            if (e.composedPath()[0] === _this) {\n              _this._focus(e);\n            } else if (e.composedPath().indexOf(_this.focusElement) !== -1 && !_this.disabled) {\n              _this._setFocused(true);\n            }\n          });\n          this.addEventListener('focusout', function (e) {\n            return _this._setFocused(false);\n          }); // In super.ready() other 'focusin' and 'focusout' listeners might be\n          // added, so we call it after our own ones to ensure they execute first.\n          // Issue to watch out: when incorrect, <vaadin-combo-box> refocuses the\n          // input field on iOS after “Done” is pressed.\n\n          _get(_getPrototypeOf(VaadinControlStateMixin.prototype), \"ready\", this).call(this); // This fixes the bug in Firefox 61 (https://bugzilla.mozilla.org/show_bug.cgi?id=1472887)\n          // where focusout event does not go out of shady DOM because composed property in the event is not true\n\n\n          var ensureEventComposed = function ensureEventComposed(e) {\n            if (!e.composed) {\n              e.target.dispatchEvent(new CustomEvent(e.type, {\n                bubbles: true,\n                composed: true,\n                cancelable: false\n              }));\n            }\n          };\n\n          this.shadowRoot.addEventListener('focusin', ensureEventComposed);\n          this.shadowRoot.addEventListener('focusout', ensureEventComposed);\n          this.addEventListener('keydown', function (e) {\n            if (!e.defaultPrevented && e.shiftKey && e.keyCode === 9) {\n              // Flag is checked in _focus event handler.\n              _this._isShiftTabbing = true;\n              HTMLElement.prototype.focus.apply(_this);\n\n              _this._setFocused(false); // Event handling in IE is asynchronous and the flag is removed asynchronously as well\n\n\n              setTimeout(function () {\n                return _this._isShiftTabbing = false;\n              }, 0);\n            }\n          });\n\n          if (this.autofocus && !this.focused && !this.disabled) {\n            window.requestAnimationFrame(function () {\n              _this._focus();\n\n              _this._setFocused(true);\n\n              _this.setAttribute('focus-ring', '');\n            });\n          }\n\n          this._boundKeydownListener = this._bodyKeydownListener.bind(this);\n          this._boundKeyupListener = this._bodyKeyupListener.bind(this);\n        }\n        /**\n         * @protected\n         */\n\n      }, {\n        key: \"connectedCallback\",\n        value: function connectedCallback() {\n          _get(_getPrototypeOf(VaadinControlStateMixin.prototype), \"connectedCallback\", this).call(this);\n\n          document.body.addEventListener('keydown', this._boundKeydownListener, true);\n          document.body.addEventListener('keyup', this._boundKeyupListener, true);\n        }\n        /**\n         * @protected\n         */\n\n      }, {\n        key: \"disconnectedCallback\",\n        value: function disconnectedCallback() {\n          _get(_getPrototypeOf(VaadinControlStateMixin.prototype), \"disconnectedCallback\", this).call(this);\n\n          document.body.removeEventListener('keydown', this._boundKeydownListener, true);\n          document.body.removeEventListener('keyup', this._boundKeyupListener, true); // in non-Chrome browsers, blur does not fire on the element when it is disconnected.\n          // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.\n\n          if (this.hasAttribute('focused')) {\n            this._setFocused(false);\n          }\n        }\n      }, {\n        key: \"_setFocused\",\n        value: function _setFocused(focused) {\n          if (focused) {\n            this.setAttribute('focused', '');\n          } else {\n            this.removeAttribute('focused');\n          } // focus-ring is true when the element was focused from the keyboard.\n          // Focus Ring [A11ycasts]: https://youtu.be/ilj2P5-5CjI\n\n\n          if (focused && this._tabPressed) {\n            this.setAttribute('focus-ring', '');\n          } else {\n            this.removeAttribute('focus-ring');\n          }\n        }\n      }, {\n        key: \"_bodyKeydownListener\",\n        value: function _bodyKeydownListener(e) {\n          this._tabPressed = e.keyCode === 9;\n        }\n      }, {\n        key: \"_bodyKeyupListener\",\n        value: function _bodyKeyupListener() {\n          this._tabPressed = false;\n        }\n        /**\n         * Any element extending this mixin is required to implement this getter.\n         * It returns the actual focusable element in the component.\n         */\n\n      }, {\n        key: \"_focus\",\n        value: function _focus(e) {\n          if (this._isShiftTabbing) {\n            return;\n          }\n\n          this.focusElement.focus();\n\n          this._setFocused(true);\n        }\n        /**\n         * Moving the focus from the host element causes firing of the blur event what leads to problems in IE.\n         * @private\n         */\n\n      }, {\n        key: \"focus\",\n        value: function focus() {\n          if (!this.focusElement || this.disabled) {\n            return;\n          }\n\n          this.focusElement.focus();\n\n          this._setFocused(true);\n        }\n        /**\n         * Native bluring in the host element does nothing because it does not have the focus.\n         * In chrome it works, but not in FF.\n         * @private\n         */\n\n      }, {\n        key: \"blur\",\n        value: function blur() {\n          this.focusElement.blur();\n\n          this._setFocused(false);\n        }\n      }, {\n        key: \"_disabledChanged\",\n        value: function _disabledChanged(disabled) {\n          this.focusElement.disabled = disabled;\n\n          if (disabled) {\n            this.blur();\n            this._previousTabIndex = this.tabindex;\n            this.tabindex = -1;\n            this.setAttribute('aria-disabled', 'true');\n          } else {\n            if (typeof this._previousTabIndex !== 'undefined') {\n              this.tabindex = this._previousTabIndex;\n            }\n\n            this.removeAttribute('aria-disabled');\n          }\n        }\n      }, {\n        key: \"_tabindexChanged\",\n        value: function _tabindexChanged(tabindex) {\n          if (tabindex !== undefined) {\n            this.focusElement.tabIndex = tabindex;\n          }\n\n          if (this.disabled && this.tabindex) {\n            // If tabindex attribute was changed while checkbox was disabled\n            if (this.tabindex !== -1) {\n              this._previousTabIndex = this.tabindex;\n            }\n\n            this.tabindex = tabindex = undefined;\n          }\n\n          if (window.ShadyDOM) {\n            this.setProperties({\n              tabIndex: tabindex,\n              tabindex: tabindex\n            });\n          }\n        }\n      }, {\n        key: \"focusElement\",\n        get: function get() {\n          window.console.warn(\"Please implement the 'focusElement' property in <\".concat(this.localName, \">\"));\n          return this;\n        }\n      }], [{\n        key: \"properties\",\n        get: function get() {\n          return {\n            /**\n             * Specify that this control should have input focus when the page loads.\n             */\n            autofocus: {\n              type: Boolean\n            },\n\n            /**\n             * Stores the previous value of tabindex attribute of the disabled element\n             */\n            _previousTabIndex: {\n              type: Number\n            },\n\n            /**\n             * If true, the user cannot interact with this element.\n             */\n            disabled: {\n              type: Boolean,\n              observer: '_disabledChanged',\n              reflectToAttribute: true\n            },\n            _isShiftTabbing: {\n              type: Boolean\n            }\n          };\n        }\n      }]);\n\n      return VaadinControlStateMixin;\n    }(TabIndexMixin(superClass))\n  );\n};","map":null,"metadata":{},"sourceType":"module"}