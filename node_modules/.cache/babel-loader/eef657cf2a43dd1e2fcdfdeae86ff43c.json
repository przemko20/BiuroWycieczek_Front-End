{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { templatize } from '../utils/templatize.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\n\nexport var DomIf =\n/*#__PURE__*/\nfunction (_PolymerElement) {\n  _inherits(DomIf, _PolymerElement);\n\n  _createClass(DomIf, null, [{\n    key: \"is\",\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    get: function get() {\n      return 'dom-if';\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * Fired whenever DOM is added or removed/hidden by this template (by\n         * default, rendering occurs lazily).  To force immediate rendering, call\n         * `render`.\n         *\n         * @event dom-change\n         */\n\n        /**\n         * A boolean indicating whether this template should stamp.\n         */\n        if: {\n          type: Boolean,\n          observer: '__debounceRender'\n        },\n\n        /**\n         * When true, elements will be removed from DOM and discarded when `if`\n         * becomes false and re-created and added back to the DOM when `if`\n         * becomes true.  By default, stamped elements will be hidden but left\n         * in the DOM when `if` becomes false, which is generally results\n         * in better performance.\n         */\n        restamp: {\n          type: Boolean,\n          observer: '__debounceRender'\n        }\n      };\n    }\n  }]);\n\n  function DomIf() {\n    var _this;\n\n    _classCallCheck(this, DomIf);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DomIf).call(this));\n    _this.__renderDebouncer = null;\n    _this.__invalidProps = null;\n    _this.__instance = null;\n    _this._lastIf = false;\n    _this.__ctor = null;\n    _this.__hideTemplateChildren__ = false;\n    return _this;\n  }\n\n  _createClass(DomIf, [{\n    key: \"__debounceRender\",\n    value: function __debounceRender() {\n      var _this2 = this;\n\n      // Render is async for 2 reasons:\n      // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n      //    same turn. This was more common in 1.x where a compound computed\n      //    property could result in the result changing multiple times, but is\n      //    mitigated to a large extent by batched property processing in 2.x.\n      // 2. To avoid double object propagation when a bag including values bound\n      //    to the `if` property as well as one or more hostProps could enqueue\n      //    the <dom-if> to flush before the <template>'s host property\n      //    forwarding. In that scenario creating an instance would result in\n      //    the host props being set once, and then the enqueued changes on the\n      //    template would set properties a second time, potentially causing an\n      //    object to be set to an instance more than once.  Creating the\n      //    instance async from flushing data ensures this doesn't happen. If\n      //    we wanted a sync option in the future, simply having <dom-if> flush\n      //    (or clear) its template's pending host properties before creating\n      //    the instance would also avoid the problem.\n      this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, microTask, function () {\n        return _this2.__render();\n      });\n      enqueueDebouncer(this.__renderDebouncer);\n    }\n    /**\n     * @override\n     * @return {void}\n     */\n\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(DomIf.prototype), \"disconnectedCallback\", this).call(this);\n\n      if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {\n        this.__teardownInstance();\n      }\n    }\n    /**\n     * @override\n     * @return {void}\n     */\n\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(DomIf.prototype), \"connectedCallback\", this).call(this);\n\n      this.style.display = 'none';\n\n      if (this.if) {\n        this.__debounceRender();\n      }\n    }\n    /**\n     * Forces the element to render its content. Normally rendering is\n     * asynchronous to a provoking change. This is done for efficiency so\n     * that multiple changes trigger only a single render. The render method\n     * should be called if, for example, template rendering is required to\n     * validate application state.\n     * @return {void}\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      flush();\n    }\n  }, {\n    key: \"__render\",\n    value: function __render() {\n      if (this.if) {\n        if (!this.__ensureInstance()) {\n          // No template found yet\n          return;\n        }\n\n        this._showHideChildren();\n      } else if (this.restamp) {\n        this.__teardownInstance();\n      }\n\n      if (!this.restamp && this.__instance) {\n        this._showHideChildren();\n      }\n\n      if (this.if != this._lastIf) {\n        this.dispatchEvent(new CustomEvent('dom-change', {\n          bubbles: true,\n          composed: true\n        }));\n        this._lastIf = this.if;\n      }\n    }\n  }, {\n    key: \"__ensureInstance\",\n    value: function __ensureInstance() {\n      var _this3 = this;\n\n      var parentNode = this.parentNode; // Guard against element being detached while render was queued\n\n      if (parentNode) {\n        if (!this.__ctor) {\n          var template =\n          /** @type {HTMLTemplateElement} */\n          this.querySelector('template');\n\n          if (!template) {\n            // Wait until childList changes and template should be there by then\n            var observer = new MutationObserver(function () {\n              if (_this3.querySelector('template')) {\n                observer.disconnect();\n\n                _this3.__render();\n              } else {\n                throw new Error('dom-if requires a <template> child');\n              }\n            });\n            observer.observe(this, {\n              childList: true\n            });\n            return false;\n          }\n\n          this.__ctor = templatize(template, this, {\n            // dom-if templatizer instances require `mutable: true`, as\n            // `__syncHostProperties` relies on that behavior to sync objects\n            mutableData: true,\n\n            /**\n             * @param {string} prop Property to forward\n             * @param {*} value Value of property\n             * @this {DomIf}\n             */\n            forwardHostProp: function forwardHostProp(prop, value) {\n              if (this.__instance) {\n                if (this.if) {\n                  this.__instance.forwardHostProp(prop, value);\n                } else {\n                  // If we have an instance but are squelching host property\n                  // forwarding due to if being false, note the invalidated\n                  // properties so `__syncHostProperties` can sync them the next\n                  // time `if` becomes true\n                  this.__invalidProps = this.__invalidProps || Object.create(null);\n                  this.__invalidProps[root(prop)] = true;\n                }\n              }\n            }\n          });\n        }\n\n        if (!this.__instance) {\n          this.__instance = new this.__ctor();\n          parentNode.insertBefore(this.__instance.root, this);\n        } else {\n          this.__syncHostProperties();\n\n          var c$ = this.__instance.children;\n\n          if (c$ && c$.length) {\n            // Detect case where dom-if was re-attached in new position\n            var lastChild = this.previousSibling;\n\n            if (lastChild !== c$[c$.length - 1]) {\n              for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\n                parentNode.insertBefore(n, this);\n              }\n            }\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"__syncHostProperties\",\n    value: function __syncHostProperties() {\n      var props = this.__invalidProps;\n\n      if (props) {\n        for (var prop in props) {\n          this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n        }\n\n        this.__invalidProps = null;\n\n        this.__instance._flushProperties();\n      }\n    }\n  }, {\n    key: \"__teardownInstance\",\n    value: function __teardownInstance() {\n      if (this.__instance) {\n        var c$ = this.__instance.children;\n\n        if (c$ && c$.length) {\n          // use first child parent, for case when dom-if may have been detached\n          var parent = c$[0].parentNode; // Instance children may be disconnected from parents when dom-if\n          // detaches if a tree was innerHTML'ed\n\n          if (parent) {\n            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\n              parent.removeChild(n);\n            }\n          }\n        }\n\n        this.__instance = null;\n        this.__invalidProps = null;\n      }\n    }\n    /**\n     * Shows or hides the template instance top level child elements. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     * @return {void}\n     * @protected\n     * @suppress {visibility}\n     */\n\n  }, {\n    key: \"_showHideChildren\",\n    value: function _showHideChildren() {\n      var hidden = this.__hideTemplateChildren__ || !this.if;\n\n      if (this.__instance) {\n        this.__instance._showHideChildren(hidden);\n      }\n    }\n  }]);\n\n  return DomIf;\n}(PolymerElement);\ncustomElements.define(DomIf.is, DomIf);","map":null,"metadata":{},"sourceType":"module"}