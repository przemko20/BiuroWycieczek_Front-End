{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\CTO-EC\\\\Desktop\\\\Programowanie\\\\Web\\xF3wka\\\\React\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { IronA11yKeysBehavior } from '@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { DatePickerHelper } from './vaadin-date-picker-helper.js';\nimport { addListener } from '@polymer/polymer/lib/utils/gestures.js';\nimport { mixinBehaviors } from '@polymer/polymer/lib/legacy/class.js';\n/**\n * @polymerMixin\n */\n\nexport var DatePickerMixin = function DatePickerMixin(subclass) {\n  return (\n    /*#__PURE__*/\n    function (_mixinBehaviors) {\n      _inherits(VaadinDatePickerMixin, _mixinBehaviors);\n\n      function VaadinDatePickerMixin() {\n        _classCallCheck(this, VaadinDatePickerMixin);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(VaadinDatePickerMixin).apply(this, arguments));\n      }\n\n      _createClass(VaadinDatePickerMixin, [{\n        key: \"ready\",\n        value: function ready() {\n          var _this = this;\n\n          _get(_getPrototypeOf(VaadinDatePickerMixin.prototype), \"ready\", this).call(this);\n\n          this._boundOnScroll = this._onScroll.bind(this);\n          this._boundFocus = this._focus.bind(this);\n          this._boundUpdateAlignmentAndPosition = this._updateAlignmentAndPosition.bind(this);\n          addListener(this, 'tap', this.open);\n          this.addEventListener('touchend', this._preventDefault.bind(this));\n          this.addEventListener('keydown', this._onKeydown.bind(this));\n\n          this._overlayContent.addEventListener('close', this._close.bind(this));\n\n          this._overlayContent.addEventListener('focus-input', this._focusAndSelect.bind(this));\n\n          this.addEventListener('input', this._onUserInput.bind(this));\n          this.addEventListener('focus', function (e) {\n            return _this._noInput && e.target.blur();\n          });\n        }\n        /**\n         * @protected\n         */\n\n      }, {\n        key: \"connectedCallback\",\n        value: function connectedCallback() {\n          _get(_getPrototypeOf(VaadinDatePickerMixin.prototype), \"connectedCallback\", this).call(this);\n\n          this.$.overlay.addEventListener('vaadin-overlay-escape-press', this._boundFocus);\n        }\n        /**\n         * @protected\n         */\n\n      }, {\n        key: \"disconnectedCallback\",\n        value: function disconnectedCallback() {\n          _get(_getPrototypeOf(VaadinDatePickerMixin.prototype), \"disconnectedCallback\", this).call(this);\n\n          this.$.overlay.removeEventListener('vaadin-overlay-escape-press', this._boundFocus);\n          this.opened = false;\n        }\n        /**\n         * Opens the dropdown.\n         */\n\n      }, {\n        key: \"open\",\n        value: function open() {\n          if (!this.disabled && !this.readonly) {\n            this.$.overlay.opened = true;\n          }\n        }\n      }, {\n        key: \"_close\",\n        value: function _close(e) {\n          if (e) {\n            e.stopPropagation();\n          }\n\n          this._focus();\n\n          this.close();\n        }\n        /**\n         * Closes the dropdown.\n         */\n\n      }, {\n        key: \"close\",\n        value: function close() {\n          this.$.overlay.close();\n        }\n      }, {\n        key: \"_parseDate\",\n        value: function _parseDate(str) {\n          // Parsing with RegExp to ensure correct format\n          var parts = /^([-+]\\d{1}|\\d{2,4}|[-+]\\d{6})-(\\d{1,2})-(\\d{1,2})$/.exec(str);\n\n          if (!parts) {\n            return;\n          }\n\n          var date = new Date(0, 0); // Wrong date (1900-01-01), but with midnight in local time\n\n          date.setFullYear(parseInt(parts[1], 10));\n          date.setMonth(parseInt(parts[2], 10) - 1);\n          date.setDate(parseInt(parts[3], 10));\n          return date;\n        }\n      }, {\n        key: \"_isNoInput\",\n        value: function _isNoInput(fullscreen, ios, i18n) {\n          return !this._inputElement || fullscreen || ios || !i18n.parseDate;\n        }\n      }, {\n        key: \"_formatISO\",\n        value: function _formatISO(date) {\n          if (!(date instanceof Date)) {\n            return '';\n          }\n\n          var pad = function pad(num) {\n            var fmt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '00';\n            return (fmt + num).substr((fmt + num).length - fmt.length);\n          };\n\n          var yearSign = '';\n          var yearFmt = '0000';\n          var yearAbs = date.getFullYear();\n\n          if (yearAbs < 0) {\n            yearAbs = -yearAbs;\n            yearSign = '-';\n            yearFmt = '000000';\n          } else if (date.getFullYear() >= 10000) {\n            yearSign = '+';\n            yearFmt = '000000';\n          }\n\n          var year = yearSign + pad(yearAbs, yearFmt);\n          var month = pad(date.getMonth() + 1);\n          var day = pad(date.getDate());\n          return [year, month, day].join('-');\n        }\n      }, {\n        key: \"_openedChanged\",\n        value: function _openedChanged(opened) {\n          if (!opened) {\n            return;\n          }\n\n          this._updateAlignmentAndPosition();\n        }\n      }, {\n        key: \"_selectedDateChanged\",\n        value: function _selectedDateChanged(selectedDate, formatDate) {\n          if (selectedDate === undefined || formatDate === undefined) {\n            return;\n          }\n\n          if (this.__userInputOccurred) {\n            this.__dispatchChange = true;\n          }\n\n          var inputValue = selectedDate && formatDate(DatePickerHelper._extractDateParts(selectedDate));\n\n          var value = this._formatISO(selectedDate);\n\n          if (value !== this.value) {\n            this.validate(inputValue);\n            this.value = value;\n          }\n\n          this.__userInputOccurred = false;\n          this.__dispatchChange = false;\n          this._focusedDate = selectedDate;\n          this._inputValue = selectedDate ? inputValue : '';\n        }\n      }, {\n        key: \"_focusedDateChanged\",\n        value: function _focusedDateChanged(focusedDate, formatDate) {\n          if (focusedDate === undefined || formatDate === undefined) {\n            return;\n          }\n\n          this.__userInputOccurred = true;\n\n          if (!this._ignoreFocusedDateChange && !this._noInput) {\n            this._inputValue = focusedDate ? formatDate(DatePickerHelper._extractDateParts(focusedDate)) : '';\n          }\n        }\n      }, {\n        key: \"_updateHasValue\",\n        value: function _updateHasValue(value) {\n          if (value) {\n            this.setAttribute('has-value', '');\n          } else {\n            this.removeAttribute('has-value');\n          }\n        }\n      }, {\n        key: \"_handleDateChange\",\n        value: function _handleDateChange(property, value, oldValue) {\n          if (!value) {\n            this[property] = '';\n            return;\n          }\n\n          var date = this._parseDate(value);\n\n          if (!date) {\n            this.value = oldValue;\n            return;\n          }\n\n          if (!DatePickerHelper._dateEquals(this[property], date)) {\n            this[property] = date;\n          }\n        }\n      }, {\n        key: \"_valueChanged\",\n        value: function _valueChanged(value, oldValue) {\n          if (this.__dispatchChange) {\n            this.dispatchEvent(new CustomEvent('change', {\n              bubbles: true\n            }));\n          }\n\n          this._handleDateChange('_selectedDate', value, oldValue);\n        }\n      }, {\n        key: \"_minChanged\",\n        value: function _minChanged(value, oldValue) {\n          this._handleDateChange('_minDate', value, oldValue);\n        }\n      }, {\n        key: \"_maxChanged\",\n        value: function _maxChanged(value, oldValue) {\n          this._handleDateChange('_maxDate', value, oldValue);\n        }\n      }, {\n        key: \"_updateAlignmentAndPosition\",\n        value: function _updateAlignmentAndPosition() {\n          if (!this._fullscreen) {\n            var inputRect = this._inputElement.getBoundingClientRect();\n\n            var bottomAlign = inputRect.top > window.innerHeight / 2;\n            var rightAlign = inputRect.left + this.clientWidth / 2 > window.innerWidth / 2;\n\n            if (rightAlign) {\n              var viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n              this.$.overlay.setAttribute('right-aligned', '');\n              this.$.overlay.style.removeProperty('left');\n              this.$.overlay.style.right = viewportWidth - inputRect.right + 'px';\n            } else {\n              this.$.overlay.removeAttribute('right-aligned');\n              this.$.overlay.style.removeProperty('right');\n              this.$.overlay.style.left = inputRect.left + 'px';\n            }\n\n            if (bottomAlign) {\n              var viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n              this.$.overlay.setAttribute('bottom-aligned', '');\n              this.$.overlay.style.removeProperty('top');\n              this.$.overlay.style.bottom = viewportHeight - inputRect.top + 'px';\n            } else {\n              this.$.overlay.removeAttribute('bottom-aligned');\n              this.$.overlay.style.removeProperty('bottom');\n              this.$.overlay.style.top = inputRect.bottom + 'px';\n            }\n          }\n\n          this.$.overlay.setAttribute('dir', getComputedStyle(this._inputElement).getPropertyValue('direction'));\n\n          this._overlayContent._repositionYearScroller();\n        }\n      }, {\n        key: \"_fullscreenChanged\",\n        value: function _fullscreenChanged() {\n          if (this.$.overlay.opened) {\n            this._updateAlignmentAndPosition();\n          }\n        }\n      }, {\n        key: \"_onOverlayOpened\",\n        value: function _onOverlayOpened() {\n          this._openedWithFocusRing = this.hasAttribute('focus-ring') || this.focusElement && this.focusElement.hasAttribute('focus-ring');\n\n          var parsedInitialPosition = this._parseDate(this.initialPosition);\n\n          var initialPosition = this._selectedDate || this._overlayContent.initialPosition || parsedInitialPosition || new Date();\n\n          if (parsedInitialPosition || DatePickerHelper._dateAllowed(initialPosition, this._minDate, this._maxDate)) {\n            this._overlayContent.initialPosition = initialPosition;\n          } else {\n            this._overlayContent.initialPosition = DatePickerHelper._getClosestDate(initialPosition, [this._minDate, this._maxDate]);\n          }\n\n          this._overlayContent.scrollToDate(this._overlayContent.focusedDate || this._overlayContent.initialPosition); // Have a default focused date\n\n\n          this._ignoreFocusedDateChange = true;\n          this._overlayContent.focusedDate = this._overlayContent.focusedDate || this._overlayContent.initialPosition;\n          this._ignoreFocusedDateChange = false;\n          window.addEventListener('scroll', this._boundOnScroll, true);\n          this.addEventListener('iron-resize', this._boundUpdateAlignmentAndPosition);\n\n          if (this._webkitOverflowScroll) {\n            this._touchPrevented = this._preventWebkitOverflowScrollingTouch(this.parentElement);\n          }\n\n          if (this._focusOverlayOnOpen) {\n            this._overlayContent.focus();\n\n            this._focusOverlayOnOpen = false;\n          } else {\n            this._focus();\n          }\n\n          if (this._noInput && this.focusElement) {\n            this.focusElement.blur();\n          }\n\n          this.updateStyles();\n          this._ignoreAnnounce = false;\n        } // A hack needed for iOS to prevent dropdown from being clipped in an\n        // ancestor container with -webkit-overflow-scrolling: touch;\n\n      }, {\n        key: \"_preventWebkitOverflowScrollingTouch\",\n        value: function _preventWebkitOverflowScrollingTouch(element) {\n          var result = [];\n\n          while (element) {\n            if (window.getComputedStyle(element).webkitOverflowScrolling === 'touch') {\n              var oldInlineValue = element.style.webkitOverflowScrolling;\n              element.style.webkitOverflowScrolling = 'auto';\n              result.push({\n                element: element,\n                oldInlineValue: oldInlineValue\n              });\n            }\n\n            element = element.parentElement;\n          }\n\n          return result;\n        }\n      }, {\n        key: \"_onOverlayClosed\",\n        value: function _onOverlayClosed() {\n          this._ignoreAnnounce = true;\n          window.removeEventListener('scroll', this._boundOnScroll, true);\n          this.removeEventListener('iron-resize', this._boundUpdateAlignmentAndPosition);\n\n          if (this._touchPrevented) {\n            this._touchPrevented.forEach(function (prevented) {\n              return prevented.element.style.webkitOverflowScrolling = prevented.oldInlineValue;\n            });\n\n            this._touchPrevented = [];\n          }\n\n          this.updateStyles(); // Select the parsed input or focused date\n\n          this._ignoreFocusedDateChange = true;\n\n          if (this.i18n.parseDate) {\n            var inputValue = this._inputValue || '';\n            var dateObject = this.i18n.parseDate(inputValue);\n\n            var parsedDate = dateObject && this._parseDate(\"\".concat(dateObject.year, \"-\").concat(dateObject.month + 1, \"-\").concat(dateObject.day));\n\n            if (this._isValidDate(parsedDate)) {\n              this._selectedDate = parsedDate;\n            } else {\n              this._selectedDate = null;\n              this._inputValue = inputValue;\n            }\n          } else if (this._focusedDate) {\n            this._selectedDate = this._focusedDate;\n          }\n\n          this._ignoreFocusedDateChange = false;\n\n          if (this._nativeInput && this._nativeInput.selectionStart) {\n            this._nativeInput.selectionStart = this._nativeInput.selectionEnd;\n          }\n\n          this.validate();\n        }\n        /**\n         * Returns true if `value` is valid, and sets the `invalid` flag appropriately.\n         *\n         * @param {string} value Value to validate. Optional, defaults to user's input value.\n         * @return {boolean} True if the value is valid and sets the `invalid` flag appropriately\n         */\n\n      }, {\n        key: \"validate\",\n        value: function validate(value) {\n          // reset invalid state on the underlying text field\n          this.invalid = false;\n          value = value !== undefined ? value : this._inputValue;\n          return !(this.invalid = !this.checkValidity(value));\n        }\n        /**\n         * Returns true if the current input value satisfies all constraints (if any)\n         *\n         * Override the `checkValidity` method for custom validations.\n         *\n         * @param {string} value Value to validate. Optional, defaults to the selected date.\n         * @return {boolean} True if the value is valid\n         */\n\n      }, {\n        key: \"checkValidity\",\n        value: function checkValidity(value) {\n          var inputValid = !value || this._selectedDate && value === this.i18n.formatDate(DatePickerHelper._extractDateParts(this._selectedDate));\n\n          var minMaxValid = !this._selectedDate || DatePickerHelper._dateAllowed(this._selectedDate, this._minDate, this._maxDate);\n\n          var inputValidity = true;\n\n          if (this._inputElement) {\n            if (this._inputElement.checkValidity) {\n              // vaadin native input elements have the checkValidity method\n              inputValidity = this._inputElement.checkValidity(value);\n            } else if (this._inputElement.validate) {\n              // iron-form-elements have the validate API\n              inputValidity = this._inputElement.validate(value);\n            }\n          }\n\n          return inputValid && minMaxValid && inputValidity;\n        }\n      }, {\n        key: \"_onScroll\",\n        value: function _onScroll(e) {\n          if (e.target === window || !this._overlayContent.contains(e.target)) {\n            this._updateAlignmentAndPosition();\n          }\n        }\n      }, {\n        key: \"_focus\",\n        value: function _focus() {\n          if (this._noInput) {\n            this._overlayContent.focus();\n          } else {\n            this._inputElement.focus();\n          }\n        }\n      }, {\n        key: \"_focusAndSelect\",\n        value: function _focusAndSelect() {\n          this._focus();\n\n          this._setSelectionRange(0, this._inputValue.length);\n        }\n      }, {\n        key: \"_setSelectionRange\",\n        value: function _setSelectionRange(a, b) {\n          if (this._nativeInput && this._nativeInput.setSelectionRange) {\n            this._nativeInput.setSelectionRange(a, b);\n          }\n        }\n      }, {\n        key: \"_preventDefault\",\n        value: function _preventDefault(e) {\n          e.preventDefault();\n        }\n        /**\n         * Keyboard Navigation\n         */\n\n      }, {\n        key: \"_eventKey\",\n        value: function _eventKey(e) {\n          var keys = ['down', 'up', 'enter', 'esc', 'tab'];\n\n          for (var i = 0; i < keys.length; i++) {\n            var k = keys[i];\n\n            if (IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k)) {\n              return k;\n            }\n          }\n        }\n      }, {\n        key: \"_isValidDate\",\n        value: function _isValidDate(d) {\n          return d && !isNaN(d.getTime());\n        }\n      }, {\n        key: \"_onKeydown\",\n        value: function _onKeydown(e) {\n          if (this._noInput) {\n            // The input element cannot be readonly as it would conflict with\n            // the required attribute. Both are not allowed on an input element.\n            // Therefore we prevent default on most keydown events.\n            var allowedKeys = [9 // tab\n            ];\n\n            if (allowedKeys.indexOf(e.keyCode) === -1) {\n              e.preventDefault();\n            }\n          }\n\n          switch (this._eventKey(e)) {\n            case 'down':\n            case 'up':\n              // prevent scrolling the page with arrows\n              e.preventDefault();\n\n              if (this.opened) {\n                this._overlayContent.focus();\n\n                this._overlayContent._onKeydown(e);\n              } else {\n                this._focusOverlayOnOpen = true;\n                this.open();\n              }\n\n              break;\n\n            case 'enter':\n              if (this._overlayContent.focusedDate) {\n                this._selectedDate = this._overlayContent.focusedDate;\n              }\n\n              this.close();\n              break;\n\n            case 'esc':\n              this._focusedDate = this._selectedDate;\n\n              this._close();\n\n              break;\n\n            case 'tab':\n              if (this.opened) {\n                e.preventDefault(); // Clear the selection range (remains visible on IE)\n\n                this._setSelectionRange(0, 0);\n\n                if (e.shiftKey) {\n                  this._overlayContent.focusCancel();\n                } else {\n                  this._overlayContent.focus();\n\n                  this._overlayContent.revealDate(this._focusedDate);\n                }\n              }\n\n              break;\n          }\n        }\n      }, {\n        key: \"_validateInput\",\n        value: function _validateInput(date, min, max) {\n          if (date && (min || max)) {\n            this.invalid = !DatePickerHelper._dateAllowed(date, min, max);\n          }\n        }\n      }, {\n        key: \"_onUserInput\",\n        value: function _onUserInput(e) {\n          if (!this.opened) {\n            this.open();\n          }\n\n          this._userInputValueChanged();\n        }\n      }, {\n        key: \"_userInputValueChanged\",\n        value: function _userInputValueChanged(value) {\n          if (this.opened && this._inputValue) {\n            var dateObject = this.i18n.parseDate && this.i18n.parseDate(this._inputValue);\n\n            var parsedDate = dateObject && this._parseDate(\"\".concat(dateObject.year, \"-\").concat(dateObject.month + 1, \"-\").concat(dateObject.day));\n\n            if (this._isValidDate(parsedDate)) {\n              this._ignoreFocusedDateChange = true;\n\n              if (!DatePickerHelper._dateEquals(parsedDate, this._focusedDate)) {\n                this._focusedDate = parsedDate;\n              }\n\n              this._ignoreFocusedDateChange = false;\n            }\n          }\n        }\n      }, {\n        key: \"_announceFocusedDate\",\n        value: function _announceFocusedDate(_focusedDate, opened, _ignoreAnnounce) {\n          if (opened && !_ignoreAnnounce) {\n            this._overlayContent.announceFocusedDate();\n          }\n        }\n      }, {\n        key: \"_inputElement\",\n        get: function get() {\n          return this._input();\n        }\n      }, {\n        key: \"_nativeInput\",\n        get: function get() {\n          if (this._inputElement) {\n            // vaadin-text-field's input is focusElement\n            // iron-input's input is inputElement\n            return this._inputElement.focusElement ? this._inputElement.focusElement : this._inputElement.inputElement ? this._inputElement.inputElement : window.unwrap ? window.unwrap(this._inputElement) : this._inputElement;\n          }\n        }\n      }, {\n        key: \"_overlayContent\",\n        get: function get() {\n          return this.$.overlay.content.querySelector('#overlay-content');\n        }\n        /**\n         * Fired when the user commits a value change.\n         *\n         * @event change\n         */\n\n      }], [{\n        key: \"properties\",\n        get: function get() {\n          return {\n            /**\n             * The current selected date.\n             */\n            _selectedDate: {\n              type: Date\n            },\n            _focusedDate: Date,\n\n            /**\n             * The value for this element.\n             *\n             * Supported date formats:\n             * - ISO 8601 `\"YYYY-MM-DD\"` (default)\n             * - 6-digit extended ISO 8601 `\"+YYYYYY-MM-DD\"`, `\"-YYYYYY-MM-DD\"`\n             *\n             * @type {String}\n             */\n            value: {\n              type: String,\n              observer: '_valueChanged',\n              notify: true,\n              value: ''\n            },\n\n            /**\n             * Set to true to mark the input as required.\n             */\n            required: {\n              type: Boolean,\n              value: false\n            },\n\n            /**\n             * The name of this element.\n             */\n            name: {\n              type: String\n            },\n\n            /**\n             * Date which should be visible when there is no value selected.\n             *\n             * The same date formats as for the `value` property are supported.\n             */\n            initialPosition: String,\n\n            /**\n             * The label for this element.\n             */\n            label: String,\n\n            /**\n             * Set true to open the date selector overlay.\n             */\n            opened: {\n              type: Boolean,\n              reflectToAttribute: true,\n              notify: true,\n              observer: '_openedChanged'\n            },\n\n            /**\n             * Set true to display ISO-8601 week numbers in the calendar. Notice that\n             * displaying week numbers is only supported when `i18n.firstDayOfWeek`\n             * is 1 (Monday).\n             */\n            showWeekNumbers: {\n              type: Boolean\n            },\n            _fullscreen: {\n              value: false,\n              observer: '_fullscreenChanged'\n            },\n            _fullscreenMediaQuery: {\n              value: '(max-width: 420px), (max-height: 420px)'\n            },\n            // An array of ancestor elements whose -webkit-overflow-scrolling is forced from value\n            // 'touch' to value 'auto' in order to prevent them from clipping the dropdown. iOS only.\n            _touchPrevented: Array,\n\n            /**\n             * The object used to localize this component.\n             * To change the default localization, replace the entire\n             * _i18n_ object or just the property you want to modify.\n             *\n             * The object has the following JSON structure and default values:\n                 {\n                  // An array with the full names of months starting\n                  // with January.\n                  monthNames: [\n                    'January', 'February', 'March', 'April', 'May',\n                    'June', 'July', 'August', 'September',\n                    'October', 'November', 'December'\n                  ],\n                   // An array of weekday names starting with Sunday. Used\n                  // in screen reader announcements.\n                  weekdays: [\n                    'Sunday', 'Monday', 'Tuesday', 'Wednesday',\n                    'Thursday', 'Friday', 'Saturday'\n                  ],\n                   // An array of short weekday names starting with Sunday.\n                  // Displayed in the calendar.\n                  weekdaysShort: [\n                    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'\n                  ],\n                   // An integer indicating the first day of the week\n                  // (0 = Sunday, 1 = Monday, etc.).\n                  firstDayOfWeek: 0,\n                   // Used in screen reader announcements along with week\n                  // numbers, if they are displayed.\n                  week: 'Week',\n                   // Translation of the Calendar icon button title.\n                  calendar: 'Calendar',\n                   // Translation of the Clear icon button title.\n                  clear: 'Clear',\n                   // Translation of the Today shortcut button text.\n                  today: 'Today',\n                   // Translation of the Cancel button text.\n                  cancel: 'Cancel',\n                   // A function to format given `Object` as\n                  // date string. Object is in the format `{ day: ..., month: ..., year: ... }`\n                  formatDate: d => {\n                    // returns a string representation of the given\n                    // object in 'MM/DD/YYYY' -format\n                  },\n                   // A function to parse the given text to an `Object` in the format `{ day: ..., month: ..., year: ... }`.\n                  // Must properly parse (at least) text\n                  // formatted by `formatDate`.\n                  // Setting the property to null will disable\n                  // keyboard input feature.\n                  parseDate: text => {\n                    // Parses a string in 'MM/DD/YY', 'MM/DD' or 'DD' -format to\n                    // an `Object` in the format `{ day: ..., month: ..., year: ... }`.\n                  }\n                   // A function to format given `monthName` and\n                  // `fullYear` integer as calendar title string.\n                  formatTitle: (monthName, fullYear) => {\n                    return monthName + ' ' + fullYear;\n                  }\n                }\n              *\n             * @default {English/US}\n             */\n            i18n: {\n              type: Object,\n              value: function value() {\n                return {\n                  monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n                  weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n                  weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n                  firstDayOfWeek: 0,\n                  week: 'Week',\n                  calendar: 'Calendar',\n                  clear: 'Clear',\n                  today: 'Today',\n                  cancel: 'Cancel',\n                  formatDate: function formatDate(d) {\n                    var yearStr = String(d.year).replace(/\\d+/, function (y) {\n                      return '0000'.substr(y.length) + y;\n                    });\n                    return [d.month + 1, d.day, yearStr].join('/');\n                  },\n                  parseDate: function parseDate(text) {\n                    var parts = text.split('/');\n                    var today = new Date();\n                    var date,\n                        month = today.getMonth(),\n                        year = today.getFullYear();\n\n                    if (parts.length === 3) {\n                      year = parseInt(parts[2]);\n\n                      if (parts[2].length < 3 && year >= 0) {\n                        year += year < 50 ? 2000 : 1900;\n                      }\n\n                      month = parseInt(parts[0]) - 1;\n                      date = parseInt(parts[1]);\n                    } else if (parts.length === 2) {\n                      month = parseInt(parts[0]) - 1;\n                      date = parseInt(parts[1]);\n                    } else if (parts.length === 1) {\n                      date = parseInt(parts[0]);\n                    }\n\n                    if (date !== undefined) {\n                      return {\n                        day: date,\n                        month: month,\n                        year: year\n                      };\n                    }\n                  },\n                  formatTitle: function formatTitle(monthName, fullYear) {\n                    return monthName + ' ' + fullYear;\n                  }\n                };\n              }\n            },\n\n            /**\n             * The earliest date that can be selected. All earlier dates will be disabled.\n             *\n             * Supported date formats:\n             * - ISO 8601 `\"YYYY-MM-DD\"` (default)\n             * - 6-digit extended ISO 8601 `\"+YYYYYY-MM-DD\"`, `\"-YYYYYY-MM-DD\"`\n             *\n             * @type {String}\n             */\n            min: {\n              type: String,\n              observer: '_minChanged'\n            },\n\n            /**\n             * The latest date that can be selected. All later dates will be disabled.\n             *\n             * Supported date formats:\n             * - ISO 8601 `\"YYYY-MM-DD\"` (default)\n             * - 6-digit extended ISO 8601 `\"+YYYYYY-MM-DD\"`, `\"-YYYYYY-MM-DD\"`\n             *\n             * @type {String}\n             */\n            max: {\n              type: String,\n              observer: '_maxChanged'\n            },\n\n            /**\n             * The earliest date that can be selected. All earlier dates will be disabled.\n             */\n            _minDate: {\n              type: Date,\n              // null does not work here because minimizer passes undefined to overlay (#351)\n              value: ''\n            },\n\n            /**\n             * The latest date that can be selected. All later dates will be disabled.\n             */\n            _maxDate: {\n              type: Date,\n              value: ''\n            },\n            _noInput: {\n              type: Boolean,\n              computed: '_isNoInput(_fullscreen, _ios, i18n, i18n.*)'\n            },\n            _ios: {\n              type: Boolean,\n              value: navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/)\n            },\n            _webkitOverflowScroll: {\n              type: Boolean,\n              value: document.createElement('div').style.webkitOverflowScrolling === ''\n            },\n            _ignoreAnnounce: {\n              value: true\n            },\n            _focusOverlayOnOpen: Boolean\n          };\n        }\n      }, {\n        key: \"observers\",\n        get: function get() {\n          return ['_updateHasValue(value)', '_validateInput(_selectedDate, _minDate, _maxDate)', '_selectedDateChanged(_selectedDate, i18n.formatDate)', '_focusedDateChanged(_focusedDate, i18n.formatDate)', '_announceFocusedDate(_focusedDate, opened, _ignoreAnnounce)'];\n        }\n      }]);\n\n      return VaadinDatePickerMixin;\n    }(mixinBehaviors([IronResizableBehavior], subclass))\n  );\n};","map":null,"metadata":{},"sourceType":"module"}